"use strict";exports.id=776,exports.ids=[776],exports.modules={4931:(e,t,i)=>{i.d(t,{CE:()=>r.CE,Cf:()=>r.Cf,Fw:()=>r.Fw,Pb:()=>r.Pb,gz:()=>r.gz,j1:()=>r.j1,v3:()=>r.v3,yI:()=>r.yI});var r=i(5807)},6991:(e,t,i)=>{i.d(t,{n:()=>h});var r=i(3258),s=i(4448),n=i.n(s),a=i(7265);class o{constructor(e){this.client=e}async get(e){try{let t=await this.client.get(e);return t?JSON.parse(t):null}catch(e){return r.A.error("Redis get error:",e),null}}async set(e,t,i){try{let r=JSON.stringify(t);i?await this.client.setex(e,i,r):await this.client.set(e,r)}catch(e){r.A.error("Redis set error:",e)}}async del(e){try{await this.client.del(e)}catch(e){r.A.error("Redis del error:",e)}}async clear(){try{await this.client.flushdb()}catch(e){r.A.error("Redis clear error:",e)}}async exists(e){try{let t=await this.client.exists(e);return 1===t}catch(e){return r.A.error("Redis exists error:",e),!1}}}class c{constructor(e){this.cache=new a.q({max:e.max,ttl:e.ttl?1e3*e.ttl:void 0})}async get(e){return this.cache.get(e)||null}async set(e,t,i){i?this.cache.set(e,t,{ttl:1e3*i}):this.cache.set(e,t)}async del(e){this.cache.delete(e)}async clear(){this.cache.clear()}async exists(e){return this.cache.has(e)}}class l{constructor(){this.initializeCache()}static getInstance(){return l.instance||(l.instance=new l),l.instance}initializeCache(){let e=process.env.REDIS_URL;if(e)try{this.redisClient=new(n())(e,{maxRetriesPerRequest:3,lazyConnect:!0}),this.redisClient.on("error",e=>{r.A.error("Redis connection error:",e),this.fallbackToLRU()}),this.redisClient.on("connect",()=>{r.A.info("Redis connected successfully")}),this.cache=new o(this.redisClient),r.A.info("Cache initialized with Redis")}catch(e){r.A.error("Failed to initialize Redis, falling back to LRU cache:",e),this.fallbackToLRU()}else this.fallbackToLRU()}fallbackToLRU(){this.cache=new c({max:1e3,ttl:3600}),r.A.info("Cache initialized with LRU cache")}getCache(){return this.cache}getRedisClient(){return this.redisClient}isUsingRedis(){return void 0!==this.redisClient}async close(){this.redisClient&&await this.redisClient.quit()}}let d=l.getInstance();d.getCache();class h{constructor(e){this.prisma=e,this.cache=d.getCache(),r.A.info("PermissionService initialized with cache manager")}async getUserEffectivePermissions(e){let t=`user:${e}:permissions`;try{let i=await this.cache.get(t);if(i)return r.A.debug(`[Cache HIT] Permissions for user ${e}`),new Set(i)}catch(e){r.A.error("Error reading from cache:",e)}r.A.debug(`[DB Fetch] Fetching permissions from DB for user ${e}`);let i=await this.prisma.user.findUnique({where:{id:e,isActive:!0},include:{userRoles:{where:{role:{isActive:!0},OR:[{expiresAt:null},{expiresAt:{gt:new Date}}]},include:{role:{include:{rolePermissions:{where:{permission:{isActive:!0}},include:{permission:!0}}}}}}}});if(!i){let i=new Set;return await this.cache.set(t,[],900),r.A.debug(`[Cache SET] Empty permissions for user ${e} stored in cache.`),i}let s=new Set;i.userRoles.forEach(e=>{e.role&&e.role.isActive&&(e.expiresAt&&e.expiresAt.getTime()<=Date.now()||e.role.rolePermissions.forEach(e=>{e.permission&&e.permission.isActive&&e.permission.name&&s.add(e.permission.name)}))});let n=Array.from(s);return await this.cache.set(t,n,900),r.A.debug(`[Cache SET] Permissions for user ${e} stored in cache.`),s}async clearUserPermissionCache(e){let t=`user:${e}:permissions`;try{await this.cache.del(t),r.A.info(`[Cache Cleared] Permissions for user ${e}`)}catch(e){r.A.error(`[PermissionService] Cache DEL error for key ${t}:`,e)}}async clearCachesAffectedByRoleChange(e){r.A.info(`[Cache Invalidation] Role ${e} changed. Clearing all user permission caches.`);try{await this.cache.clear(),r.A.debug("[Cache] All user permission caches cleared due to role change.")}catch(e){r.A.error("[PermissionService] Error clearing caches after role change:",e)}}async checkPermission(e,t){return!!t&&(await this.getUserEffectivePermissions(e)).has(t)}async checkBatchPermissions(e,t){if(!t||0===t.length)return[];let i=await this.getUserEffectivePermissions(e),r=[];for(let e of t){if(!e.name){r.push({id:e.id,allowed:!1,reasonCode:"INVALID_REQUEST_FORMAT",message:"Request missing canonical permission name."});continue}let t=i.has(e.name),s="",n="PERMISSION_DENIED";t?(s="Operation allowed.",n="PERMISSION_GRANTED"):0===i.size?(s="User has no effective permissions.",n="NO_PERMISSIONS"):(s=`Permission '${e.name}' denied or not found in user's effective permissions.`,n="PERMISSION_DENIED"),r.push({id:e.id,allowed:t,reasonCode:n,message:s})}return r}}},9776:(e,t,i)=>{i.d(t,{PC:()=>I,Bu:()=>y,DU:()=>m,ls:()=>p,L3:()=>w,e8:()=>v});var r=i(5511),s=i.n(r),n=i(5212),a=i(4736),o=i(2229),c=i(1047),l=i(3040),d=i(7151),h=i(8891),u=i(4958);i(6991);let f=new(i(6991)).n(u.z);var g=i(4931);let p={INVALID_REQUEST:"invalid_request",INVALID_CLIENT:"invalid_client",INVALID_GRANT:"invalid_grant",UNAUTHORIZED_CLIENT:"unauthorized_client",UNSUPPORTED_GRANT_TYPE:"unsupported_grant_type",INVALID_SCOPE:"invalid_scope",ACCESS_DENIED:"access_denied",UNSUPPORTED_RESPONSE_TYPE:"unsupported_response_type",SERVER_ERROR:"server_error",TEMPORARILY_UNAVAILABLE:"temporarily_unavailable"};class w{static generateCodeVerifier(){return s().randomBytes(32).toString("base64url")}static generateCodeChallenge(e){return s().createHash("sha256").update(e).digest("base64url")}static verifyCodeChallenge(e,t,i="S256"){return"S256"!==i?(console.warn(`PKCEUtils: Unsupported code_challenge_method: ${i}`),!1):this.generateCodeChallenge(e)===t}static validateCodeChallenge(e){return/^[A-Za-z0-9\-._~]{43,128}$/.test(e)}static validateCodeVerifier(e){return/^[A-Za-z0-9\-._~]{43,128}$/.test(e)}}class v{static parseScopes(e){return e?e.split(" ").filter(e=>e.length>0):[]}static formatScopes(e){return e.join(" ")}static validateScopes(e,t){if(0===e.length)return{valid:!0,invalidScopes:[]};if(Array.isArray(t)){let i=e.filter(e=>!t.includes(e));return{valid:0===i.length,invalidScopes:i,error_description:i.length>0?`Requested scope(s) not in allowed list: ${i.join(", ")}`:void 0}}return(async()=>{let i=[];if(t.allowedScopes)try{i=JSON.parse(t.allowedScopes),Array.isArray(i)||(i=[])}catch(e){console.error("Failed to parse client.allowedScopes for client ID:",t.id,e),i=[]}let r=e.filter(e=>!i.includes(e));if(r.length>0)return{valid:!1,invalidScopes:r,error_description:`Requested scope(s) not allowed for this client: ${r.join(", ")}`};let s=(await h.z.scope.findMany({where:{name:{in:e},isActive:!0}})).map(e=>e.name),n=e.filter(e=>!s.includes(e));return n.length>0?{valid:!1,invalidScopes:n,error_description:`Requested scope(s) are invalid or inactive: ${n.join(", ")}`}:(t.clientType,{valid:!0,invalidScopes:[]})})()}static hasScope(e,t){return e.includes(t)}static hasAnyScope(e,t){return t.some(t=>e.includes(t))}static hasAllScopes(e,t){return t.every(t=>e.includes(t))}}class m{static async getRSAPrivateKeyForSigning(){let e=process.env.JWT_PRIVATE_KEY_PEM,t=process.env.JWT_ALGORITHM||"RS256";if(!e){let e="JWT_PRIVATE_KEY_PEM is not set. Please configure it via environment variables.";throw console.error(`${e} (Production)`),new g.j1(e)}try{return await n.Lf(e,t)}catch(e){throw console.error("Failed to import RSA private key (PKCS8):",e),new g.j1("Invalid RSA private key (JWT_PRIVATE_KEY_PEM) format or configuration.",{originalError:e.message})}}static async getRSAPublicKeyForVerification(){let e=process.env.JWT_PUBLIC_KEY_PEM,t=process.env.JWT_ALGORITHM||"RS256";if(!e){let e="JWT_PUBLIC_KEY_PEM is not set. Please configure it via environment variables.";throw console.error(`${e} (Production)`),new g.j1(e)}try{return await n.jU(e,t)}catch(i){console.warn("Failed to import RSA public key as SPKI, trying as X.509 certificate...",i);try{return await n.Mh(e,t)}catch(e){throw console.error("Failed to import RSA public key (SPKI or X.509):",e),new g.j1("Invalid RSA public key (JWT_PUBLIC_KEY_PEM) format or configuration. Supported formats: SPKI PEM, X.509 PEM.",{originalError:e.message})}}}static getIssuer(){let e=process.env.JWT_ISSUER;if(!e)throw new g.j1("JWT_ISSUER is not set in production environment");return e}static getAudience(){let e=process.env.JWT_AUDIENCE;if(!e)throw new g.j1("JWT_AUDIENCE is not set in production environment");return e}static async createAccessToken(e){let t=process.env.JWT_ALGORITHM||"RS256",i=process.env.JWT_KEY_ID||"default-kid",r={client_id:e.client_id,sub:e.user_id||e.client_id,aud:this.getAudience(),iss:this.getIssuer(),jti:s().randomUUID(),iat:Math.floor(Date.now()/1e3),scope:e.scope,permissions:e.permissions||[]};return Object.keys(r).forEach(e=>void 0===r[e]&&delete r[e]),await new a.P(r).setProtectedHeader({alg:t,kid:i}).setExpirationTime(e.exp||"1h").sign(await this.getRSAPrivateKeyForSigning())}static getTokenHash(e){return s().createHash("sha256").update(e).digest("hex")}static async verifyAccessToken(e){let t=process.env.JWT_ALGORITHM||"RS256";try{let{payload:i}=await o.V(e,await this.getRSAPublicKeyForVerification(),{issuer:this.getIssuer(),audience:this.getAudience(),algorithms:[t]});if(i.jti&&await h.z.tokenBlacklist.findUnique({where:{jti:i.jti}}))return{valid:!1,error:"Token has been revoked (JTI blacklisted)"};return{valid:!0,payload:i}}catch(t){let e="Token verification failed";return console.error("Access Token Verification Error:",t),t instanceof c.n?e="Token has expired":t instanceof c.ie?e=`Token claim validation failed: ${t.claim} ${t.reason}`:(t instanceof c.Ye||t instanceof c.h2)&&(e="Invalid token or signature"),{valid:!1,error:e}}}static async createRefreshToken(e){let t=process.env.JWT_ALGORITHM||"RS256",i=process.env.JWT_KEY_ID||"default-kid",r={client_id:e.client_id,sub:e.user_id||e.client_id,aud:this.getAudience(),iss:this.getIssuer(),jti:s().randomUUID(),iat:Math.floor(Date.now()/1e3),scope:e.scope,token_type:"refresh"};return Object.keys(r).forEach(e=>void 0===r[e]&&delete r[e]),await new a.P(r).setProtectedHeader({alg:t,kid:i}).setExpirationTime(e.exp||"30d").sign(await this.getRSAPrivateKeyForSigning())}static async verifyRefreshToken(e){let t=process.env.JWT_ALGORITHM||"RS256";try{let{payload:i}=await o.V(e,await this.getRSAPublicKeyForVerification(),{issuer:this.getIssuer(),audience:this.getAudience(),algorithms:[t]});if("refresh"!==i.token_type)return console.warn("Invalid token type for refresh token verification:",i.token_type),{valid:!1,error:"Invalid token type: expected refresh token"};if(i.jti&&await h.z.tokenBlacklist.findUnique({where:{jti:i.jti}}))return{valid:!1,error:"Refresh token has been revoked (JTI blacklisted)"};return{valid:!0,payload:i}}catch(t){let e="Refresh token verification failed";return console.error("Refresh Token Verification Error:",t),t instanceof c.n?e="Refresh token has expired":t instanceof c.ie?e=`Refresh token claim validation failed: ${t.claim} ${t.reason}`:(t instanceof c.Ye||t instanceof c.h2)&&(e="Invalid refresh token or signature"),{valid:!1,error:e}}}static async createIdToken(e,t,i){let r=process.env.JWT_ALGORITHM||"RS256",n=process.env.JWT_KEY_ID||"default-kid",o={iss:this.getIssuer(),sub:e.id,aud:t.clientId,exp:Math.floor(Date.now()/1e3)+3600,iat:Math.floor(Date.now()/1e3),jti:s().randomUUID(),name:`${e.firstName||""} ${e.lastName||""}`.trim()||void 0,given_name:e.firstName||void 0,family_name:e.lastName||void 0,preferred_username:e.username||void 0,nonce:i};return Object.keys(o).forEach(e=>void 0===o[e]&&delete o[e]),await new a.P(o).setProtectedHeader({alg:r,kid:n}).sign(await this.getRSAPrivateKeyForSigning())}static async decodeTokenPayload(e,t){try{return l.i(e)}catch(e){throw Error(`Failed to decode token payload: ${e.message}`)}}static async verifyAndDecodeRefreshToken(e,t){let i=await this.verifyRefreshToken(e);if(!i.valid||!i.payload)throw Error(i.error||"Invalid refresh token");if(i.payload.client_id!==t.clientId)throw Error("Token client_id does not match authenticated client");return{...i.payload,client_id:i.payload.client_id,token_type:i.payload.token_type||"refresh_token",user_id:i.payload.user_id,scope:i.payload.scope}}}class y{static async authenticateClient(e,t){let i=t.get("client_id"),r=t.get("client_secret"),s=t.get("client_assertion_type"),n=t.get("client_assertion"),a=e.headers.get("authorization");if(a&&a.toLowerCase().startsWith("basic "))try{let e=a.slice(6),[t,s]=Buffer.from(e,"base64").toString("utf-8").split(":");t&&s&&(i=i||t,r=r||s)}catch{throw new g.gz("Invalid Basic authentication header format.",g.Fw.InvalidClient,401)}if("urn:ietf:params:oauth:client-assertion-type:jwt-bearer"===s&&n)return await this.authenticateWithJWT(n,e);if(i&&r)return await this.authenticateWithSecret(i,r);if(i&&!r){let e=await h.z.oAuthClient.findUnique({where:{clientId:i,isActive:!0}});if(!e)throw new g.gz("Client not found.",g.Fw.InvalidClient,401);if("PUBLIC"!==e.clientType)throw new g.gz("客户端不是公开客户端，需要身份验证",g.Fw.InvalidClient,401);return e}throw new g.gz("Client authentication required but not provided or method not supported.",g.Fw.InvalidClient,401)}static async authenticateWithSecret(e,t){let r=await h.z.oAuthClient.findUnique({where:{clientId:e,isActive:!0}});if(!r)throw new g.gz("Invalid client ID or client not active.",g.Fw.InvalidClient,401);if("PUBLIC"===r.clientType)throw new g.gz("公开客户端试图使用密钥进行身份验证",g.Fw.InvalidClient,400);if(!r.clientSecret)throw console.error(`客户端 ${e} 在数据库中缺少客户端密钥`),new g.j1("此客户端未配置客户端密钥");try{let e=await Promise.resolve().then(i.t.bind(i,5486,23));if(!await e.compare(t,r.clientSecret))throw new g.gz("客户端密钥无效",g.Fw.InvalidClient,401)}catch(e){throw console.error("客户端密钥验证期间bcrypt.compare发生错误:",e),new g.j1("客户端密钥验证期间发生错误")}return r}static async authenticateWithJWT(e,t){try{let i=l.i(e);if(!i.iss||!i.sub||i.iss!==i.sub)throw new g.gz("Invalid JWT assertion: iss and sub claims are required and must be identical (client_id).",g.Fw.InvalidClient,400);let r=i.iss,s=await h.z.oAuthClient.findUnique({where:{clientId:r,isActive:!0}});if(!s)throw new g.gz("Client specified in JWT assertion not found or not active.",g.Fw.InvalidClient,401);if(!s.jwksUri)throw new g.j1("Client is not configured for JWT assertion-based authentication (missing jwks_uri).",{missingJwksUri:!0});let n=this.getTokenEndpointUrl(t),a=d.RD(new URL(s.jwksUri));return await o.V(e,a,{issuer:r,audience:n,algorithms:["RS256","ES256","PS256"]}),s}catch(i){console.error("Client JWT assertion validation failed:",i);let e="Client assertion validation failed.",t=g.Fw.InvalidClient;if(i instanceof c.n)e="Client assertion has expired.",t=g.Fw.InvalidGrant;else if(i instanceof c.ie)e=`Client assertion claim validation failed: ${i.claim} ${i.reason}.`;else if(i instanceof c.h2)e="Client assertion signature verification failed.";else if(i instanceof g.j1)throw i;throw new g.gz(e,t,400,void 0,{originalError:i.message})}}static getTokenEndpointUrl(e){let t=new URL(e.url),i=e.headers.get("x-forwarded-proto")||t.protocol.slice(0,-1),r=e.headers.get("x-forwarded-host")||t.host,s=process.env.OAUTH_TOKEN_ENDPOINT_PATH||"/api/v2/oauth/token";return`${i}://${r}${s}`}}class I{static validateRedirectUri(e,t){return t.includes(e)}static validateResponseType(e,t=["code"]){return t.includes(e)}static generateState(){return s().randomBytes(32).toString("base64url")}static generateNonce(){return s().randomBytes(32).toString("base64url")}static generateAuthorizationCode(){return s().randomBytes(32).toString("hex")}static async logAuditEvent(e){try{let t="SYSTEM",i="system";if(e.userId)t="USER",i=e.userId;else if(e.clientId){t="CLIENT";let r=await h.z.oAuthClient.findUnique({where:{id:e.clientId},select:{clientId:!0}});i=r?r.clientId:e.clientId}let r=e.success;void 0===r&&(r=e.status?"SUCCESS"===e.status:!e.errorMessage),await h.z.auditLog.create({data:{action:e.action,actorType:t,actorId:i||"unknown",status:r?"SUCCESS":"FAILURE",ipAddress:e.ipAddress||null,userAgent:e.userAgent||null,details:this.buildDetailsJson(e)||void 0}})}catch(e){console.error("Failed to log audit event:",e)}}static buildDetailsJson(e){let t={};if(e.metadata&&(t={...t,...e.metadata}),e.errorMessage&&(t.errorMessage=e.errorMessage),e.details)try{let i=JSON.parse(e.details);t={...t,...i}}catch{t.rawDetails=e.details}return Object.keys(t).length>0?JSON.stringify(t):null}static async getUserPermissions(e){try{let t=await f.getUserEffectivePermissions(e);return Array.from(t)}catch(e){return console.error("Error getting user permissions:",e),[]}}}class A{static{this.requests=new Map}static isRateLimited(e,t=100,i=6e4){if("true"===process.env.DISABLE_RATE_LIMITING||e.startsWith("test-")||e.includes("192.168.")||e.includes("127.0.0.1")||"unknown"===e)return!1;let r=Date.now(),s=this.requests.get(e);return!s||r>s.resetTime?(this.requests.set(e,{count:1,resetTime:r+i}),!1):s.count>=t||(s.count++,!1)}static getRateLimitKey(e,t="ip"){if("ip"===t){let t=e.headers.get("x-forwarded-for"),i=e.headers.get("x-real-ip");return t?.split(",")[0]?.trim()||i||"unknown"}return console.warn("Client-based rate limiting key generation is placeholder. Implement actual client ID extraction."),"client-rate-limit-placeholder"}static clearCache(){this.requests.clear(),console.log("Rate limit cache cleared.")}static setTestRateLimit(e,t,i){console.warn("setTestRateLimit called outside of test environment. Operation ignored.")}}}};