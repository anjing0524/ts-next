"use strict";exports.id=776,exports.ids=[776],exports.modules={4344:(e,t,i)=>{i.d(t,{S:()=>n});var r=i(4958);class n{static async getUserPermissions(e){let t=await r.z.user.findUnique({where:{id:e,isActive:!0},include:{userRoles:{include:{role:{include:{rolePermissions:{include:{permission:!0}}}}}}}});if(!t)return null;let i=t.userRoles.map(e=>e.role.name),n=new Set;return t.userRoles.forEach(e=>{e.role.rolePermissions.forEach(e=>{n.add(e.permission.name)})}),{userId:t.id,roles:i,permissions:Array.from(n),organizationContext:{organization:t.organization||void 0,department:t.department||void 0}}}}},4931:(e,t,i)=>{i.d(t,{CE:()=>r.CE,Cf:()=>r.Cf,Fw:()=>r.Fw,Pb:()=>r.Pb,gz:()=>r.gz,j1:()=>r.j1,v3:()=>r.v3,yI:()=>r.yI});var r=i(5807)},9776:(e,t,i)=>{i.d(t,{PC:()=>m,Bu:()=>_,DU:()=>I,ls:()=>w,L3:()=>v,e8:()=>g});var r=i(5511),n=i.n(r),a=i(5212),s=i(4736),o=i(2229),l=i(1047),c=i(3040),d=i(7151),u=i(8891),h=i(4344),f=i(4931);let p=new h.S,w={INVALID_REQUEST:"invalid_request",INVALID_CLIENT:"invalid_client",INVALID_GRANT:"invalid_grant",UNAUTHORIZED_CLIENT:"unauthorized_client",UNSUPPORTED_GRANT_TYPE:"unsupported_grant_type",INVALID_SCOPE:"invalid_scope",ACCESS_DENIED:"access_denied",UNSUPPORTED_RESPONSE_TYPE:"unsupported_response_type",SERVER_ERROR:"server_error",TEMPORARILY_UNAVAILABLE:"temporarily_unavailable"};class v{static generateCodeVerifier(){return n().randomBytes(32).toString("base64url")}static generateCodeChallenge(e){return n().createHash("sha256").update(e).digest("base64url")}static verifyCodeChallenge(e,t,i="S256"){return"S256"!==i?(console.warn(`PKCEUtils: Unsupported code_challenge_method: ${i}`),!1):this.generateCodeChallenge(e)===t}static validateCodeChallenge(e){return/^[A-Za-z0-9\-._~]{43,128}$/.test(e)}static validateCodeVerifier(e){return/^[A-Za-z0-9\-._~]{43,128}$/.test(e)}}class g{static parseScopes(e){return e?e.split(" ").filter(e=>e.length>0):[]}static formatScopes(e){return e.join(" ")}static validateScopes(e,t){if(0===e.length)return{valid:!0,invalidScopes:[]};if(Array.isArray(t)){let i=e.filter(e=>!t.includes(e));return{valid:0===i.length,invalidScopes:i,error_description:i.length>0?`Requested scope(s) not in allowed list: ${i.join(", ")}`:void 0}}return(async()=>{let i=[];if(t.allowedScopes)try{i=JSON.parse(t.allowedScopes),Array.isArray(i)||(i=[])}catch(e){console.error("Failed to parse client.allowedScopes for client ID:",t.id,e),i=[]}let r=e.filter(e=>!i.includes(e));if(r.length>0)return{valid:!1,invalidScopes:r,error_description:`Requested scope(s) not allowed for this client: ${r.join(", ")}`};let n=await u.z.scope.findMany({where:{name:{in:e},isActive:!0}}),a=n.map(e=>e.name),s=e.filter(e=>!a.includes(e));if(s.length>0)return{valid:!1,invalidScopes:s,error_description:`Requested scope(s) are invalid or inactive: ${s.join(", ")}`};if(t.isPublic){let e=n.filter(e=>!e.isPublic).map(e=>e.name);if(e.length>0)return{valid:!1,invalidScopes:e,error_description:`Public client requested non-public scope(s): ${e.join(", ")}`}}return{valid:!0,invalidScopes:[]}})()}static hasScope(e,t){return e.includes(t)}static hasAnyScope(e,t){return t.some(t=>e.includes(t))}static hasAllScopes(e,t){return t.every(t=>e.includes(t))}}class I{static async getRSAPrivateKeyForSigning(){let e=process.env.JWT_PRIVATE_KEY_PEM,t=process.env.JWT_ALGORITHM||"RS256";if(!e){let e="JWT_PRIVATE_KEY_PEM is not set. Please configure it via environment variables.";throw console.error(`${e} (Production)`),new f.j1(e,"JWT_KEY_MISSING")}try{return await a.Lf(e,t)}catch(e){throw console.error("Failed to import RSA private key (PKCS8):",e),new f.j1("Invalid RSA private key (JWT_PRIVATE_KEY_PEM) format or configuration.","JWT_KEY_INVALID_FORMAT",{originalError:e.message})}}static async getRSAPublicKeyForVerification(){let e=process.env.JWT_PUBLIC_KEY_PEM,t=process.env.JWT_ALGORITHM||"RS256";if(!e){let e="JWT_PUBLIC_KEY_PEM is not set. Please configure it via environment variables.";throw console.error(`${e} (Production)`),new f.j1(e,"JWT_PUB_KEY_MISSING")}try{return await a.jU(e,t)}catch(i){console.warn("Failed to import RSA public key as SPKI, trying as X.509 certificate...",i);try{return await a.Mh(e,t)}catch(e){throw console.error("Failed to import RSA public key (SPKI or X.509):",e),new f.j1("Invalid RSA public key (JWT_PUBLIC_KEY_PEM) format or configuration. Supported formats: SPKI PEM, X.509 PEM.","JWT_PUB_KEY_INVALID_FORMAT",{originalError:e.message})}}}static getIssuer(){let e=process.env.JWT_ISSUER;if(!e)throw new f.j1("JWT_ISSUER is not set in production environment","JWT_ISSUER_MISSING");return e}static getAudience(){let e=process.env.JWT_AUDIENCE;if(!e)throw new f.j1("JWT_AUDIENCE is not set in production environment","JWT_AUDIENCE_MISSING");return e}static async createAccessToken(e){let t=process.env.JWT_ALGORITHM||"RS256",i=process.env.JWT_KEY_ID||"default-kid",r={client_id:e.client_id,sub:e.user_id||e.client_id,aud:this.getAudience(),iss:this.getIssuer(),jti:n().randomUUID(),iat:Math.floor(Date.now()/1e3),scope:e.scope,permissions:e.permissions||[]};return Object.keys(r).forEach(e=>void 0===r[e]&&delete r[e]),await new s.P(r).setProtectedHeader({alg:t,kid:i}).setExpirationTime(e.exp||"1h").sign(await this.getRSAPrivateKeyForSigning())}static getTokenHash(e){return n().createHash("sha256").update(e).digest("hex")}static async verifyAccessToken(e){let t=process.env.JWT_ALGORITHM||"RS256";try{let{payload:i}=await o.V(e,await this.getRSAPublicKeyForVerification(),{issuer:this.getIssuer(),audience:this.getAudience(),algorithms:[t]});if(i.jti&&await u.z.tokenBlacklist.findUnique({where:{jti:i.jti}}))return{valid:!1,error:"Token has been revoked (JTI blacklisted)"};return{valid:!0,payload:i}}catch(t){let e="Token verification failed";return console.error("Access Token Verification Error:",t),t instanceof l.n?e="Token has expired":t instanceof l.ie?e=`Token claim validation failed: ${t.claim} ${t.reason}`:(t instanceof l.Ye||t instanceof l.h2)&&(e="Invalid token or signature"),{valid:!1,error:e}}}static async createRefreshToken(e){let t=process.env.JWT_ALGORITHM||"RS256",i=process.env.JWT_KEY_ID||"default-kid",r={client_id:e.client_id,sub:e.user_id||e.client_id,aud:this.getAudience(),iss:this.getIssuer(),jti:n().randomUUID(),iat:Math.floor(Date.now()/1e3),scope:e.scope,token_type:"refresh"};return Object.keys(r).forEach(e=>void 0===r[e]&&delete r[e]),await new s.P(r).setProtectedHeader({alg:t,kid:i}).setExpirationTime(e.exp||"30d").sign(await this.getRSAPrivateKeyForSigning())}static async verifyRefreshToken(e){let t=process.env.JWT_ALGORITHM||"RS256";try{let{payload:i}=await o.V(e,await this.getRSAPublicKeyForVerification(),{issuer:this.getIssuer(),audience:this.getAudience(),algorithms:[t]});if("refresh"!==i.token_type)return console.warn("Invalid token type for refresh token verification:",i.token_type),{valid:!1,error:"Invalid token type: expected refresh token"};if(i.jti&&await u.z.tokenBlacklist.findUnique({where:{jti:i.jti}}))return{valid:!1,error:"Refresh token has been revoked (JTI blacklisted)"};return{valid:!0,payload:i}}catch(t){let e="Refresh token verification failed";return console.error("Refresh Token Verification Error:",t),t instanceof l.n?e="Refresh token has expired":t instanceof l.ie?e=`Refresh token claim validation failed: ${t.claim} ${t.reason}`:(t instanceof l.Ye||t instanceof l.h2)&&(e="Invalid refresh token or signature"),{valid:!1,error:e}}}static async createIdToken(e,t,i){let r=process.env.JWT_ALGORITHM||"RS256",a=process.env.JWT_KEY_ID||"default-kid",o={iss:this.getIssuer(),sub:e.id,aud:t.clientId,exp:Math.floor(Date.now()/1e3)+3600,iat:Math.floor(Date.now()/1e3),jti:n().randomUUID(),email:e.email,email_verified:e.emailVerified??!1,name:`${e.firstName||""} ${e.lastName||""}`.trim()||void 0,given_name:e.firstName||void 0,family_name:e.lastName||void 0,preferred_username:e.username||void 0,nonce:i};return Object.keys(o).forEach(e=>void 0===o[e]&&delete o[e]),await new s.P(o).setProtectedHeader({alg:r,kid:a}).sign(await this.getRSAPrivateKeyForSigning())}}class _{static async authenticateClient(e,t){let i=t.get("client_id"),r=t.get("client_secret"),n=t.get("client_assertion_type"),a=t.get("client_assertion"),s=e.headers.get("authorization");if(s&&s.toLowerCase().startsWith("basic "))try{let e=s.slice(6),[t,n]=Buffer.from(e,"base64").toString("utf-8").split(":");t&&n&&(i=i||t,r=r||n)}catch{throw new f.gz("Invalid Basic authentication header format.",f.Fw.InvalidClient,401)}if("urn:ietf:params:oauth:client-assertion-type:jwt-bearer"===n&&a)return await this.authenticateWithJWT(a,e);if(i&&r)return await this.authenticateWithSecret(i,r);if(i&&!r){let e=await u.z.oAuthClient.findUnique({where:{clientId:i,isActive:!0}});if(!e)throw new f.gz("Client not found.",f.Fw.InvalidClient,401);if(!e.isPublic)throw new f.gz("Client is not a public client and requires authentication.",f.Fw.InvalidClient,401);return e}throw new f.gz("Client authentication required but not provided or method not supported.",f.Fw.InvalidClient,401)}static async authenticateWithSecret(e,t){let r=await u.z.oAuthClient.findUnique({where:{clientId:e,isActive:!0}});if(!r)throw new f.gz("Invalid client ID or client not active.",f.Fw.InvalidClient,401);if(r.isPublic)throw new f.gz("Public client attempted to authenticate with a secret.",f.Fw.InvalidClient,400);if(!r.clientSecret)throw console.error(`Client ${e} is missing clientSecret in database.`),new f.j1("Client secret not configured for this client.","CLIENT_CONFIG_MISSING_SECRET");try{let e=await Promise.resolve().then(i.t.bind(i,5486,23));if(!await e.compare(t,r.clientSecret))throw new f.gz("Invalid client secret.",f.Fw.InvalidClient,401)}catch(e){throw console.error("Error during bcrypt.compare for client secret validation:",e),new f.Cf("Error during client secret validation.",500,"CRYPTO_ERROR")}if(r.clientSecretExpiresAt&&r.clientSecretExpiresAt<new Date)throw new f.gz("Client secret has expired.",f.Fw.InvalidClient,401);return r}static async authenticateWithJWT(e,t){try{let i=c.i(e);if(!i.iss||!i.sub||i.iss!==i.sub)throw new f.gz("Invalid JWT assertion: iss and sub claims are required and must be identical (client_id).",f.Fw.InvalidClient,400);let r=i.iss,n=await u.z.oAuthClient.findUnique({where:{clientId:r,isActive:!0}});if(!n)throw new f.gz("Client specified in JWT assertion not found or not active.",f.Fw.InvalidClient,401);if(!n.jwksUri)throw new f.j1("Client is not configured for JWT assertion-based authentication (missing jwks_uri).","CLIENT_CONFIG_MISSING_JWKS_URI");let a=this.getTokenEndpointUrl(t),s=d.RD(new URL(n.jwksUri));return await o.V(e,s,{issuer:r,audience:a,algorithms:["RS256","ES256","PS256"]}),n}catch(i){console.error("Client JWT assertion validation failed:",i);let e="Client assertion validation failed.",t=f.Fw.InvalidClient;if(i instanceof l.n)e="Client assertion has expired.",t=f.Fw.InvalidGrant;else if(i instanceof l.ie)e=`Client assertion claim validation failed: ${i.claim} ${i.reason}.`;else if(i instanceof l.h2)e="Client assertion signature verification failed.";else if(i instanceof f.j1)throw i;throw new f.gz(e,t,400,void 0,{originalError:i.message})}}static getTokenEndpointUrl(e){let t=new URL(e.url),i=e.headers.get("x-forwarded-proto")||t.protocol.slice(0,-1),r=e.headers.get("x-forwarded-host")||t.host,n=process.env.OAUTH_TOKEN_ENDPOINT_PATH||"/api/v2/oauth/token";return`${i}://${r}${n}`}}class m{static validateRedirectUri(e,t){return t.includes(e)}static validateResponseType(e,t=["code"]){return t.includes(e)}static generateState(){return n().randomBytes(32).toString("base64url")}static generateNonce(){return n().randomBytes(32).toString("base64url")}static generateAuthorizationCode(){return n().randomBytes(32).toString("hex")}static async logAuditEvent(e){try{let t=null;if(e.userId){let i=await u.z.user.findUnique({where:{id:e.userId},select:{id:!0}});t=i?e.userId:null,i||console.warn(`Audit log: User ID ${e.userId} not found.`)}let i=null;if(e.clientId){let t=await u.z.oAuthClient.findUnique({where:{clientId:e.clientId}});if(t)i=t.id;else{let t=await u.z.oAuthClient.findUnique({where:{id:e.clientId}});t?i=t.id:console.warn(`Audit log: Client with identifier ${e.clientId} not found.`)}}let r="SYSTEM",n=null;if(t)r="USER",n=t;else if(i){r="CLIENT";let t=await u.z.oAuthClient.findUnique({where:{id:i}});n=t?t.clientId:e.clientId}await u.z.auditLog.create({data:{user:t?{connect:{id:t}}:void 0,client:i?{connect:{id:i}}:void 0,action:e.action,resourceType:e.resourceType||null,resourceId:e.resourceId||null,ipAddress:e.ipAddress||null,userAgent:e.userAgent||null,success:e.success,errorMessage:e.errorMessage||null,metadata:e.metadata?JSON.stringify(e.metadata):null,status:e.success?"SUCCESS":"FAILURE",actorType:r,actorId:n}})}catch(e){console.error("Failed to log audit event:",e)}}static async getUserPermissions(e){return e?Array.from(await p.getUserEffectivePermissions(e)):[]}}class S{static{this.requests=new Map}static isRateLimited(e,t=100,i=6e4){if("true"===process.env.DISABLE_RATE_LIMITING||e.startsWith("test-")||e.includes("192.168.")||e.includes("127.0.0.1")||"unknown"===e)return!1;let r=Date.now(),n=this.requests.get(e);return!n||r>n.resetTime?(this.requests.set(e,{count:1,resetTime:r+i}),!1):n.count>=t||(n.count++,!1)}static getRateLimitKey(e,t="ip"){return"ip"===t?e.headers.get("x-forwarded-for")?.split(",")[0].trim()||e.headers.get("x-real-ip")||e.ip||"unknown":(console.warn("Client-based rate limiting key generation is placeholder. Implement actual client ID extraction."),"client-rate-limit-placeholder")}static clearCache(){this.requests.clear(),console.log("Rate limit cache cleared.")}static setTestRateLimit(e,t,i){console.warn("setTestRateLimit called outside of test environment. Operation ignored.")}}}};