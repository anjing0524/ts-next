# OAuth2.1认证授权中心详细测试方案

> **文档版本**: v1.0.0  
> **创建日期**: 2024-01-20  
> **适用范围**: OAuth2.1认证授权中心完整系统  
> **测试策略**: TDD + 自动化测试 + 持续集成  
> **维护团队**: 质量保证团队

## 目录

- [1. 测试策略概述](#1-测试策略概述)
- [2. 单元测试详细方案](#2-单元测试详细方案)
- [3. 集成测试详细方案](#3-集成测试详细方案)
- [4. 安全测试详细方案](#4-安全测试详细方案)
- [5. 性能测试详细方案](#5-性能测试详细方案)
- [6. 端到端测试详细方案](#6-端到端测试详细方案)
- [7. 测试环境配置](#7-测试环境配置)
- [8. 测试数据管理](#8-测试数据管理)
- [9. 测试自动化流水线](#9-测试自动化流水线)
- [10. 测试报告和指标](#10-测试报告和指标)

## 1. 测试策略概述

### 1.1 测试金字塔

```
测试分层策略:

           /\     E2E Tests (10%)
          /  \    - 用户场景测试
         /    \   - 浏览器自动化
        /______\  - 关键业务流程
       /        \
      /          \  Integration Tests (20%)
     /            \ - API接口测试
    /              \- 数据库集成测试
   /________________\- 第三方服务集成
  /                  \
 /                    \ Unit Tests (70%)
/______________________\- 函数级别测试
                        - 组件测试
                        - 工具函数测试
```

### 1.2 测试覆盖目标

| 测试类型 | 覆盖率目标 | 执行频率 | 执行时间 |
|----------|------------|----------|----------|
| 单元测试 | ≥ 85% | 每次提交 | < 5分钟 |
| 集成测试 | ≥ 75% | 每次合并 | < 15分钟 |
| 安全测试 | 100%关键路径 | 每日构建 | < 30分钟 |
| 性能测试 | 核心API | 每周执行 | < 60分钟 |
| E2E测试 | 主要用户流程 | 发布前 | < 45分钟 |

### 1.3 测试工具栈

```typescript
// 测试技术栈
const testStack = {
  unitTesting: {
    framework: 'Jest',
    utilities: ['@testing-library/react', '@testing-library/jest-dom'],
    mocking: ['jest.mock', 'msw'],
    coverage: 'jest --coverage'
  },
  integrationTesting: {
    api: 'Supertest',
    database: 'Test Containers',
    fixtures: 'Factory Bot'
  },
  e2eTesting: {
    framework: 'Playwright',
    browsers: ['Chromium', 'Firefox', 'Safari'],
    mobile: 'Device Emulation'
  },
  performanceTesting: {
    loadTesting: 'K6',
    monitoring: 'Grafana K6',
    profiling: 'Node.js Profiler'
  },
  securityTesting: {
    staticAnalysis: 'SonarQube',
    dependencyCheck: 'npm audit',
    penetrationTesting: 'OWASP ZAP'
  }
};
```

## 2. 单元测试详细方案

### 2.1 OAuth2.1核心功能测试

#### 2.1.1 PKCE参数生成测试

```typescript
// tests/unit/oauth/pkce.test.ts
import { generatePKCE, verifyPKCE } from '@/lib/oauth/pkce';
import { createHash, randomBytes } from 'crypto';

describe('PKCE参数生成和验证', () => {
  describe('generatePKCE', () => {
    it('应该生成符合RFC 7636标准的code_verifier', () => {
      const { codeVerifier, codeChallenge } = generatePKCE();
      
      // code_verifier长度应该在43-128字符之间
      expect(codeVerifier.length).toBeGreaterThanOrEqual(43);
      expect(codeVerifier.length).toBeLessThanOrEqual(128);
      
      // 只包含允许的字符
      expect(codeVerifier).toMatch(/^[A-Za-z0-9\-._~]+$/);
    });

    it('应该生成正确的code_challenge', () => {
      const { codeVerifier, codeChallenge } = generatePKCE();
      
      // 验证SHA256哈希
      const expectedChallenge = createHash('sha256')
        .update(codeVerifier)
        .digest('base64url');
      
      expect(codeChallenge).toBe(expectedChallenge);
    });

    it('每次调用应该生成不同的参数', () => {
      const pkce1 = generatePKCE();
      const pkce2 = generatePKCE();
      
      expect(pkce1.codeVerifier).not.toBe(pkce2.codeVerifier);
      expect(pkce1.codeChallenge).not.toBe(pkce2.codeChallenge);
    });
  });

  describe('verifyPKCE', () => {
    it('应该验证正确的PKCE参数', () => {
      const { codeVerifier, codeChallenge } = generatePKCE();
      
      const isValid = verifyPKCE(codeVerifier, codeChallenge);
      expect(isValid).toBe(true);
    });

    it('应该拒绝错误的code_verifier', () => {
      const { codeChallenge } = generatePKCE();
      const wrongVerifier = 'wrong_verifier';
      
      const isValid = verifyPKCE(wrongVerifier, codeChallenge);
      expect(isValid).toBe(false);
    });

    it('应该拒绝格式错误的参数', () => {
      expect(() => verifyPKCE('', 'challenge')).toThrow();
      expect(() => verifyPKCE('verifier', '')).toThrow();
    });
  });
});
```

#### 2.1.2 JWT令牌管理测试

```typescript
// tests/unit/auth/jwt.test.ts
import { JWTManager } from '@/lib/auth/jwt';
import { sign, verify } from 'jsonwebtoken';

describe('JWT令牌管理', () => {
  let jwtManager: JWTManager;
  const mockSecret = 'test-secret-key';
  const mockPayload = {
    userId: '123',
    email: 'test@example.com',
    roles: ['user']
  };

  beforeEach(() => {
    jwtManager = new JWTManager({
      secret: mockSecret,
      accessTokenExpiry: '15m',
      refreshTokenExpiry: '7d'
    });
  });

  describe('generateAccessToken', () => {
    it('应该生成有效的访问令牌', async () => {
      const token = await jwtManager.generateAccessToken(mockPayload);
      
      expect(typeof token).toBe('string');
      expect(token.split('.')).toHaveLength(3); // JWT格式
      
      // 验证令牌内容
      const decoded = verify(token, mockSecret) as any;
      expect(decoded.userId).toBe(mockPayload.userId);
      expect(decoded.email).toBe(mockPayload.email);
      expect(decoded.type).toBe('access');
    });

    it('应该设置正确的过期时间', async () => {
      const token = await jwtManager.generateAccessToken(mockPayload);
      const decoded = verify(token, mockSecret) as any;
      
      const now = Math.floor(Date.now() / 1000);
      const expectedExp = now + (15 * 60); // 15分钟
      
      expect(decoded.exp).toBeCloseTo(expectedExp, -1);
    });

    it('应该包含JTI用于令牌撤销', async () => {
      const token = await jwtManager.generateAccessToken(mockPayload);
      const decoded = verify(token, mockSecret) as any;
      
      expect(decoded.jti).toBeDefined();
      expect(typeof decoded.jti).toBe('string');
      expect(decoded.jti.length).toBeGreaterThan(0);
    });
  });

  describe('verifyToken', () => {
    it('应该验证有效令牌', async () => {
      const token = await jwtManager.generateAccessToken(mockPayload);
      const result = await jwtManager.verifyToken(token);
      
      expect(result.valid).toBe(true);
      expect(result.payload?.userId).toBe(mockPayload.userId);
    });

    it('应该拒绝过期令牌', async () => {
      // 创建已过期的令牌
      const expiredToken = sign(
        { ...mockPayload, exp: Math.floor(Date.now() / 1000) - 3600 },
        mockSecret
      );
      
      const result = await jwtManager.verifyToken(expiredToken);
      expect(result.valid).toBe(false);
      expect(result.error).toContain('expired');
    });

    it('应该拒绝被撤销的令牌', async () => {
      const token = await jwtManager.generateAccessToken(mockPayload);
      const decoded = verify(token, mockSecret) as any;
      
      // 模拟令牌撤销
      await jwtManager.revokeToken(decoded.jti);
      
      const result = await jwtManager.verifyToken(token);
      expect(result.valid).toBe(false);
      expect(result.error).toContain('revoked');
    });
  });
});
```

#### 2.1.3 权限验证测试

```typescript
// tests/unit/auth/permissions.test.ts
import { PermissionService } from '@/lib/auth/permissions';
import { mockPrisma } from '../__mocks__/prisma';

describe('权限验证服务', () => {
  let permissionService: PermissionService;

  beforeEach(() => {
    permissionService = new PermissionService(mockPrisma);
    jest.clearAllMocks();
  });

  describe('checkUserPermission', () => {
    it('应该验证用户具有的权限', async () => {
      // 模拟用户权限数据
      mockPrisma.user.findUnique.mockResolvedValue({
        id: '1',
        roles: [
          {
            role: {
              permissions: [
                { permission: { code: 'user:read', type: 'API' } }
              ]
            }
          }
        ]
      });

      const hasPermission = await permissionService.checkUserPermission(
        '1',
        'user:read',
        'API'
      );

      expect(hasPermission).toBe(true);
    });

    it('应该拒绝用户没有的权限', async () => {
      mockPrisma.user.findUnique.mockResolvedValue({
        id: '1',
        roles: []
      });

      const hasPermission = await permissionService.checkUserPermission(
        '1',
        'admin:write',
        'API'
      );

      expect(hasPermission).toBe(false);
    });

    it('应该处理不存在的用户', async () => {
      mockPrisma.user.findUnique.mockResolvedValue(null);

      await expect(
        permissionService.checkUserPermission('999', 'user:read', 'API')
      ).rejects.toThrow('User not found');
    });
  });

  describe('getUserPermissions', () => {
    it('应该返回用户的所有权限', async () => {
      const mockPermissions = [
        { code: 'user:read', type: 'API' },
        { code: 'user:write', type: 'API' },
        { code: 'dashboard:view', type: 'MENU' }
      ];

      mockPrisma.user.findUnique.mockResolvedValue({
        id: '1',
        roles: [
          {
            role: {
              permissions: mockPermissions.map(p => ({ permission: p }))
            }
          }
        ]
      });

      const permissions = await permissionService.getUserPermissions('1');

      expect(permissions).toHaveLength(3);
      expect(permissions).toEqual(expect.arrayContaining(mockPermissions));
    });

    it('应该去重复的权限', async () => {
      // 模拟用户有多个角色，包含重复权限
      mockPrisma.user.findUnique.mockResolvedValue({
        id: '1',
        roles: [
          {
            role: {
              permissions: [
                { permission: { code: 'user:read', type: 'API' } }
              ]
            }
          },
          {
            role: {
              permissions: [
                { permission: { code: 'user:read', type: 'API' } },
                { permission: { code: 'user:write', type: 'API' } }
              ]
            }
          }
        ]
      });

      const permissions = await permissionService.getUserPermissions('1');

      expect(permissions).toHaveLength(2);
      expect(permissions.filter(p => p.code === 'user:read')).toHaveLength(1);
    });
  });
});
```

### 2.2 中间件测试

#### 2.2.1 认证中间件测试

```typescript
// tests/unit/middleware/auth.test.ts
import { authMiddleware } from '@/middleware/auth';
import { NextRequest } from 'next/server';
import { JWTManager } from '@/lib/auth/jwt';

describe('认证中间件', () => {
  let mockJWTManager: jest.Mocked<JWTManager>;

  beforeEach(() => {
    mockJWTManager = {
      verifyToken: jest.fn(),
      generateAccessToken: jest.fn(),
      revokeToken: jest.fn()
    } as any;
  });

  it('应该允许有效令牌通过', async () => {
    const validToken = 'valid.jwt.token';
    const request = new NextRequest('http://localhost/api/protected', {
      headers: {
        authorization: `Bearer ${validToken}`
      }
    });

    mockJWTManager.verifyToken.mockResolvedValue({
      valid: true,
      payload: { userId: '1', email: 'test@example.com' }
    });

    const response = await authMiddleware(request, mockJWTManager);

    expect(response.status).toBe(200);
    expect(mockJWTManager.verifyToken).toHaveBeenCalledWith(validToken);
  });

  it('应该拒绝无效令牌', async () => {
    const invalidToken = 'invalid.jwt.token';
    const request = new NextRequest('http://localhost/api/protected', {
      headers: {
        authorization: `Bearer ${invalidToken}`
      }
    });

    mockJWTManager.verifyToken.mockResolvedValue({
      valid: false,
      error: 'Token expired'
    });

    const response = await authMiddleware(request, mockJWTManager);

    expect(response.status).toBe(401);
  });

  it('应该拒绝缺少Authorization头的请求', async () => {
    const request = new NextRequest('http://localhost/api/protected');

    const response = await authMiddleware(request, mockJWTManager);

    expect(response.status).toBe(401);
    expect(mockJWTManager.verifyToken).not.toHaveBeenCalled();
  });

  it('应该拒绝格式错误的Authorization头', async () => {
    const request = new NextRequest('http://localhost/api/protected', {
      headers: {
        authorization: 'InvalidFormat token'
      }
    });

    const response = await authMiddleware(request, mockJWTManager);

    expect(response.status).toBe(401);
    expect(mockJWTManager.verifyToken).not.toHaveBeenCalled();
  });
});
```

#### 2.2.2 权限中间件测试

```typescript
// tests/unit/middleware/permissions.test.ts
import { permissionMiddleware } from '@/middleware/permissions';
import { PermissionService } from '@/lib/auth/permissions';
import { NextRequest } from 'next/server';

describe('权限中间件', () => {
  let mockPermissionService: jest.Mocked<PermissionService>;

  beforeEach(() => {
    mockPermissionService = {
      checkUserPermission: jest.fn(),
      getUserPermissions: jest.fn()
    } as any;
  });

  it('应该允许有权限的用户访问', async () => {
    const request = new NextRequest('http://localhost/api/admin/users', {
      headers: {
        'x-user-id': '1'
      }
    });

    mockPermissionService.checkUserPermission.mockResolvedValue(true);

    const response = await permissionMiddleware(
      request,
      mockPermissionService,
      'admin:users:read'
    );

    expect(response.status).toBe(200);
    expect(mockPermissionService.checkUserPermission).toHaveBeenCalledWith(
      '1',
      'admin:users:read',
      'API'
    );
  });

  it('应该拒绝无权限的用户访问', async () => {
    const request = new NextRequest('http://localhost/api/admin/users', {
      headers: {
        'x-user-id': '1'
      }
    });

    mockPermissionService.checkUserPermission.mockResolvedValue(false);

    const response = await permissionMiddleware(
      request,
      mockPermissionService,
      'admin:users:read'
    );

    expect(response.status).toBe(403);
  });

  it('应该处理权限检查异常', async () => {
    const request = new NextRequest('http://localhost/api/admin/users', {
      headers: {
        'x-user-id': '1'
      }
    });

    mockPermissionService.checkUserPermission.mockRejectedValue(
      new Error('Database connection failed')
    );

    const response = await permissionMiddleware(
      request,
      mockPermissionService,
      'admin:users:read'
    );

    expect(response.status).toBe(500);
  });
});
```

### 2.3 工具函数测试

#### 2.3.1 加密工具测试

```typescript
// tests/unit/utils/crypto.test.ts
import {
  hashPassword,
  verifyPassword,
  generateSecureToken,
  encryptData,
  decryptData
} from '@/lib/utils/crypto';

describe('加密工具函数', () => {
  describe('密码哈希', () => {
    it('应该生成安全的密码哈希', async () => {
      const password = 'testPassword123!';
      const hash = await hashPassword(password);
      
      expect(hash).toBeDefined();
      expect(hash).not.toBe(password);
      expect(hash.length).toBeGreaterThan(50); // bcrypt哈希长度
    });

    it('应该验证正确的密码', async () => {
      const password = 'testPassword123!';
      const hash = await hashPassword(password);
      
      const isValid = await verifyPassword(password, hash);
      expect(isValid).toBe(true);
    });

    it('应该拒绝错误的密码', async () => {
      const password = 'testPassword123!';
      const wrongPassword = 'wrongPassword456!';
      const hash = await hashPassword(password);
      
      const isValid = await verifyPassword(wrongPassword, hash);
      expect(isValid).toBe(false);
    });

    it('相同密码应该生成不同的哈希', async () => {
      const password = 'testPassword123!';
      const hash1 = await hashPassword(password);
      const hash2 = await hashPassword(password);
      
      expect(hash1).not.toBe(hash2);
    });
  });

  describe('安全令牌生成', () => {
    it('应该生成指定长度的安全令牌', () => {
      const token32 = generateSecureToken(32);
      const token64 = generateSecureToken(64);
      
      expect(token32.length).toBe(64); // hex编码后长度翻倍
      expect(token64.length).toBe(128);
    });

    it('应该生成不同的令牌', () => {
      const token1 = generateSecureToken(32);
      const token2 = generateSecureToken(32);
      
      expect(token1).not.toBe(token2);
    });

    it('应该只包含十六进制字符', () => {
      const token = generateSecureToken(32);
      expect(token).toMatch(/^[0-9a-f]+$/);
    });
  });

  describe('数据加密解密', () => {
    const testData = 'sensitive user data';
    const encryptionKey = 'test-encryption-key-32-characters!';

    it('应该正确加密和解密数据', () => {
      const encrypted = encryptData(testData, encryptionKey);
      const decrypted = decryptData(encrypted, encryptionKey);
      
      expect(encrypted).not.toBe(testData);
      expect(decrypted).toBe(testData);
    });

    it('相同数据应该生成不同的加密结果', () => {
      const encrypted1 = encryptData(testData, encryptionKey);
      const encrypted2 = encryptData(testData, encryptionKey);
      
      expect(encrypted1).not.toBe(encrypted2);
    });

    it('错误的密钥应该无法解密', () => {
      const encrypted = encryptData(testData, encryptionKey);
      const wrongKey = 'wrong-encryption-key-32-characters!';
      
      expect(() => {
        decryptData(encrypted, wrongKey);
      }).toThrow();
    });
  });
});
```

## 3. 集成测试详细方案

### 3.1 API接口集成测试

#### 3.1.1 OAuth2.1授权流程测试

```typescript
// tests/integration/oauth/authorization-flow.test.ts
import request from 'supertest';
import { app } from '@/app';
import { TestDatabase } from '../helpers/test-database';
import { TestDataFactory } from '../helpers/test-data-factory';

describe('OAuth2.1授权流程集成测试', () => {
  let testDb: TestDatabase;
  let testData: TestDataFactory;

  beforeAll(async () => {
    testDb = new TestDatabase();
    await testDb.setup();
    testData = new TestDataFactory(testDb.prisma);
  });

  afterAll(async () => {
    await testDb.teardown();
  });

  beforeEach(async () => {
    await testDb.reset();
  });

  describe('授权码流程', () => {
    it('应该完成完整的授权码流程', async () => {
      // 1. 创建测试数据
      const client = await testData.createOAuthClient({
        clientId: 'test-client',
        clientSecret: 'test-secret',
        redirectUris: ['http://localhost:3000/callback'],
        grantTypes: ['authorization_code'],
        responseTypes: ['code']
      });

      const user = await testData.createUser({
        email: 'test@example.com',
        password: 'password123'
      });

      // 2. 生成PKCE参数
      const { codeVerifier, codeChallenge } = generatePKCE();
      const state = generateSecureToken(16);

      // 3. 发起授权请求
      const authResponse = await request(app)
        .get('/api/oauth/authorize')
        .query({
          client_id: client.clientId,
          response_type: 'code',
          redirect_uri: client.redirectUris[0],
          scope: 'openid profile email',
          state,
          code_challenge: codeChallenge,
          code_challenge_method: 'S256'
        })
        .expect(302);

      // 4. 模拟用户登录和授权
      const loginResponse = await request(app)
        .post('/api/auth/login')
        .send({
          email: user.email,
          password: 'password123'
        })
        .expect(200);

      const sessionCookie = loginResponse.headers['set-cookie'];

      // 5. 用户同意授权
      const consentResponse = await request(app)
        .post('/api/oauth/consent')
        .set('Cookie', sessionCookie)
        .send({
          client_id: client.clientId,
          scope: 'openid profile email',
          allow: true
        })
        .expect(302);

      // 6. 提取授权码
      const redirectUrl = new URL(consentResponse.headers.location);
      const authorizationCode = redirectUrl.searchParams.get('code');
      const returnedState = redirectUrl.searchParams.get('state');

      expect(authorizationCode).toBeDefined();
      expect(returnedState).toBe(state);

      // 7. 交换访问令牌
      const tokenResponse = await request(app)
        .post('/api/oauth/token')
        .send({
          grant_type: 'authorization_code',
          client_id: client.clientId,
          client_secret: client.clientSecret,
          code: authorizationCode,
          redirect_uri: client.redirectUris[0],
          code_verifier: codeVerifier
        })
        .expect(200);

      // 8. 验证令牌响应
      expect(tokenResponse.body).toMatchObject({
        access_token: expect.any(String),
        token_type: 'Bearer',
        expires_in: expect.any(Number),
        refresh_token: expect.any(String),
        scope: 'openid profile email'
      });

      // 9. 使用访问令牌访问受保护资源
      const userInfoResponse = await request(app)
        .get('/api/oauth/userinfo')
        .set('Authorization', `Bearer ${tokenResponse.body.access_token}`)
        .expect(200);

      expect(userInfoResponse.body).toMatchObject({
        sub: user.id,
        email: user.email,
        email_verified: true
      });
    });

    it('应该拒绝无效的PKCE参数', async () => {
      const client = await testData.createOAuthClient();
      const { codeChallenge } = generatePKCE();
      const wrongVerifier = 'wrong_verifier';

      // 获取授权码
      const authCode = await testData.createAuthorizationCode({
        clientId: client.clientId,
        userId: (await testData.createUser()).id,
        codeChallenge
      });

      // 尝试用错误的code_verifier交换令牌
      await request(app)
        .post('/api/oauth/token')
        .send({
          grant_type: 'authorization_code',
          client_id: client.clientId,
          client_secret: client.clientSecret,
          code: authCode.code,
          redirect_uri: client.redirectUris[0],
          code_verifier: wrongVerifier
        })
        .expect(400)
        .expect((res) => {
          expect(res.body.error).toBe('invalid_grant');
          expect(res.body.error_description).toContain('PKCE');
        });
    });
  });

  describe('刷新令牌流程', () => {
    it('应该使用刷新令牌获取新的访问令牌', async () => {
      const client = await testData.createOAuthClient();
      const user = await testData.createUser();
      
      // 创建初始令牌
      const { accessToken, refreshToken } = await testData.createTokenPair({
        clientId: client.clientId,
        userId: user.id
      });

      // 使用刷新令牌获取新令牌
      const response = await request(app)
        .post('/api/oauth/token')
        .send({
          grant_type: 'refresh_token',
          client_id: client.clientId,
          client_secret: client.clientSecret,
          refresh_token: refreshToken.token
        })
        .expect(200);

      expect(response.body).toMatchObject({
        access_token: expect.any(String),
        token_type: 'Bearer',
        expires_in: expect.any(Number),
        refresh_token: expect.any(String)
      });

      // 新的访问令牌应该不同于原来的
      expect(response.body.access_token).not.toBe(accessToken.token);
    });

    it('应该撤销使用过的刷新令牌', async () => {
      const client = await testData.createOAuthClient();
      const user = await testData.createUser();
      const { refreshToken } = await testData.createTokenPair({
        clientId: client.clientId,
        userId: user.id
      });

      // 第一次使用刷新令牌
      await request(app)
        .post('/api/oauth/token')
        .send({
          grant_type: 'refresh_token',
          client_id: client.clientId,
          client_secret: client.clientSecret,
          refresh_token: refreshToken.token
        })
        .expect(200);

      // 第二次使用相同的刷新令牌应该失败
      await request(app)
        .post('/api/oauth/token')
        .send({
          grant_type: 'refresh_token',
          client_id: client.clientId,
          client_secret: client.clientSecret,
          refresh_token: refreshToken.token
        })
        .expect(400)
        .expect((res) => {
          expect(res.body.error).toBe('invalid_grant');
        });
    });
  });
});
```

#### 3.1.2 用户管理API测试

```typescript
// tests/integration/api/users.test.ts
import request from 'supertest';
import { app } from '@/app';
import { TestDatabase } from '../helpers/test-database';
import { TestDataFactory } from '../helpers/test-data-factory';

describe('用户管理API集成测试', () => {
  let testDb: TestDatabase;
  let testData: TestDataFactory;
  let adminToken: string;
  let userToken: string;

  beforeAll(async () => {
    testDb = new TestDatabase();
    await testDb.setup();
    testData = new TestDataFactory(testDb.prisma);

    // 创建管理员和普通用户
    const admin = await testData.createUser({
      email: 'admin@example.com',
      roles: ['admin']
    });
    const user = await testData.createUser({
      email: 'user@example.com',
      roles: ['user']
    });

    adminToken = await testData.generateAccessToken(admin.id);
    userToken = await testData.generateAccessToken(user.id);
  });

  afterAll(async () => {
    await testDb.teardown();
  });

  beforeEach(async () => {
    await testDb.resetUsers();
  });

  describe('GET /api/users', () => {
    it('管理员应该能够获取用户列表', async () => {
      await testData.createUsers(5);

      const response = await request(app)
        .get('/api/users')
        .set('Authorization', `Bearer ${adminToken}`)
        .expect(200);

      expect(response.body.data).toHaveLength(5);
      expect(response.body.pagination).toMatchObject({
        page: 1,
        limit: 20,
        total: 5
      });
    });

    it('普通用户应该无法获取用户列表', async () => {
      await request(app)
        .get('/api/users')
        .set('Authorization', `Bearer ${userToken}`)
        .expect(403);
    });

    it('应该支持分页查询', async () => {
      await testData.createUsers(25);

      const response = await request(app)
        .get('/api/users?page=2&limit=10')
        .set('Authorization', `Bearer ${adminToken}`)
        .expect(200);

      expect(response.body.data).toHaveLength(10);
      expect(response.body.pagination).toMatchObject({
        page: 2,
        limit: 10,
        total: 25
      });
    });

    it('应该支持搜索过滤', async () => {
      await testData.createUser({ email: 'john@example.com', name: 'John Doe' });
      await testData.createUser({ email: 'jane@example.com', name: 'Jane Smith' });

      const response = await request(app)
        .get('/api/users?search=john')
        .set('Authorization', `Bearer ${adminToken}`)
        .expect(200);

      expect(response.body.data).toHaveLength(1);
      expect(response.body.data[0].email).toBe('john@example.com');
    });
  });

  describe('POST /api/users', () => {
    it('管理员应该能够创建新用户', async () => {
      const userData = {
        email: 'newuser@example.com',
        name: 'New User',
        password: 'password123',
        roles: ['user']
      };

      const response = await request(app)
        .post('/api/users')
        .set('Authorization', `Bearer ${adminToken}`)
        .send(userData)
        .expect(201);

      expect(response.body.data).toMatchObject({
        email: userData.email,
        name: userData.name,
        id: expect.any(String)
      });

      // 密码不应该在响应中返回
      expect(response.body.data.password).toBeUndefined();
    });

    it('应该验证邮箱格式', async () => {
      const userData = {
        email: 'invalid-email',
        name: 'Test User',
        password: 'password123'
      };

      await request(app)
        .post('/api/users')
        .set('Authorization', `Bearer ${adminToken}`)
        .send(userData)
        .expect(400)
        .expect((res) => {
          expect(res.body.error).toContain('email');
        });
    });

    it('应该验证密码强度', async () => {
      const userData = {
        email: 'test@example.com',
        name: 'Test User',
        password: '123' // 弱密码
      };

      await request(app)
        .post('/api/users')
        .set('Authorization', `Bearer ${adminToken}`)
        .send(userData)
        .expect(400)
        .expect((res) => {
          expect(res.body.error).toContain('password');
        });
    });

    it('应该防止邮箱重复', async () => {
      const email = 'duplicate@example.com';
      await testData.createUser({ email });

      const userData = {
        email,
        name: 'Duplicate User',
        password: 'password123'
      };

      await request(app)
        .post('/api/users')
        .set('Authorization', `Bearer ${adminToken}`)
        .send(userData)
        .expect(409)
        .expect((res) => {
          expect(res.body.error).toContain('already exists');
        });
    });
  });

  describe('PUT /api/users/:id', () => {
    it('管理员应该能够更新用户信息', async () => {
      const user = await testData.createUser();
      const updateData = {
        name: 'Updated Name',
        email: 'updated@example.com'
      };

      const response = await request(app)
        .put(`/api/users/${user.id}`)
        .set('Authorization', `Bearer ${adminToken}`)
        .send(updateData)
        .expect(200);

      expect(response.body.data).toMatchObject(updateData);
    });

    it('用户应该能够更新自己的信息', async () => {
      const user = await testData.createUser();
      const userOwnToken = await testData.generateAccessToken(user.id);
      
      const updateData = {
        name: 'Self Updated Name'
      };

      const response = await request(app)
        .put(`/api/users/${user.id}`)
        .set('Authorization', `Bearer ${userOwnToken}`)
        .send(updateData)
        .expect(200);

      expect(response.body.data.name).toBe(updateData.name);
    });

    it('用户不应该能够更新其他用户信息', async () => {
      const user1 = await testData.createUser();
      const user2 = await testData.createUser();
      const user1Token = await testData.generateAccessToken(user1.id);

      await request(app)
        .put(`/api/users/${user2.id}`)
        .set('Authorization', `Bearer ${user1Token}`)
        .send({ name: 'Unauthorized Update' })
        .expect(403);
    });
  });

  describe('DELETE /api/users/:id', () => {
    it('管理员应该能够删除用户', async () => {
      const user = await testData.createUser();

      await request(app)
        .delete(`/api/users/${user.id}`)
        .set('Authorization', `Bearer ${adminToken}`)
        .expect(204);

      // 验证用户已被删除
      await request(app)
        .get(`/api/users/${user.id}`)
        .set('Authorization', `Bearer ${adminToken}`)
        .expect(404);
    });

    it('普通用户不应该能够删除用户', async () => {
      const user = await testData.createUser();

      await request(app)
        .delete(`/api/users/${user.id}`)
        .set('Authorization', `Bearer ${userToken}`)
        .expect(403);
    });

    it('不应该能够删除不存在的用户', async () => {
      await request(app)
        .delete('/api/users/non-existent-id')
        .set('Authorization', `Bearer ${adminToken}`)
        .expect(404);
    });
  });
});
```

### 3.2 数据库集成测试

#### 3.2.1 Prisma模型测试

```typescript
// tests/integration/database/models.test.ts
import { PrismaClient } from '@prisma/client';
import { TestDatabase } from '../helpers/test-database';
import { hashPassword } from '@/lib/utils/crypto';

describe('数据库模型集成测试', () => {
  let testDb: TestDatabase;
  let prisma: PrismaClient;

  beforeAll(async () => {
    testDb = new TestDatabase();
    await testDb.setup();
    prisma = testDb.prisma;
  });

  afterAll(async () => {
    await testDb.teardown();
  });

  beforeEach(async () => {
    await testDb.reset();
  });

  describe('User模型', () => {
    it('应该创建用户并建立角色关联', async () => {
      // 创建角色
      const role = await prisma.role.create({
        data: {
          name: 'user',
          description: 'Regular user role'
        }
      });

      // 创建用户
      const user = await prisma.user.create({
        data: {
          email: 'test@example.com',
          name: 'Test User',
          passwordHash: await hashPassword('password123'),
          emailVerified: true,
          roles: {
            create: {
              roleId: role.id
            }
          }
        },
        include: {
          roles: {
            include: {
              role: true
            }
          }
        }
      });

      expect(user).toMatchObject({
        email: 'test@example.com',
        name: 'Test User',
        emailVerified: true
      });
      expect(user.roles).toHaveLength(1);
      expect(user.roles[0].role.name).toBe('user');
    });

    it('应该强制邮箱唯一性', async () => {
      const email = 'duplicate@example.com';
      
      await prisma.user.create({
        data: {
          email,
          name: 'First User',
          passwordHash: await hashPassword('password123')
        }
      });

      await expect(
        prisma.user.create({
          data: {
            email,
            name: 'Second User',
            passwordHash: await hashPassword('password456')
          }
        })
      ).rejects.toThrow();
    });

    it('应该正确处理用户删除时的级联操作', async () => {
      const user = await prisma.user.create({
        data: {
          email: 'test@example.com',
          name: 'Test User',
          passwordHash: await hashPassword('password123')
        }
      });

      // 创建相关数据
      await prisma.accessToken.create({
        data: {
          token: 'test-token',
          userId: user.id,
          clientId: 'test-client',
          expiresAt: new Date(Date.now() + 3600000)
        }
      });

      await prisma.auditLog.create({
        data: {
          userId: user.id,
          action: 'LOGIN',
          resource: 'auth',
          details: {}
        }
      });

      // 删除用户
      await prisma.user.delete({
        where: { id: user.id }
      });

      // 验证相关数据也被删除
      const tokens = await prisma.accessToken.findMany({
        where: { userId: user.id }
      });
      expect(tokens).toHaveLength(0);

      const logs = await prisma.auditLog.findMany({
        where: { userId: user.id }
      });
      expect(logs).toHaveLength(0);
    });
  });

  describe('OAuth模型', () => {
    it('应该创建完整的OAuth客户端', async () => {
      const client = await prisma.oAuthClient.create({
        data: {
          clientId: 'test-client-id',
          clientSecret: 'test-client-secret',
          name: 'Test Application',
          type: 'CONFIDENTIAL',
          redirectUris: ['http://localhost:3000/callback'],
          grantTypes: ['authorization_code', 'refresh_token'],
          responseTypes: ['code'],
          scopes: ['openid', 'profile', 'email']
        }
      });

      expect(client).toMatchObject({
        clientId: 'test-client-id',
        name: 'Test Application',
        type: 'CONFIDENTIAL'
      });
      expect(client.redirectUris).toEqual(['http://localhost:3000/callback']);
      expect(client.grantTypes).toEqual(['authorization_code', 'refresh_token']);
    });

    it('应该创建授权码并关联用户和客户端', async () => {
      const user = await prisma.user.create({
        data: {
          email: 'test@example.com',
          name: 'Test User',
          passwordHash: await hashPassword('password123')
        }
      });

      const client = await prisma.oAuthClient.create({
        data: {
          clientId: 'test-client',
          clientSecret: 'test-secret',
          name: 'Test App',
          type: 'CONFIDENTIAL',
          redirectUris: ['http://localhost:3000/callback'],
          grantTypes: ['authorization_code'],
          responseTypes: ['code']
        }
      });

      const authCode = await prisma.authorizationCode.create({
        data: {
          code: 'test-auth-code',
          userId: user.id,
          clientId: client.clientId,
          redirectUri: client.redirectUris[0],
          scopes: ['openid', 'profile'],
          expiresAt: new Date(Date.now() + 600000), // 10分钟
          codeChallenge: 'test-challenge',
          codeChallengeMethod: 'S256'
        },
        include: {
          user: true,
          client: true
        }
      });

      expect(authCode.user.email).toBe('test@example.com');
      expect(authCode.client.name).toBe('Test App');
      expect(authCode.scopes).toEqual(['openid', 'profile']);
    });

    it('应该正确处理令牌过期', async () => {
      const user = await prisma.user.create({
        data: {
          email: 'test@example.com',
          name: 'Test User',
          passwordHash: await hashPassword('password123')
        }
      });

      // 创建已过期的访问令牌
      const expiredToken = await prisma.accessToken.create({
        data: {
          token: 'expired-token',
          userId: user.id,
          clientId: 'test-client',
          expiresAt: new Date(Date.now() - 3600000) // 1小时前过期
        }
      });

      // 查询有效令牌（应该排除过期的）
      const validTokens = await prisma.accessToken.findMany({
        where: {
          userId: user.id,
          expiresAt: {
            gt: new Date()
          }
        }
      });

      expect(validTokens).toHaveLength(0);

      // 查询所有令牌（包括过期的）
      const allTokens = await prisma.accessToken.findMany({
        where: {
          userId: user.id
        }
      });

      expect(allTokens).toHaveLength(1);
      expect(allTokens[0].token).toBe('expired-token');
    });
  });

  describe('权限模型', () => {
    it('应该创建完整的RBAC权限体系', async () => {
      // 创建权限
      const readPermission = await prisma.permission.create({
        data: {
          code: 'user:read',
          name: 'Read Users',
          description: 'Can read user information',
          type: 'API'
        }
      });

      const writePermission = await prisma.permission.create({
        data: {
          code: 'user:write',
          name: 'Write Users',
          description: 'Can create and update users',
          type: 'API'
        }
      });

      // 创建角色并关联权限
      const role = await prisma.role.create({
        data: {
          name: 'user_manager',
          description: 'User management role',
          permissions: {
            create: [
              { permissionId: readPermission.id },
              { permissionId: writePermission.id }
            ]
          }
        },
        include: {
          permissions: {
            include: {
              permission: true
            }
          }
        }
      });

      expect(role.permissions).toHaveLength(2);
      expect(role.permissions.map(p => p.permission.code)).toEqual(
        expect.arrayContaining(['user:read', 'user:write'])
      );

      // 创建用户并分配角色
      const user = await prisma.user.create({
        data: {
          email: 'manager@example.com',
          name: 'User Manager',
          passwordHash: await hashPassword('password123'),
          roles: {
            create: {
              roleId: role.id
            }
          }
        }
      });

      // 查询用户的所有权限
      const userWithPermissions = await prisma.user.findUnique({
        where: { id: user.id },
        include: {
          roles: {
            include: {
              role: {
                include: {
                  permissions: {
                    include: {
                      permission: true
                    }
                  }
                }
              }
            }
          }
        }
      });

      const userPermissions = userWithPermissions?.roles
        .flatMap(ur => ur.role.permissions)
        .map(rp => rp.permission.code) || [];

      expect(userPermissions).toEqual(
        expect.arrayContaining(['user:read', 'user:write'])
      );
    });
  });

  describe('审计日志', () => {
    it('应该记录用户操作审计日志', async () => {
      const user = await prisma.user.create({
        data: {
          email: 'test@example.com',
          name: 'Test User',
          passwordHash: await hashPassword('password123')
        }
      });

      const auditLog = await prisma.auditLog.create({
        data: {
          userId: user.id,
          action: 'CREATE_USER',
          resource: 'users',
          resourceId: user.id,
          details: {
            email: user.email,
            name: user.name
          },
          ipAddress: '192.168.1.1',
          userAgent: 'Test User Agent'
        }
      });

      expect(auditLog).toMatchObject({
        userId: user.id,
        action: 'CREATE_USER',
        resource: 'users',
        resourceId: user.id
      });
      expect(auditLog.details).toEqual({
        email: user.email,
        name: user.name
      });
    });

    it('应该支持审计日志查询和过滤', async () => {
      const user = await prisma.user.create({
        data: {
          email: 'test@example.com',
          name: 'Test User',
          passwordHash: await hashPassword('password123')
        }
      });

      // 创建多条审计日志
      await prisma.auditLog.createMany({
        data: [
          {
            userId: user.id,
            action: 'LOGIN',
            resource: 'auth',
            ipAddress: '192.168.1.1'
          },
          {
            userId: user.id,
            action: 'UPDATE_PROFILE',
            resource: 'users',
            resourceId: user.id,
            ipAddress: '192.168.1.1'
          },
          {
            userId: user.id,
            action: 'LOGOUT',
            resource: 'auth',
            ipAddress: '192.168.1.1'
          }
        ]
      });

      // 查询特定用户的审计日志
      const userLogs = await prisma.auditLog.findMany({
        where: {
          userId: user.id
        },
        orderBy: {
          createdAt: 'desc'
        }
      });

      expect(userLogs).toHaveLength(3);
      expect(userLogs[0].action).toBe('LOGOUT'); // 最新的

      // 查询特定操作的日志
      const authLogs = await prisma.auditLog.findMany({
        where: {
          userId: user.id,
          resource: 'auth'
        }
      });

      expect(authLogs).toHaveLength(2);
      expect(authLogs.map(log => log.action)).toEqual(
        expect.arrayContaining(['LOGIN', 'LOGOUT'])
      );
    });
  });
});
```

## 4. 安全测试详细方案

### 4.1 OAuth2.1安全测试

#### 4.1.1 PKCE安全测试

```typescript
// tests/security/oauth/pkce-security.test.ts
import request from 'supertest';
import { app } from '@/app';
import { TestDatabase } from '../helpers/test-database';
import { TestDataFactory } from '../helpers/test-data-factory';
import { generatePKCE } from '@/lib/oauth/pkce';

describe('PKCE安全测试', () => {
  let testDb: TestDatabase;
  let testData: TestDataFactory;

  beforeAll(async () => {
    testDb = new TestDatabase();
    await testDb.setup();
    testData = new TestDataFactory(testDb.prisma);
  });

  afterAll(async () => {
    await testDb.teardown();
  });

  beforeEach(async () => {
    await testDb.reset();
  });

  describe('PKCE降级攻击防护', () => {
    it('应该拒绝不使用PKCE的授权请求', async () => {
      const client = await testData.createOAuthClient({
        clientId: 'public-client',
        type: 'PUBLIC', // 公共客户端必须使用PKCE
        redirectUris: ['http://localhost:3000/callback']
      });

      //