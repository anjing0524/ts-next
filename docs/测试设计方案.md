# OAuth2.1认证授权中心测试设计方案

## 1. 测试概述

### 1.1 测试目标

本测试方案旨在确保OAuth2.1认证授权中心的以下核心功能：

- **OAuth2.1协议合规性**: 严格遵循RFC 6749、RFC 7636等标准
- **PKCE安全增强**: 验证PKCE流程的安全性和正确性
- **OIDC身份认证**: 确保OpenID Connect功能的完整性
- **RBAC权限控制**: 验证基于角色的访问控制机制
- **API安全性**: 确保所有API端点的安全性
- **性能和可靠性**: 验证系统在各种负载下的表现

### 1.2 测试范围

**包含范围**:
- OAuth2.1核心流程测试
- PKCE增强安全测试
- OIDC身份认证测试
- RBAC权限系统测试
- API接口功能测试
- 安全性测试
- 性能测试
- 兼容性测试

**排除范围**:
- 第三方依赖库的内部测试
- 基础设施层面的测试
- 操作系统级别的安全测试

### 1.3 测试策略

```mermaid
graph TB
    A[单元测试] --> B[集成测试]
    B --> C[系统测试]
    C --> D[验收测试]
    
    A1[组件测试] --> A
    A2[工具函数测试] --> A
    
    B1[API集成测试] --> B
    B2[数据库集成测试] --> B
    B3[OAuth流程集成测试] --> B
    
    C1[端到端测试] --> C
    C2[性能测试] --> C
    C3[安全测试] --> C
    
    D1[用户验收测试] --> D
    D2[业务流程验证] --> D
```

## 2. 测试环境设计

### 2.1 测试环境架构

```mermaid
graph TB
    subgraph "开发环境"
        A1[本地开发]
        A2[单元测试]
        A3[组件测试]
    end
    
    subgraph "测试环境"
        B1[集成测试]
        B2[API测试]
        B3[E2E测试]
    end
    
    subgraph "预生产环境"
        C1[性能测试]
        C2[安全测试]
        C3[压力测试]
    end
    
    subgraph "生产环境"
        D1[监控测试]
        D2[回归测试]
    end
```

### 2.2 测试数据管理

**测试数据分类**:

```typescript
interface TestDataCategory {
  users: {
    admin: User[];
    normalUsers: User[];
    disabledUsers: User[];
    testUsers: User[];
  };
  roles: {
    systemRoles: Role[];
    businessRoles: Role[];
    testRoles: Role[];
  };
  permissions: {
    menuPermissions: Permission[];
    apiPermissions: Permission[];
    dataPermissions: Permission[];
  };
  clients: {
    publicClients: OAuthClient[];
    confidentialClients: OAuthClient[];
    testClients: OAuthClient[];
  };
  tokens: {
    validTokens: Token[];
    expiredTokens: Token[];
    revokedTokens: Token[];
  };
}
```

**数据初始化策略**:
- 使用数据库种子文件
- 测试前自动清理和重建
- 隔离的测试数据库
- 数据版本控制

### 2.3 测试工具栈

**前端测试**:
- **Jest**: JavaScript测试框架
- **React Testing Library**: React组件测试
- **Cypress**: E2E测试
- **Storybook**: 组件可视化测试

**后端测试**:
- **Jest**: Node.js测试框架
- **Supertest**: HTTP接口测试
- **Prisma Test**: 数据库测试
- **Artillery**: 性能测试

**安全测试**:
- **OWASP ZAP**: 安全漏洞扫描
- **Burp Suite**: 渗透测试
- **Custom Scripts**: OAuth安全测试

## 3. OAuth2.1核心流程测试

### 3.1 授权码流程测试

#### 3.1.1 标准授权码流程

**测试用例**: `TC_OAUTH_001`

```typescript
describe('OAuth2.1 Authorization Code Flow', () => {
  test('should complete standard authorization code flow', async () => {
    // 1. 客户端重定向到授权端点
    const authUrl = buildAuthorizationUrl({
      client_id: 'test-client',
      redirect_uri: 'https://client.example.com/callback',
      response_type: 'code',
      scope: 'openid profile email',
      state: 'random-state-value'
    });
    
    // 2. 用户认证和授权
    const authResponse = await authenticateUser({
      username: 'testuser',
      password: 'password123'
    });
    
    // 3. 获取授权码
    const authCode = await authorizeClient({
      client_id: 'test-client',
      user_id: authResponse.user_id,
      scope: 'openid profile email'
    });
    
    // 4. 交换访问令牌
    const tokenResponse = await exchangeCodeForToken({
      grant_type: 'authorization_code',
      code: authCode,
      redirect_uri: 'https://client.example.com/callback',
      client_id: 'test-client',
      client_secret: 'client-secret'
    });
    
    // 验证响应
    expect(tokenResponse).toMatchObject({
      access_token: expect.any(String),
      token_type: 'Bearer',
      expires_in: expect.any(Number),
      refresh_token: expect.any(String),
      scope: 'openid profile email'
    });
  });
});
```

#### 3.1.2 PKCE增强流程测试

**测试用例**: `TC_OAUTH_002`

```typescript
describe('OAuth2.1 PKCE Enhanced Flow', () => {
  test('should complete PKCE authorization code flow', async () => {
    // 1. 生成PKCE参数
    const codeVerifier = generateCodeVerifier();
    const codeChallenge = generateCodeChallenge(codeVerifier);
    const codeChallengeMethod = 'S256';
    
    // 2. 授权请求包含PKCE参数
    const authUrl = buildAuthorizationUrl({
      client_id: 'public-client',
      redirect_uri: 'https://app.example.com/callback',
      response_type: 'code',
      scope: 'openid profile',
      code_challenge: codeChallenge,
      code_challenge_method: codeChallengeMethod,
      state: 'random-state'
    });
    
    // 3. 用户认证和授权
    const authCode = await completeAuthorization(authUrl);
    
    // 4. 令牌交换包含code_verifier
    const tokenResponse = await exchangeCodeForToken({
      grant_type: 'authorization_code',
      code: authCode,
      redirect_uri: 'https://app.example.com/callback',
      client_id: 'public-client',
      code_verifier: codeVerifier
    });
    
    // 验证PKCE流程成功
    expect(tokenResponse.access_token).toBeDefined();
    expect(tokenResponse.id_token).toBeDefined();
  });
  
  test('should reject invalid code_verifier', async () => {
    const codeVerifier = generateCodeVerifier();
    const wrongVerifier = generateCodeVerifier();
    const codeChallenge = generateCodeChallenge(codeVerifier);
    
    // 获取授权码
    const authCode = await getAuthorizationCode({
      code_challenge: codeChallenge,
      code_challenge_method: 'S256'
    });
    
    // 使用错误的code_verifier
    const tokenRequest = exchangeCodeForToken({
      grant_type: 'authorization_code',
      code: authCode,
      client_id: 'public-client',
      code_verifier: wrongVerifier
    });
    
    await expect(tokenRequest).rejects.toMatchObject({
      error: 'invalid_grant',
      error_description: 'Invalid code verifier'
    });
  });
});
```

### 3.2 刷新令牌流程测试

**测试用例**: `TC_OAUTH_003`

```typescript
describe('Refresh Token Flow', () => {
  test('should refresh access token successfully', async () => {
    // 1. 获取初始令牌
    const initialTokens = await getInitialTokens();
    
    // 2. 使用刷新令牌获取新的访问令牌
    const refreshResponse = await refreshAccessToken({
      grant_type: 'refresh_token',
      refresh_token: initialTokens.refresh_token,
      client_id: 'test-client',
      client_secret: 'client-secret'
    });
    
    // 3. 验证新令牌
    expect(refreshResponse).toMatchObject({
      access_token: expect.any(String),
      token_type: 'Bearer',
      expires_in: expect.any(Number)
    });
    
    // 4. 验证新令牌与旧令牌不同
    expect(refreshResponse.access_token).not.toBe(initialTokens.access_token);
    
    // 5. 验证旧令牌已失效
    const oldTokenValidation = await validateToken(initialTokens.access_token);
    expect(oldTokenValidation.valid).toBe(false);
  });
  
  test('should handle refresh token rotation', async () => {
    const initialTokens = await getInitialTokens();
    
    const refreshResponse = await refreshAccessToken({
      grant_type: 'refresh_token',
      refresh_token: initialTokens.refresh_token,
      client_id: 'test-client'
    });
    
    // 验证返回了新的刷新令牌
    expect(refreshResponse.refresh_token).toBeDefined();
    expect(refreshResponse.refresh_token).not.toBe(initialTokens.refresh_token);
    
    // 验证旧刷新令牌已失效
    const oldRefreshAttempt = refreshAccessToken({
      grant_type: 'refresh_token',
      refresh_token: initialTokens.refresh_token,
      client_id: 'test-client'
    });
    
    await expect(oldRefreshAttempt).rejects.toMatchObject({
      error: 'invalid_grant'
    });
  });
});
```

### 3.3 令牌撤销测试

**测试用例**: `TC_OAUTH_004`

```typescript
describe('Token Revocation', () => {
  test('should revoke access token', async () => {
    const tokens = await getValidTokens();
    
    // 撤销访问令牌
    const revokeResponse = await revokeToken({
      token: tokens.access_token,
      token_type_hint: 'access_token',
      client_id: 'test-client',
      client_secret: 'client-secret'
    });
    
    expect(revokeResponse.status).toBe(200);
    
    // 验证令牌已失效
    const tokenValidation = await validateToken(tokens.access_token);
    expect(tokenValidation.valid).toBe(false);
  });
  
  test('should revoke refresh token and cascade revoke access tokens', async () => {
    const tokens = await getValidTokens();
    
    // 撤销刷新令牌
    await revokeToken({
      token: tokens.refresh_token,
      token_type_hint: 'refresh_token',
      client_id: 'test-client'
    });
    
    // 验证相关的访问令牌也被撤销
    const accessTokenValidation = await validateToken(tokens.access_token);
    expect(accessTokenValidation.valid).toBe(false);
    
    // 验证刷新令牌无法再使用
    const refreshAttempt = refreshAccessToken({
      grant_type: 'refresh_token',
      refresh_token: tokens.refresh_token,
      client_id: 'test-client'
    });
    
    await expect(refreshAttempt).rejects.toMatchObject({
      error: 'invalid_grant'
    });
  });
});
```

## 4. OIDC身份认证测试

### 4.1 ID Token测试

**测试用例**: `TC_OIDC_001`

```typescript
describe('OpenID Connect ID Token', () => {
  test('should return valid ID token with openid scope', async () => {
    const tokenResponse = await getTokensWithScope('openid profile email');
    
    // 验证ID token存在
    expect(tokenResponse.id_token).toBeDefined();
    
    // 解析和验证ID token
    const idToken = jwt.decode(tokenResponse.id_token, { complete: true });
    
    // 验证JWT头部
    expect(idToken.header).toMatchObject({
      alg: 'RS256',
      typ: 'JWT',
      kid: expect.any(String)
    });
    
    // 验证JWT载荷
    expect(idToken.payload).toMatchObject({
      iss: process.env.ISSUER_URL,
      sub: expect.any(String),
      aud: 'test-client',
      exp: expect.any(Number),
      iat: expect.any(Number),
      auth_time: expect.any(Number),
      nonce: expect.any(String)
    });
    
    // 验证签名
    const publicKey = await getPublicKey(idToken.header.kid);
    const isValid = jwt.verify(tokenResponse.id_token, publicKey);
    expect(isValid).toBeTruthy();
  });
  
  test('should include user claims based on scope', async () => {
    const tokenResponse = await getTokensWithScope('openid profile email');
    const idToken = jwt.decode(tokenResponse.id_token);
    
    // 验证profile scope的声明
    expect(idToken).toMatchObject({
      name: expect.any(String),
      given_name: expect.any(String),
      family_name: expect.any(String),
      picture: expect.any(String)
    });
    
    // 验证email scope的声明
    expect(idToken).toMatchObject({
      email: expect.stringMatching(/^[^\s@]+@[^\s@]+\.[^\s@]+$/),
      email_verified: expect.any(Boolean)
    });
  });
});
```

### 4.2 UserInfo端点测试

**测试用例**: `TC_OIDC_002`

```typescript
describe('OIDC UserInfo Endpoint', () => {
  test('should return user information with valid access token', async () => {
    const tokens = await getTokensWithScope('openid profile email');
    
    const userInfoResponse = await fetch('/api/v2/oidc/userinfo', {
      headers: {
        'Authorization': `Bearer ${tokens.access_token}`
      }
    });
    
    expect(userInfoResponse.status).toBe(200);
    
    const userInfo = await userInfoResponse.json();
    expect(userInfo).toMatchObject({
      sub: expect.any(String),
      name: expect.any(String),
      email: expect.any(String),
      email_verified: expect.any(Boolean)
    });
  });
  
  test('should respect scope limitations', async () => {
    // 只请求profile scope
    const tokens = await getTokensWithScope('openid profile');
    
    const userInfoResponse = await fetch('/api/v2/oidc/userinfo', {
      headers: {
        'Authorization': `Bearer ${tokens.access_token}`
      }
    });
    
    const userInfo = await userInfoResponse.json();
    
    // 应该包含profile信息
    expect(userInfo.name).toBeDefined();
    
    // 不应该包含email信息
    expect(userInfo.email).toBeUndefined();
  });
});
```

### 4.3 Discovery端点测试

**测试用例**: `TC_OIDC_003`

```typescript
describe('OIDC Discovery', () => {
  test('should return well-known configuration', async () => {
    const response = await fetch('/.well-known/openid-configuration');
    expect(response.status).toBe(200);
    
    const config = await response.json();
    expect(config).toMatchObject({
      issuer: process.env.ISSUER_URL,
      authorization_endpoint: expect.stringContaining('/oauth/authorize'),
      token_endpoint: expect.stringContaining('/oauth/token'),
      userinfo_endpoint: expect.stringContaining('/oidc/userinfo'),
      jwks_uri: expect.stringContaining('/.well-known/jwks.json'),
      response_types_supported: expect.arrayContaining(['code']),
      subject_types_supported: expect.arrayContaining(['public']),
      id_token_signing_alg_values_supported: expect.arrayContaining(['RS256']),
      scopes_supported: expect.arrayContaining(['openid', 'profile', 'email']),
      token_endpoint_auth_methods_supported: expect.arrayContaining(['client_secret_basic', 'client_secret_post']),
      code_challenge_methods_supported: expect.arrayContaining(['S256'])
    });
  });
});
```

## 5. RBAC权限系统测试

### 5.1 角色权限测试

**测试用例**: `TC_RBAC_001`

```typescript
describe('RBAC Role-Based Access Control', () => {
  test('should enforce role-based API access', async () => {
    // 创建测试用户和角色
    const adminUser = await createTestUser({ roles: ['admin'] });
    const normalUser = await createTestUser({ roles: ['user'] });
    
    const adminToken = await getAccessToken(adminUser);
    const userToken = await getAccessToken(normalUser);
    
    // 管理员应该能访问管理API
    const adminResponse = await fetch('/api/v2/admin/users', {
      headers: { 'Authorization': `Bearer ${adminToken}` }
    });
    expect(adminResponse.status).toBe(200);
    
    // 普通用户应该被拒绝访问
    const userResponse = await fetch('/api/v2/admin/users', {
      headers: { 'Authorization': `Bearer ${userToken}` }
    });
    expect(userResponse.status).toBe(403);
  });
  
  test('should support hierarchical role inheritance', async () => {
    // 创建角色层次：super_admin > admin > user
    const superAdminUser = await createTestUser({ roles: ['super_admin'] });
    const token = await getAccessToken(superAdminUser);
    
    // super_admin应该继承admin和user的所有权限
    const adminApiResponse = await fetch('/api/v2/admin/roles', {
      headers: { 'Authorization': `Bearer ${token}` }
    });
    expect(adminApiResponse.status).toBe(200);
    
    const userApiResponse = await fetch('/api/v2/account/profile', {
      headers: { 'Authorization': `Bearer ${token}` }
    });
    expect(userApiResponse.status).toBe(200);
  });
});
```

### 5.2 权限检查测试

**测试用例**: `TC_RBAC_002`

```typescript
describe('Permission Checking', () => {
  test('should check single permission correctly', async () => {
    const user = await createTestUser({
      permissions: ['users:read', 'users:write']
    });
    const token = await getAccessToken(user);
    
    // 检查单个权限
    const checkResponse = await fetch('/api/v2/auth/check', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        permission: 'users:read'
      })
    });
    
    expect(checkResponse.status).toBe(200);
    const result = await checkResponse.json();
    expect(result.hasPermission).toBe(true);
  });
  
  test('should check multiple permissions in batch', async () => {
    const user = await createTestUser({
      permissions: ['users:read', 'roles:read']
    });
    const token = await getAccessToken(user);
    
    const batchCheckResponse = await fetch('/api/v2/auth/check-batch', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        permissions: ['users:read', 'users:write', 'roles:read']
      })
    });
    
    expect(batchCheckResponse.status).toBe(200);
    const result = await batchCheckResponse.json();
    expect(result).toMatchObject({
      'users:read': true,
      'users:write': false,
      'roles:read': true
    });
  });
});
```

### 5.3 数据权限测试

**测试用例**: `TC_RBAC_003`

```typescript
describe('Data-Level Permissions', () => {
  test('should filter data based on user scope', async () => {
    // 创建部门级别的用户
    const deptUser = await createTestUser({
      department: 'engineering',
      dataScope: 'department'
    });
    const token = await getAccessToken(deptUser);
    
    // 获取用户列表
    const usersResponse = await fetch('/api/v2/users', {
      headers: { 'Authorization': `Bearer ${token}` }
    });
    
    const users = await usersResponse.json();
    
    // 应该只返回同部门的用户
    expect(users.data.every(user => user.department === 'engineering')).toBe(true);
  });
  
  test('should respect field-level permissions', async () => {
    const limitedUser = await createTestUser({
      permissions: ['users:read:basic'] // 只能读取基本信息
    });
    const token = await getAccessToken(limitedUser);
    
    const userResponse = await fetch('/api/v2/users/123', {
      headers: { 'Authorization': `Bearer ${token}` }
    });
    
    const user = await userResponse.json();
    
    // 应该包含基本字段
    expect(user.id).toBeDefined();
    expect(user.name).toBeDefined();
    
    // 不应该包含敏感字段
    expect(user.email).toBeUndefined();
    expect(user.phone).toBeUndefined();
  });
});
```

## 6. API安全测试

### 6.1 认证安全测试

**测试用例**: `TC_SEC_001`

```typescript
describe('Authentication Security', () => {
  test('should prevent brute force attacks', async () => {
    const attempts = [];
    
    // 尝试多次错误登录
    for (let i = 0; i < 10; i++) {
      const attempt = fetch('/api/v2/auth/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          username: 'testuser',
          password: 'wrongpassword'
        })
      });
      attempts.push(attempt);
    }
    
    const responses = await Promise.all(attempts);
    
    // 前几次应该返回401，后面应该返回429（太多请求）
    const lastResponse = responses[responses.length - 1];
    expect(lastResponse.status).toBe(429);
  });
  
  test('should validate JWT token properly', async () => {
    // 测试无效的JWT
    const invalidTokenResponse = await fetch('/api/v2/users', {
      headers: { 'Authorization': 'Bearer invalid.jwt.token' }
    });
    expect(invalidTokenResponse.status).toBe(401);
    
    // 测试过期的JWT
    const expiredToken = generateExpiredToken();
    const expiredTokenResponse = await fetch('/api/v2/users', {
      headers: { 'Authorization': `Bearer ${expiredToken}` }
    });
    expect(expiredTokenResponse.status).toBe(401);
    
    // 测试篡改的JWT
    const validToken = await getValidToken();
    const tamperedToken = validToken.slice(0, -10) + 'tampered123';
    const tamperedTokenResponse = await fetch('/api/v2/users', {
      headers: { 'Authorization': `Bearer ${tamperedToken}` }
    });
    expect(tamperedTokenResponse.status).toBe(401);
  });
});
```

### 6.2 输入验证测试

**测试用例**: `TC_SEC_002`

```typescript
describe('Input Validation Security', () => {
  test('should prevent SQL injection', async () => {
    const token = await getValidAdminToken();
    
    // 尝试SQL注入攻击
    const maliciousInput = "'; DROP TABLE users; --";
    
    const response = await fetch('/api/v2/users', {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${token}`
      },
      body: JSON.stringify({
        search: maliciousInput
      })
    });
    
    // 应该正常处理，不会执行恶意SQL
    expect(response.status).not.toBe(500);
    
    // 验证数据库表仍然存在
    const usersStillExist = await fetch('/api/v2/users', {
      headers: { 'Authorization': `Bearer ${token}` }
    });
    expect(usersStillExist.status).toBe(200);
  });
  
  test('should sanitize XSS attempts', async () => {
    const token = await getValidAdminToken();
    
    const xssPayload = '<script>alert("XSS")</script>';
    
    const response = await fetch('/api/v2/users', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        name: xssPayload,
        email: 'test@example.com'
      })
    });
    
    if (response.status === 201) {
      const user = await response.json();
      // 恶意脚本应该被转义或移除
      expect(user.name).not.toContain('<script>');
      expect(user.name).not.toContain('alert');
    }
  });
});
```

### 6.3 授权安全测试

**测试用例**: `TC_SEC_003`

```typescript
describe('Authorization Security', () => {
  test('should prevent privilege escalation', async () => {
    const normalUser = await createTestUser({ roles: ['user'] });
    const token = await getAccessToken(normalUser);
    
    // 尝试访问管理员功能
    const adminResponse = await fetch('/api/v2/admin/users', {
      headers: { 'Authorization': `Bearer ${token}` }
    });
    expect(adminResponse.status).toBe(403);
    
    // 尝试修改自己的角色
    const roleChangeResponse = await fetch(`/api/v2/users/${normalUser.id}`, {
      method: 'PATCH',
      headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        roles: ['admin']
      })
    });
    expect(roleChangeResponse.status).toBe(403);
  });
  
  test('should prevent horizontal privilege escalation', async () => {
    const user1 = await createTestUser({ id: 'user1' });
    const user2 = await createTestUser({ id: 'user2' });
    
    const user1Token = await getAccessToken(user1);
    
    // user1尝试访问user2的数据
    const unauthorizedResponse = await fetch(`/api/v2/users/${user2.id}`, {
      headers: { 'Authorization': `Bearer ${user1Token}` }
    });
    expect(unauthorizedResponse.status).toBe(403);
    
    // user1尝试修改user2的数据
    const modifyResponse = await fetch(`/api/v2/users/${user2.id}`, {
      method: 'PATCH',
      headers: {
        'Authorization': `Bearer ${user1Token}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        name: 'Modified by user1'
      })
    });
    expect(modifyResponse.status).toBe(403);
  });
});
```

## 7. 性能测试

### 7.1 负载测试

**测试用例**: `TC_PERF_001`

```javascript
// Artillery.js配置文件
module.exports = {
  config: {
    target: 'http://localhost:3000',
    phases: [
      { duration: 60, arrivalRate: 10 }, // 预热阶段
      { duration: 300, arrivalRate: 50 }, // 正常负载
      { duration: 120, arrivalRate: 100 }, // 高负载
      { duration: 60, arrivalRate: 200 } // 峰值负载
    ],
    processor: './test-processor.js'
  },
  scenarios: [
    {
      name: 'OAuth Authorization Flow',
      weight: 40,
      flow: [
        {
          post: {
            url: '/api/v2/auth/login',
            json: {
              username: '{{ $randomString() }}@example.com',
              password: 'password123'
            },
            capture: {
              json: '$.access_token',
              as: 'accessToken'
            }
          }
        },
        {
          get: {
            url: '/api/v2/oauth/authorize',
            qs: {
              client_id: 'test-client',
              response_type: 'code',
              scope: 'openid profile'
            },
            headers: {
              'Authorization': 'Bearer {{ accessToken }}'
            }
          }
        }
      ]
    },
    {
      name: 'Token Validation',
      weight: 30,
      flow: [
        {
          function: 'generateValidToken'
        },
        {
          post: {
            url: '/api/v2/auth/check',
            json: {
              permission: 'users:read'
            },
            headers: {
              'Authorization': 'Bearer {{ accessToken }}'
            }
          }
        }
      ]
    },
    {
      name: 'API Access',
      weight: 30,
      flow: [
        {
          function: 'generateValidToken'
        },
        {
          get: {
            url: '/api/v2/users',
            headers: {
              'Authorization': 'Bearer {{ accessToken }}'
            }
          }
        }
      ]
    }
  ]
};
```

### 7.2 压力测试

**测试用例**: `TC_PERF_002`

```typescript
describe('Stress Testing', () => {
  test('should handle concurrent token requests', async () => {
    const concurrentRequests = 100;
    const requests = [];
    
    // 创建100个并发的令牌请求
    for (let i = 0; i < concurrentRequests; i++) {
      const request = fetch('/api/v2/oauth/token', {
        method: 'POST',
        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
        body: new URLSearchParams({
          grant_type: 'authorization_code',
          code: `test-code-${i}`,
          client_id: 'test-client',
          client_secret: 'test-secret'
        })
      });
      requests.push(request);
    }
    
    const startTime = Date.now();
    const responses = await Promise.all(requests);
    const endTime = Date.now();
    
    // 验证响应时间
    const totalTime = endTime - startTime;
    const averageTime = totalTime / concurrentRequests;
    expect(averageTime).toBeLessThan(1000); // 平均响应时间小于1秒
    
    // 验证成功率
    const successfulResponses = responses.filter(r => r.status === 200);
    const successRate = successfulResponses.length / responses.length;
    expect(successRate).toBeGreaterThan(0.95); // 成功率大于95%
  });
});
```

### 7.3 内存和资源测试

**测试用例**: `TC_PERF_003`

```typescript
describe('Resource Usage Testing', () => {
  test('should not have memory leaks in token generation', async () => {
    const initialMemory = process.memoryUsage();
    
    // 生成大量令牌
    for (let i = 0; i < 1000; i++) {
      await generateAccessToken({
        user_id: `user-${i}`,
        client_id: 'test-client',
        scope: 'openid profile email'
      });
      
      // 每100次检查一次内存
      if (i % 100 === 0) {
        global.gc && global.gc(); // 强制垃圾回收
        const currentMemory = process.memoryUsage();
        const memoryIncrease = currentMemory.heapUsed - initialMemory.heapUsed;
        
        // 内存增长应该在合理范围内
        expect(memoryIncrease).toBeLessThan(50 * 1024 * 1024); // 小于50MB
      }
    }
  });
});
```

## 8. 兼容性测试

### 8.1 OAuth客户端兼容性测试

**测试用例**: `TC_COMPAT_001`

```typescript
describe('OAuth Client Compatibility', () => {
  test('should work with standard OAuth libraries', async () => {
    // 测试与popular OAuth库的兼容性
    const oauthLibraries = [
      'passport-oauth2',
      'simple-oauth2',
      'oauth2-server'
    ];
    
    for (const library of oauthLibraries) {
      const client = createOAuthClient(library);
      
      // 测试授权码流程
      const authUrl = client.getAuthorizationUrl({
        scope: 'openid profile email',
        state: 'test-state'
      });
      
      expect(authUrl).toContain('/oauth/authorize');
      expect(authUrl).toContain('client_id=');
      expect(authUrl).toContain('response_type=code');
    }
  });
});
```

### 8.2 浏览器兼容性测试

**测试用例**: `TC_COMPAT_002`

```typescript
describe('Browser Compatibility', () => {
  const browsers = ['chrome', 'firefox', 'safari', 'edge'];
  
  browsers.forEach(browser => {
    test(`should work in ${browser}`, async () => {
      const page = await getBrowserPage(browser);
      
      // 测试登录流程
      await page.goto('/login');
      await page.fill('[name="username"]', 'testuser');
      await page.fill('[name="password"]', 'password123');
      await page.click('[type="submit"]');
      
      // 验证登录成功
      await page.waitForURL('/dashboard');
      expect(page.url()).toContain('/dashboard');
      
      // 测试OAuth授权
      await page.goto('/oauth/authorize?client_id=test-client&response_type=code');
      await page.click('[data-testid="authorize-button"]');
      
      // 验证重定向
      await page.waitForURL(/callback/);
      expect(page.url()).toContain('code=');
    });
  });
});
```

## 9. 端到端测试

### 9.1 完整用户流程测试

**测试用例**: `TC_E2E_001`

```typescript
describe('End-to-End User Flows', () => {
  test('complete OAuth flow from user perspective', async () => {
    const page = await browser.newPage();
    
    // 1. 用户访问第三方应用
    await page.goto('https://client-app.example.com');
    await page.click('[data-testid="login-button"]');
    
    // 2. 重定向到认证中心
    await page.waitForURL(/oauth\/authorize/);
    expect(page.url()).toContain('client_id=');
    
    // 3. 用户登录
    await page.fill('[name="username"]', 'testuser@example.com');
    await page.fill('[name="password"]', 'password123');
    await page.click('[type="submit"]');
    
    // 4. 用户授权
    await page.waitForSelector('[data-testid="authorize-button"]');
    await page.click('[data-testid="authorize-button"]');
    
    // 5. 重定向回第三方应用
    await page.waitForURL(/client-app\.example\.com/);
    
    // 6. 验证用户已登录
    const userInfo = await page.textContent('[data-testid="user-name"]');
    expect(userInfo).toContain('testuser');
  });
  
  test('admin user management workflow', async () => {
    const page = await browser.newPage();
    
    // 1. 管理员登录
    await loginAsAdmin(page);
    
    // 2. 导航到用户管理
    await page.click('[data-testid="users-menu"]');
    await page.waitForURL('/users');
    
    // 3. 创建新用户
    await page.click('[data-testid="create-user-button"]');
    await page.fill('[name="username"]', 'newuser');
    await page.fill('[name="email"]', 'newuser@example.com');
    await page.fill('[name="password"]', 'password123');
    await page.selectOption('[name="role"]', 'user');
    await page.click('[type="submit"]');
    
    // 4. 验证用户创建成功
    await page.waitForSelector('[data-testid="success-message"]');
    
    // 5. 搜索新创建的用户
    await page.fill('[data-testid="search-input"]', 'newuser');
    await page.waitForSelector('[data-testid="user-row"]:has-text("newuser")');
    
    // 6. 编辑用户权限
    await page.click('[data-testid="edit-user-button"]');
    await page.check('[data-testid="permission-users-read"]');
    await page.click('[data-testid="save-button"]');
    
    // 7. 验证权限更新
    await page.waitForSelector('[data-testid="success-message"]');
  });
});
```

### 9.2 错误处理流程测试

**测试用例**: `TC_E2E_002`

```typescript
describe('Error Handling Flows', () => {
  test('should handle invalid client gracefully', async () => {
    const page = await browser.newPage();
    
    // 访问带有无效client_id的授权URL
    await page.goto('/oauth/authorize?client_id=invalid-client&response_type=code');
    
    // 应该显示错误页面
    await page.waitForSelector('[data-testid="error-message"]');
    const errorMessage = await page.textContent('[data-testid="error-message"]');
    expect(errorMessage).toContain('Invalid client');
  });
  
  test('should handle network errors during OAuth flow', async () => {
    const page = await browser.newPage();
    
    // 模拟网络错误
    await page.route('/api/v2/oauth/token', route => {
      route.abort('failed');
    });
    
    // 尝试完成OAuth流程
    await completeOAuthFlow(page);
    
    // 应该显示适当的错误消息
    await page.waitForSelector('[data-testid="network-error"]');
    const errorMessage = await page.textContent('[data-testid="network-error"]');
    expect(errorMessage).toContain('Network error');
  });
});
```

## 10. 测试数据管理

### 10.1 测试数据生成

```typescript
// test-data-factory.ts
export class TestDataFactory {
  static createUser(overrides: Partial<User> = {}): User {
    return {
      id: faker.datatype.uuid(),
      username: faker.internet.userName(),
      email: faker.internet.email(),
      password: bcrypt.hashSync('password123', 10),
      name: faker.name.fullName(),
      status: 'active',
      createdAt: new Date(),
      updatedAt: new Date(),
      ...overrides
    };
  }
  
  static createRole(overrides: Partial<Role> = {}): Role {
    return {
      id: faker.datatype.uuid(),
      name: faker.lorem.word(),
      description: faker.lorem.sentence(),
      permissions: [],
      createdAt: new Date(),
      updatedAt: new Date(),
      ...overrides
    };
  }
  
  static createOAuthClient(overrides: Partial<OAuthClient> = {}): OAuthClient {
    return {
      id: faker.datatype.uuid(),
      clientId: faker.random.alphaNumeric(16),
      clientSecret: faker.random.alphaNumeric(32),
      name: faker.company.name(),
      redirectUris: [faker.internet.url()],
      scopes: ['openid', 'profile', 'email'],
      grantTypes: ['authorization_code', 'refresh_token'],
      responseTypes: ['code'],
      tokenEndpointAuthMethod: 'client_secret_basic',
      createdAt: new Date(),
      updatedAt: new Date(),
      ...overrides
    };
  }
}
```

### 10.2 测试数据清理

```typescript
// test-cleanup.ts
export class TestCleanup {
  static async cleanupDatabase() {
    await prisma.token.deleteMany();
    await prisma.authorizationCode.deleteMany();
    await prisma.userRole.deleteMany();
    await prisma.rolePermission.deleteMany();
    await prisma.user.deleteMany();
    await prisma.role.deleteMany();
    await prisma.permission.deleteMany();
    await prisma.oAuthClient.deleteMany();
  }
  
  static async seedTestData() {
    // 创建基础权限
    const permissions = await createBasicPermissions();
    
    // 创建基础角色
    const roles = await createBasicRoles(permissions);
    
    // 创建测试用户
    const users = await createTestUsers(roles);
    
    // 创建测试客户端
    const clients = await createTestClients();
    
    return { permissions, roles, users, clients };
  }
}
```

## 11. 测试报告和监控

### 11.1 测试报告生成

```typescript
// test-reporter.ts
export class TestReporter {
  static generateReport(testResults: TestResult[]) {
    const report = {
      summary: {
        total: testResults.length,
        passed: testResults.filter(r => r.status === 'passed').length,
        failed: testResults.filter(r => r.status === 'failed').length,
        skipped: testResults.filter(r => r.status === 'skipped').length,
        duration: testResults.reduce((sum, r) => sum + r.duration, 0)
      },
      categories: {
        oauth: this.getCategoryResults(testResults, 'oauth'),
        oidc: this.getCategoryResults(testResults, 'oidc'),
        rbac: this.getCategoryResults(testResults, 'rbac'),
        security: this.getCategoryResults(testResults, 'security'),
        performance: this.getCategoryResults(testResults, 'performance')
      },
      coverage: {
        statements: 85.2,
        branches: 78.9,
        functions: 92.1,
        lines: 87.3
      },
      timestamp: new Date().toISOString()
    };
    
    return report;
  }
}
```

### 11.2 持续集成配置

```yaml
# .github/workflows/test.yml
name: Test Suite

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:14
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: test_db
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
      
      redis:
        image: redis:7
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '18'
        cache: 'npm'
    
    - name: Install dependencies
      run: npm ci
    
    - name: Setup test database
      run: |
        npx prisma migrate deploy
        npx prisma db seed
      env:
        DATABASE_URL: postgresql://postgres:postgres@localhost:5432/test_db
    
    - name: Run unit tests
      run: npm run test:unit
    
    - name: Run integration tests
      run: npm run test:integration
      env:
        DATABASE_URL: postgresql://postgres:postgres@localhost:5432/test_db
        REDIS_URL: redis://localhost:6379
    
    - name: Run E2E tests
      run: npm run test:e2e
    
    - name: Run security tests
      run: npm run test:security
    
    - name: Generate test report
      run: npm run test:report
    
    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v3
      with:
        file: ./coverage/lcov.info
```

## 12. 测试维护和优化

### 12.1 测试代码质量

**测试代码规范**:
- 清晰的测试命名
- 适当的测试粒度
- 避免测试间的依赖
- 使用Page Object模式
- 合理的断言

**测试重构策略**:
- 定期审查测试代码
- 消除重复代码
- 提取公共测试工具
- 优化测试性能

### 12.2 测试环境维护

**环境一致性**:
- 使用Docker容器化
- 版本控制测试配置
- 自动化环境部署
- 定期更新依赖

**测试数据管理**:
- 自动化数据准备
- 测试数据版本控制
- 数据隐私保护
- 定期清理测试数据

---

*文档版本：v1.0*  
*最后更新：2024年12月*  
*状态：设计阶段*