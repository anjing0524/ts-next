# OAuth2.1认证授权中心测试设计方案

> **文档版本**: v2.0.0  
> **创建日期**: 2024-01-20  
> **最后更新**: 2024-01-20  
> **文档状态**: 正式版  
> **维护团队**: 测试团队

## 文档摘要

本文档详细描述了OAuth2.1认证授权中心的完整测试策略，包括测试目标、测试范围、测试环境设计、测试用例设计、自动化测试方案等。确保系统在功能性、安全性、性能和可靠性方面达到企业级标准。

## 目录

- [1. 测试概述](#1-测试概述)
  - [1.1 测试目标](#11-测试目标)
  - [1.2 测试范围](#12-测试范围)
  - [1.3 测试策略](#13-测试策略)
- [2. 测试环境设计](#2-测试环境设计)
- [3. OAuth2.1协议测试](#3-oauth21协议测试)
- [4. 安全性测试](#4-安全性测试)
- [5. 性能测试](#5-性能测试)
- [6. 自动化测试](#6-自动化测试)
- [7. 测试执行计划](#7-测试执行计划)
- [8. 质量保证](#8-质量保证)

## 1. 测试概述

### 1.1 测试目标

本测试设计方案基于**测试驱动开发(TDD)**理念，旨在确保OAuth2.1认证授权中心的功能完整性、安全性和性能表现。通过全面的测试覆盖，验证系统在各种场景下的稳定性和可靠性，特别关注内网环境下的认证授权核心功能。

核心测试目标：
- **OAuth2.1协议合规性**: 严格遵循RFC 6749、RFC 7636等标准
- **PKCE安全增强**: 验证PKCE流程的安全性和正确性
- **OIDC身份认证**: 确保OpenID Connect功能的完整性
- **RBAC权限控制**: 验证基于角色的访问控制机制
- **API安全性**: 确保所有API端点的安全性
- **性能和可靠性**: 验证系统在各种负载下的表现

### 1.2 测试范围

#### 核心功能测试
- **OAuth2.1授权码模式**: 完整的授权码流程测试
- **客户端认证模式**: Service-to-Service认证测试
- **强制PKCE**: PKCE参数生成和验证测试
- **OIDC公钥获取**: OpenID Connect公钥端点测试
- **RBAC权限模型**: 基于角色的访问控制测试
- **JWT令牌管理**: 令牌生成、验证、刷新测试

#### 安全测试
- **认证安全**: 密码策略、登录保护测试
- **授权安全**: 权限验证、越权访问测试
- **令牌安全**: JWT签名验证、令牌泄露测试
- **PKCE安全**: Code challenge验证测试

#### 性能和集成测试
- **API性能**: 响应时间和吞吐量测试
- **数据库性能**: 查询优化和索引效果测试
- **第三方集成**: 客户端应用集成测试

**排除范围**:
- 第三方依赖库的内部测试
- 基础设施层面的测试
- 操作系统级别的安全测试

### 1.3 测试驱动开发策略

采用**严格的TDD方法**，确保代码质量和逻辑正确性：

#### TDD循环
1. **红(Red)**: 编写失败的测试用例，明确需求
2. **绿(Green)**: 编写最少代码使测试通过
3. **重构(Refactor)**: 优化代码结构，保持测试通过

#### TDD原则
- **测试先行**: 任何功能代码前必须先写测试
- **小步迭代**: 每次只实现一个小功能
- **持续重构**: 保持代码简洁和可维护性
- **100%覆盖**: 确保所有业务逻辑都有测试覆盖

### 1.4 测试策略

```mermaid
graph TB
    A[单元测试] --> B[集成测试]
    B --> C[系统测试]
    C --> D[验收测试]
    
    A1[组件测试] --> A
    A2[工具函数测试] --> A
    
    B1[API集成测试] --> B
    B2[数据库集成测试] --> B
    B3[OAuth流程集成测试] --> B
    
    C1[端到端测试] --> C
    C2[性能测试] --> C
    C3[安全测试] --> C
    
    D1[用户验收测试] --> D
    D2[业务流程验证] --> D
```

## 2. TDD测试用例设计

### 2.1 OAuth2.1授权码模式TDD测试

#### 2.1.1 PKCE参数生成测试

```javascript
// 测试用例：PKCE参数生成
describe('PKCE Parameter Generation', () => {
  test('should generate valid code_verifier', () => {
    // Red: 编写失败的测试
    const codeVerifier = generateCodeVerifier();
    
    expect(codeVerifier).toBeDefined();
    expect(codeVerifier.length).toBeGreaterThanOrEqual(43);
    expect(codeVerifier.length).toBeLessThanOrEqual(128);
    expect(codeVerifier).toMatch(/^[A-Za-z0-9\-._~]+$/);
  });
  
  test('should generate valid code_challenge from verifier', () => {
    const codeVerifier = 'test_verifier_123';
    const codeChallenge = generateCodeChallenge(codeVerifier);
    
    expect(codeChallenge).toBeDefined();
    expect(codeChallenge).toMatch(/^[A-Za-z0-9\-_]+$/);
    // 验证SHA256+Base64URL编码
    const expected = base64URLEncode(sha256(codeVerifier));
    expect(codeChallenge).toBe(expected);
  });
});
```

#### 2.1.2 授权码流程测试

```javascript
// 测试用例：完整授权码流程
describe('Authorization Code Flow', () => {
  test('should handle complete authorization flow with PKCE', async () => {
    // Red: 定义完整流程测试
    const client = await createTestClient();
    const user = await createTestUser();
    const codeVerifier = generateCodeVerifier();
    const codeChallenge = generateCodeChallenge(codeVerifier);
    
    // 1. 授权请求
    const authResponse = await request(app)
      .get('/api/oauth/authorize')
      .query({
        response_type: 'code',
        client_id: client.clientId,
        redirect_uri: client.redirectUris[0],
        scope: 'openid profile',
        code_challenge: codeChallenge,
        code_challenge_method: 'S256',
        state: 'test_state'
      })
      .expect(302);
    
    // 2. 用户登录和授权（模拟）
    const code = extractAuthorizationCode(authResponse.headers.location);
    expect(code).toBeDefined();
    
    // 3. 令牌交换
    const tokenResponse = await request(app)
      .post('/api/oauth/token')
      .send({
        grant_type: 'authorization_code',
        code: code,
        redirect_uri: client.redirectUris[0],
        client_id: client.clientId,
        code_verifier: codeVerifier
      })
      .expect(200);
    
    expect(tokenResponse.body.access_token).toBeDefined();
    expect(tokenResponse.body.refresh_token).toBeDefined();
    expect(tokenResponse.body.id_token).toBeDefined();
    expect(tokenResponse.body.token_type).toBe('Bearer');
  });
});
```

### 2.2 客户端认证模式TDD测试

```javascript
// 测试用例：客户端认证模式
describe('Client Credentials Flow', () => {
  test('should authenticate confidential client', async () => {
    const client = await createConfidentialClient();
    
    const response = await request(app)
      .post('/api/oauth/token')
      .auth(client.clientId, client.clientSecret)
      .send({
        grant_type: 'client_credentials',
        scope: 'api:read api:write'
      })
      .expect(200);
    
    expect(response.body.access_token).toBeDefined();
    expect(response.body.token_type).toBe('Bearer');
    expect(response.body.scope).toContain('api:read');
  });
  
  test('should reject invalid client credentials', async () => {
    await request(app)
      .post('/api/oauth/token')
      .auth('invalid_client', 'invalid_secret')
      .send({
        grant_type: 'client_credentials',
        scope: 'api:read'
      })
      .expect(401);
  });
});
```

### 2.3 RBAC权限模型TDD测试

```javascript
// 测试用例：RBAC权限验证
describe('RBAC Permission System', () => {
  test('should enforce role-based access control', async () => {
    // 创建测试数据
    const adminRole = await createRole('admin', ['user:read', 'user:write']);
    const userRole = await createRole('user', ['profile:read']);
    const adminUser = await createUserWithRole(adminRole);
    const normalUser = await createUserWithRole(userRole);
    
    // 管理员应该能访问用户管理API
    const adminToken = await generateTokenForUser(adminUser);
    await request(app)
      .get('/api/v2/users')
      .auth(adminToken, { type: 'bearer' })
      .expect(200);
    
    // 普通用户应该被拒绝访问
    const userToken = await generateTokenForUser(normalUser);
    await request(app)
      .get('/api/v2/users')
      .auth(userToken, { type: 'bearer' })
      .expect(403);
  });
});
```

### 2.4 JWT令牌验证TDD测试

```javascript
// 测试用例：JWT令牌验证
describe('JWT Token Validation', () => {
  test('should validate JWT signature with public key', async () => {
    const { privateKey, publicKey } = await generateKeyPair();
    const payload = {
      sub: 'user123',
      iss: 'https://auth.company.com',
      aud: 'test_client',
      exp: Math.floor(Date.now() / 1000) + 3600
    };
    
    const token = await signJWT(payload, privateKey);
    const verified = await verifyJWT(token, publicKey);
    
    expect(verified.sub).toBe('user123');
    expect(verified.iss).toBe('https://auth.company.com');
  });
  
  test('should reject expired tokens', async () => {
    const expiredPayload = {
      sub: 'user123',
      exp: Math.floor(Date.now() / 1000) - 3600 // 1小时前过期
    };
    
    const token = await signJWT(expiredPayload, privateKey);
    
    await expect(verifyJWT(token, publicKey))
      .rejects.toThrow('Token expired');
  });
});
```

## 3. 测试环境设计

### 3.1 TDD开发环境

```
┌─────────────────────────────────────────────────────────────┐
│                  TDD测试环境架构                             │
├─────────────────────────────────────────────────────────────┤
│  单元测试层 (Unit Tests)                                     │
│  ┌─────────────────┐  ┌─────────────────┐                  │
│  │   Jest/Vitest   │  │   测试数据库     │                  │
│  │   快速反馈      │  │   SQLite内存     │                  │
│  └─────────────────┘  └─────────────────┘                  │
├─────────────────────────────────────────────────────────────┤
│  集成测试层 (Integration Tests)                              │
│  ┌─────────────────┐  ┌─────────────────┐                  │
│  │   Supertest     │  │   Docker容器     │                  │
│  │   API测试       │  │   PostgreSQL     │                  │
│  └─────────────────┘  └─────────────────┘                  │
├─────────────────────────────────────────────────────────────┤
│  端到端测试层 (E2E Tests)                                    │
│  ┌─────────────────┐  ┌─────────────────┐                  │
│  │   Playwright    │  │   完整环境       │                  │
│  │   浏览器测试     │  │   真实数据       │                  │
│  └─────────────────┘  └─────────────────┘                  │
└─────────────────────────────────────────────────────────────┘
```

### 3.2 测试数据管理

#### 3.2.1 测试数据工厂

```javascript
// 测试数据工厂模式
class TestDataFactory {
  static async createTestUser(overrides = {}) {
    return await User.create({
      username: `test_user_${Date.now()}`,
      passwordHash: await bcrypt.hash('password123', 10),
      isActive: true,
      organization: 'test_org',
      department: 'test_dept',
      ...overrides
    });
  }
  
  static async createTestClient(overrides = {}) {
    return await OAuthClient.create({
      clientId: `test_client_${Date.now()}`,
      clientSecret: await bcrypt.hash('secret123', 10),
      redirectUris: JSON.stringify(['http://localhost:3000/callback']),
      grantTypes: JSON.stringify(['authorization_code', 'refresh_token']),
      responseTypes: JSON.stringify(['code']),
      allowedScopes: JSON.stringify(['openid', 'profile']),
      clientType: 'CONFIDENTIAL',
      requirePkce: true,
      isActive: true,
      ...overrides
    });
  }
}
```

#### 3.2.2 测试数据清理

```javascript
// 测试前后数据清理
beforeEach(async () => {
  // 清理测试数据
  await cleanupTestData();
  // 初始化基础数据
  await seedBasicTestData();
});

afterEach(async () => {
  // 清理测试产生的数据
  await cleanupTestData();
});
```

### 3.3 性能测试设计

#### 3.3.1 OAuth2.1性能基准测试

```javascript
// K6性能测试脚本
import http from 'k6/http';
import { check, sleep } from 'k6';
import { Rate } from 'k6/metrics';

const errorRate = new Rate('errors');

export let options = {
  stages: [
    { duration: '2m', target: 100 }, // 逐步增加到100用户
    { duration: '5m', target: 100 }, // 保持100用户5分钟
    { duration: '2m', target: 200 }, // 增加到200用户
    { duration: '5m', target: 200 }, // 保持200用户5分钟
    { duration: '2m', target: 0 },   // 逐步减少到0
  ],
  thresholds: {
    http_req_duration: ['p(95)<500'], // 95%请求在500ms内
    http_req_failed: ['rate<0.1'],    // 错误率小于10%
    errors: ['rate<0.1'],
  },
};

export default function() {
  // 测试授权码流程性能
  const authParams = {
    response_type: 'code',
    client_id: 'test_client',
    redirect_uri: 'http://localhost:3000/callback',
    scope: 'openid profile',
    code_challenge: 'test_challenge',
    code_challenge_method: 'S256',
    state: 'test_state'
  };
  
  const authResponse = http.get(`${__ENV.BASE_URL}/api/oauth/authorize`, {
    params: authParams
  });
  
  check(authResponse, {
    'authorization endpoint status is 302': (r) => r.status === 302,
    'authorization response time < 200ms': (r) => r.timings.duration < 200,
  }) || errorRate.add(1);
  
  // 测试令牌端点性能
  const tokenResponse = http.post(`${__ENV.BASE_URL}/api/oauth/token`, {
    grant_type: 'client_credentials',
    scope: 'api:read'
  }, {
    headers: {
      'Authorization': `Basic ${__ENV.CLIENT_CREDENTIALS}`,
      'Content-Type': 'application/x-www-form-urlencoded'
    }
  });
  
  check(tokenResponse, {
    'token endpoint status is 200': (r) => r.status === 200,
    'token response time < 300ms': (r) => r.timings.duration < 300,
    'access token present': (r) => JSON.parse(r.body).access_token !== undefined,
  }) || errorRate.add(1);
  
  sleep(1);
}
```

#### 3.3.2 数据库性能测试

```javascript
// 数据库查询性能测试
describe('Database Performance Tests', () => {
  test('user authentication should complete within 100ms', async () => {
    const startTime = Date.now();
    
    await authenticateUser('test_user', 'password123');
    
    const duration = Date.now() - startTime;
    expect(duration).toBeLessThan(100);
  });
  
  test('token validation should complete within 50ms', async () => {
    const token = await generateTestToken();
    const startTime = Date.now();
    
    await validateToken(token);
    
    const duration = Date.now() - startTime;
    expect(duration).toBeLessThan(50);
  });
  
  test('permission check should complete within 30ms', async () => {
    const user = await createTestUser();
    const startTime = Date.now();
    
    await checkUserPermission(user.id, 'user:read');
    
    const duration = Date.now() - startTime;
    expect(duration).toBeLessThan(30);
  });
});
```

### 3.4 安全测试设计

#### 3.4.1 OAuth2.1安全测试

```javascript
// 安全测试用例
describe('OAuth2.1 Security Tests', () => {
  test('should prevent PKCE downgrade attack', async () => {
    const client = await createTestClient({ requirePkce: true });
    
    // 尝试不使用PKCE的授权请求
    const response = await request(app)
      .get('/api/oauth/authorize')
      .query({
        response_type: 'code',
        client_id: client.clientId,
        redirect_uri: client.redirectUris[0],
        scope: 'openid profile'
        // 故意不包含code_challenge
      })
      .expect(400);
    
    expect(response.body.error).toBe('invalid_request');
    expect(response.body.error_description).toContain('code_challenge');
  });
  
  test('should prevent authorization code replay attack', async () => {
    const { code, codeVerifier } = await performAuthorizationFlow();
    
    // 第一次使用授权码
    await request(app)
      .post('/api/oauth/token')
      .send({
        grant_type: 'authorization_code',
        code: code,
        code_verifier: codeVerifier
      })
      .expect(200);
    
    // 尝试重复使用同一个授权码
    await request(app)
      .post('/api/oauth/token')
      .send({
        grant_type: 'authorization_code',
        code: code,
        code_verifier: codeVerifier
      })
      .expect(400);
  });
  
  test('should validate redirect URI strictly', async () => {
    const client = await createTestClient({
      redirectUris: ['https://app.company.com/callback']
    });
    
    // 尝试使用未注册的重定向URI
    await request(app)
      .get('/api/oauth/authorize')
      .query({
        response_type: 'code',
        client_id: client.clientId,
        redirect_uri: 'https://evil.com/callback', // 恶意重定向
        scope: 'openid profile'
      })
      .expect(400);
  });
  
  test('should prevent timing attacks on client authentication', async () => {
    const validClient = await createTestClient();
    const timings = [];
    
    // 测试有效客户端认证时间
    for (let i = 0; i < 10; i++) {
      const start = process.hrtime.bigint();
      await authenticateClient(validClient.clientId, validClient.clientSecret);
      const end = process.hrtime.bigint();
      timings.push(Number(end - start) / 1000000); // 转换为毫秒
    }
    
    // 测试无效客户端认证时间
    const invalidTimings = [];
    for (let i = 0; i < 10; i++) {
      const start = process.hrtime.bigint();
      try {
        await authenticateClient('invalid_client', 'invalid_secret');
      } catch (e) {
        // 预期的错误
      }
      const end = process.hrtime.bigint();
      invalidTimings.push(Number(end - start) / 1000000);
    }
    
    // 验证时间差异不应该太大（防止时序攻击）
    const avgValid = timings.reduce((a, b) => a + b) / timings.length;
    const avgInvalid = invalidTimings.reduce((a, b) => a + b) / invalidTimings.length;
    const timeDifference = Math.abs(avgValid - avgInvalid);
    
    expect(timeDifference).toBeLessThan(10); // 时间差异应小于10ms
  });
});
```

#### 3.4.2 输入验证安全测试

```javascript
// 输入验证安全测试
describe('Input Validation Security Tests', () => {
  test('should prevent SQL injection in user queries', async () => {
    const maliciousInput = "'; DROP TABLE users; --";
    
    await expect(findUserByUsername(maliciousInput))
      .rejects.toThrow(); // 应该抛出验证错误，而不是执行SQL
  });
  
  test('should prevent XSS in client metadata', async () => {
    const xssPayload = '<script>alert("xss")</script>';
    
    await expect(createOAuthClient({
      clientName: xssPayload,
      clientUri: 'https://example.com'
    })).rejects.toThrow('Invalid client name');
  });
  
  test('should validate JWT claims properly', async () => {
    const maliciousToken = {
      sub: '../../../etc/passwd', // 路径遍历尝试
      iss: 'https://evil.com',
      aud: 'test_client'
    };
    
    await expect(validateJWTClaims(maliciousToken))
      .rejects.toThrow('Invalid subject claim');
  });
});
```

### 3.5 CI/CD集成测试

#### 3.5.1 GitHub Actions测试流水线

```yaml
# .github/workflows/test.yml
name: OAuth2.1 Test Suite

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  unit-tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Run unit tests
        run: npm run test:unit
        env:
          NODE_ENV: test
      
      - name: Upload coverage reports
        uses: codecov/codecov-action@v3
        with:
          file: ./coverage/lcov.info
  
  integration-tests:
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: test
          POSTGRES_DB: oauth_test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Run database migrations
        run: npm run db:migrate
        env:
          DATABASE_URL: postgresql://postgres:test@localhost:5432/oauth_test
      
      - name: Run integration tests
        run: npm run test:integration
        env:
          NODE_ENV: test
          DATABASE_URL: postgresql://postgres:test@localhost:5432/oauth_test
  
  security-tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Run security audit
        run: npm audit --audit-level high
      
      - name: Run OWASP dependency check
        uses: dependency-check/Dependency-Check_Action@main
        with:
          project: 'OAuth2.1-Auth-Center'
          path: '.'
          format: 'HTML'
      
      - name: Upload security report
        uses: actions/upload-artifact@v3
        with:
          name: security-report
          path: reports/
  
  performance-tests:
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup K6
        run: |
          sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys C5AD17C747E3415A3642D57D77C6C491D6AC1D69
          echo "deb https://dl.k6.io/deb stable main" | sudo tee /etc/apt/sources.list.d/k6.list
          sudo apt-get update
          sudo apt-get install k6
      
      - name: Run performance tests
        run: k6 run tests/performance/oauth-load-test.js
        env:
          BASE_URL: ${{ secrets.STAGING_URL }}
          CLIENT_CREDENTIALS: ${{ secrets.TEST_CLIENT_CREDENTIALS }}
```

#### 3.5.2 测试报告和质量门禁

```javascript
// jest.config.js - 测试覆盖率配置
module.exports = {
  collectCoverage: true,
  coverageDirectory: 'coverage',
  coverageReporters: ['text', 'lcov', 'html'],
  coverageThreshold: {
    global: {
      branches: 80,
      functions: 80,
      lines: 80,
      statements: 80
    },
    './src/oauth/': {
      branches: 90,
      functions: 90,
      lines: 90,
      statements: 90
    }
  },
  testMatch: [
    '**/__tests__/**/*.(test|spec).(js|ts)',
    '**/*.(test|spec).(js|ts)'
  ],
  setupFilesAfterEnv: ['<rootDir>/tests/setup.js']
};
```

## 3. OAuth2.1核心流程测试

### 3.1 授权码流程测试

#### 3.1.1 标准授权码流程

**测试用例**: `TC_OAUTH_001`

```typescript
describe('OAuth2.1 Authorization Code Flow', () => {
  test('should complete standard authorization code flow', async () => {
    // 1. 客户端重定向到授权端点
    const authUrl = buildAuthorizationUrl({
      client_id: 'test-client',
      redirect_uri: 'https://client.example.com/callback',
      response_type: 'code',
      scope: 'openid profile email',
      state: 'random-state-value'
    });
    
    // 2. 用户认证和授权
    const authResponse = await authenticateUser({
      username: 'testuser',
      password: 'password123'
    });
    
    // 3. 获取授权码
    const authCode = await authorizeClient({
      client_id: 'test-client',
      user_id: authResponse.user_id,
      scope: 'openid profile email'
    });
    
    // 4. 交换访问令牌
    const tokenResponse = await exchangeCodeForToken({
      grant_type: 'authorization_code',
      code: authCode,
      redirect_uri: 'https://client.example.com/callback',
      client_id: 'test-client',
      client_secret: 'client-secret'
    });
    
    // 验证响应
    expect(tokenResponse).toMatchObject({
      access_token: expect.any(String),
      token_type: 'Bearer',
      expires_in: expect.any(Number),
      refresh_token: expect.any(String),
      scope: 'openid profile email'
    });
  });
});
```

#### 3.1.2 PKCE增强流程测试

**测试用例**: `TC_OAUTH_002`

```typescript
describe('OAuth2.1 PKCE Enhanced Flow', () => {
  test('should complete PKCE authorization code flow', async () => {
    // 1. 生成PKCE参数
    const codeVerifier = generateCodeVerifier();
    const codeChallenge = generateCodeChallenge(codeVerifier);
    const codeChallengeMethod = 'S256';
    
    // 2. 授权请求包含PKCE参数
    const authUrl = buildAuthorizationUrl({
      client_id: 'public-client',
      redirect_uri: 'https://app.example.com/callback',
      response_type: 'code',
      scope: 'openid profile',
      code_challenge: codeChallenge,
      code_challenge_method: codeChallengeMethod,
      state: 'random-state'
    });
    
    // 3. 用户认证和授权
    const authCode = await completeAuthorization(authUrl);
    
    // 4. 令牌交换包含code_verifier
    const tokenResponse = await exchangeCodeForToken({
      grant_type: 'authorization_code',
      code: authCode,
      redirect_uri: 'https://app.example.com/callback',
      client_id: 'public-client',
      code_verifier: codeVerifier
    });
    
    // 验证PKCE流程成功
    expect(tokenResponse.access_token).toBeDefined();
    expect(tokenResponse.id_token).toBeDefined();
  });
  
  test('should reject invalid code_verifier', async () => {
    const codeVerifier = generateCodeVerifier();
    const wrongVerifier = generateCodeVerifier();
    const codeChallenge = generateCodeChallenge(codeVerifier);
    
    // 获取授权码
    const authCode = await getAuthorizationCode({
      code_challenge: codeChallenge,
      code_challenge_method: 'S256'
    });
    
    // 使用错误的code_verifier
    const tokenRequest = exchangeCodeForToken({
      grant_type: 'authorization_code',
      code: authCode,
      client_id: 'public-client',
      code_verifier: wrongVerifier
    });
    
    await expect(tokenRequest).rejects.toMatchObject({
      error: 'invalid_grant',
      error_description: 'Invalid code verifier'
    });
  });
});
```

### 3.2 刷新令牌流程测试

**测试用例**: `TC_OAUTH_003`

```typescript
describe('Refresh Token Flow', () => {
  test('should refresh access token successfully', async () => {
    // 1. 获取初始令牌
    const initialTokens = await getInitialTokens();
    
    // 2. 使用刷新令牌获取新的访问令牌
    const refreshResponse = await refreshAccessToken({
      grant_type: 'refresh_token',
      refresh_token: initialTokens.refresh_token,
      client_id: 'test-client',
      client_secret: 'client-secret'
    });
    
    // 3. 验证新令牌
    expect(refreshResponse).toMatchObject({
      access_token: expect.any(String),
      token_type: 'Bearer',
      expires_in: expect.any(Number)
    });
    
    // 4. 验证新令牌与旧令牌不同
    expect(refreshResponse.access_token).not.toBe(initialTokens.access_token);
    
    // 5. 验证旧令牌已失效
    const oldTokenValidation = await validateToken(initialTokens.access_token);
    expect(oldTokenValidation.valid).toBe(false);
  });
  
  test('should handle refresh token rotation', async () => {
    const initialTokens = await getInitialTokens();
    
    const refreshResponse = await refreshAccessToken({
      grant_type: 'refresh_token',
      refresh_token: initialTokens.refresh_token,
      client_id: 'test-client'
    });
    
    // 验证返回了新的刷新令牌
    expect(refreshResponse.refresh_token).toBeDefined();
    expect(refreshResponse.refresh_token).not.toBe(initialTokens.refresh_token);
    
    // 验证旧刷新令牌已失效
    const oldRefreshAttempt = refreshAccessToken({
      grant_type: 'refresh_token',
      refresh_token: initialTokens.refresh_token,
      client_id: 'test-client'
    });
    
    await expect(oldRefreshAttempt).rejects.toMatchObject({
      error: 'invalid_grant'
    });
  });
});
```

### 3.3 令牌撤销测试

**测试用例**: `TC_OAUTH_004`

```typescript
describe('Token Revocation', () => {
  test('should revoke access token', async () => {
    const tokens = await getValidTokens();
    
    // 撤销访问令牌
    const revokeResponse = await revokeToken({
      token: tokens.access_token,
      token_type_hint: 'access_token',
      client_id: 'test-client',
      client_secret: 'client-secret'
    });
    
    expect(revokeResponse.status).toBe(200);
    
    // 验证令牌已失效
    const tokenValidation = await validateToken(tokens.access_token);
    expect(tokenValidation.valid).toBe(false);
  });
  
  test('should revoke refresh token and cascade revoke access tokens', async () => {
    const tokens = await getValidTokens();
    
    // 撤销刷新令牌
    await revokeToken({
      token: tokens.refresh_token,
      token_type_hint: 'refresh_token',
      client_id: 'test-client'
    });
    
    // 验证相关的访问令牌也被撤销
    const accessTokenValidation = await validateToken(tokens.access_token);
    expect(accessTokenValidation.valid).toBe(false);
    
    // 验证刷新令牌无法再使用
    const refreshAttempt = refreshAccessToken({
      grant_type: 'refresh_token',
      refresh_token: tokens.refresh_token,
      client_id: 'test-client'
    });
    
    await expect(refreshAttempt).rejects.toMatchObject({
      error: 'invalid_grant'
    });
  });
});
```

## 4. OIDC身份认证测试

### 4.1 ID Token测试

**测试用例**: `TC_OIDC_001`

```typescript
describe('OpenID Connect ID Token', () => {
  test('should return valid ID token with openid scope', async () => {
    const tokenResponse = await getTokensWithScope('openid profile email');
    
    // 验证ID token存在
    expect(tokenResponse.id_token).toBeDefined();
    
    // 解析和验证ID token
    const idToken = jwt.decode(tokenResponse.id_token, { complete: true });
    
    // 验证JWT头部
    expect(idToken.header).toMatchObject({
      alg: 'RS256',
      typ: 'JWT',
      kid: expect.any(String)
    });
    
    // 验证JWT载荷
    expect(idToken.payload).toMatchObject({
      iss: process.env.ISSUER_URL,
      sub: expect.any(String),
      aud: 'test-client',
      exp: expect.any(Number),
      iat: expect.any(Number),
      auth_time: expect.any(Number),
      nonce: expect.any(String)
    });
    
    // 验证签名
    const publicKey = await getPublicKey(idToken.header.kid);
    const isValid = jwt.verify(tokenResponse.id_token, publicKey);
    expect(isValid).toBeTruthy();
  });
  
  test('should include user claims based on scope', async () => {
    const tokenResponse = await getTokensWithScope('openid profile email');
    const idToken = jwt.decode(tokenResponse.id_token);
    
    // 验证profile scope的声明
    expect(idToken).toMatchObject({
      name: expect.any(String),
      given_name: expect.any(String),
      family_name: expect.any(String),
      picture: expect.any(String)
    });
    
    // 验证email scope的声明
    expect(idToken).toMatchObject({
      email: expect.stringMatching(/^[^\s@]+@[^\s@]+\.[^\s@]+$/),
      email_verified: expect.any(Boolean)
    });
  });
});
```

### 4.2 UserInfo端点测试

**测试用例**: `TC_OIDC_002`

```typescript
describe('OIDC UserInfo Endpoint', () => {
  test('should return user information with valid access token', async () => {
    const tokens = await getTokensWithScope('openid profile email');
    
    const userInfoResponse = await fetch('/api/v2/oidc/userinfo', {
      headers: {
        'Authorization': `Bearer ${tokens.access_token}`
      }
    });
    
    expect(userInfoResponse.status).toBe(200);
    
    const userInfo = await userInfoResponse.json();
    expect(userInfo).toMatchObject({
      sub: expect.any(String),
      name: expect.any(String),
      email: expect.any(String),
      email_verified: expect.any(Boolean)
    });
  });
  
  test('should respect scope limitations', async () => {
    // 只请求profile scope
    const tokens = await getTokensWithScope('openid profile');
    
    const userInfoResponse = await fetch('/api/v2/oidc/userinfo', {
      headers: {
        'Authorization': `Bearer ${tokens.access_token}`
      }
    });
    
    const userInfo = await userInfoResponse.json();
    
    // 应该包含profile信息
    expect(userInfo.name).toBeDefined();
    
    // 不应该包含email信息
    expect(userInfo.email).toBeUndefined();
  });
});
```

### 4.3 Discovery端点测试

**测试用例**: `TC_OIDC_003`

```typescript
describe('OIDC Discovery', () => {
  test('should return well-known configuration', async () => {
    const response = await fetch('/.well-known/openid-configuration');
    expect(response.status).toBe(200);
    
    const config = await response.json();
    expect(config).toMatchObject({
      issuer: process.env.ISSUER_URL,
      authorization_endpoint: expect.stringContaining('/oauth/authorize'),
      token_endpoint: expect.stringContaining('/oauth/token'),
      userinfo_endpoint: expect.stringContaining('/oidc/userinfo'),
      jwks_uri: expect.stringContaining('/.well-known/jwks.json'),
      response_types_supported: expect.arrayContaining(['code']),
      subject_types_supported: expect.arrayContaining(['public']),
      id_token_signing_alg_values_supported: expect.arrayContaining(['RS256']),
      scopes_supported: expect.arrayContaining(['openid', 'profile', 'email']),
      token_endpoint_auth_methods_supported: expect.arrayContaining(['client_secret_basic', 'client_secret_post']),
      code_challenge_methods_supported: expect.arrayContaining(['S256'])
    });
  });
});
```

## 5. RBAC权限系统测试

### 5.1 角色权限测试

**测试用例**: `TC_RBAC_001`

```typescript
describe('RBAC Role-Based Access Control', () => {
  test('should enforce role-based API access', async () => {
    // 创建测试用户和角色
    const adminUser = await createTestUser({ roles: ['admin'] });
    const normalUser = await createTestUser({ roles: ['user'] });
    
    const adminToken = await getAccessToken(adminUser);
    const userToken = await getAccessToken(normalUser);
    
    // 管理员应该能访问管理API
    const adminResponse = await fetch('/api/v2/admin/users', {
      headers: { 'Authorization': `Bearer ${adminToken}` }
    });
    expect(adminResponse.status).toBe(200);
    
    // 普通用户应该被拒绝访问
    const userResponse = await fetch('/api/v2/admin/users', {
      headers: { 'Authorization': `Bearer ${userToken}` }
    });
    expect(userResponse.status).toBe(403);
  });
  
  test('should support hierarchical role inheritance', async () => {
    // 创建角色层次：super_admin > admin > user
    const superAdminUser = await createTestUser({ roles: ['super_admin'] });
    const token = await getAccessToken(superAdminUser);
    
    // super_admin应该继承admin和user的所有权限
    const adminApiResponse = await fetch('/api/v2/admin/roles', {
      headers: { 'Authorization': `Bearer ${token}` }
    });
    expect(adminApiResponse.status).toBe(200);
    
    const userApiResponse = await fetch('/api/v2/account/profile', {
      headers: { 'Authorization': `Bearer ${token}` }
    });
    expect(userApiResponse.status).toBe(200);
  });
});
```

### 5.2 权限检查测试

**测试用例**: `TC_RBAC_002`

```typescript
describe('Permission Checking', () => {
  test('should check single permission correctly', async () => {
    const user = await createTestUser({
      permissions: ['users:read', 'users:write']
    });
    const token = await getAccessToken(user);
    
    // 检查单个权限
    const checkResponse = await fetch('/api/v2/auth/check', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        permission: 'users:read'
      })
    });
    
    expect(checkResponse.status).toBe(200);
    const result = await checkResponse.json();
    expect(result.hasPermission).toBe(true);
  });
  
  test('should check multiple permissions in batch', async () => {
    const user = await createTestUser({
      permissions: ['users:read', 'roles:read']
    });
    const token = await getAccessToken(user);
    
    const batchCheckResponse = await fetch('/api/v2/auth/check-batch', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        permissions: ['users:read', 'users:write', 'roles:read']
      })
    });
    
    expect(batchCheckResponse.status).toBe(200);
    const result = await batchCheckResponse.json();
    expect(result).toMatchObject({
      'users:read': true,
      'users:write': false,
      'roles:read': true
    });
  });
});
```

### 5.3 数据权限测试

**测试用例**: `TC_RBAC_003`

```typescript
describe('Data-Level Permissions', () => {
  test('should filter data based on user scope', async () => {
    // 创建部门级别的用户
    const deptUser = await createTestUser({
      department: 'engineering',
      dataScope: 'department'
    });
    const token = await getAccessToken(deptUser);
    
    // 获取用户列表
    const usersResponse = await fetch('/api/v2/users', {
      headers: { 'Authorization': `Bearer ${token}` }
    });
    
    const users = await usersResponse.json();
    
    // 应该只返回同部门的用户
    expect(users.data.every(user => user.department === 'engineering')).toBe(true);
  });
  
  test('should respect field-level permissions', async () => {
    const limitedUser = await createTestUser({
      permissions: ['users:read:basic'] // 只能读取基本信息
    });
    const token = await getAccessToken(limitedUser);
    
    const userResponse = await fetch('/api/v2/users/123', {
      headers: { 'Authorization': `Bearer ${token}` }
    });
    
    const user = await userResponse.json();
    
    // 应该包含基本字段
    expect(user.id).toBeDefined();
    expect(user.name).toBeDefined();
    
    // 不应该包含敏感字段
    expect(user.email).toBeUndefined();
    expect(user.phone).toBeUndefined();
  });
});
```

## 6. API安全测试

### 6.1 认证安全测试

**测试用例**: `TC_SEC_001`

```typescript
describe('Authentication Security', () => {
  test('should prevent brute force attacks', async () => {
    const attempts = [];
    
    // 尝试多次错误登录
    for (let i = 0; i < 10; i++) {
      const attempt = fetch('/api/v2/auth/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          username: 'testuser',
          password: 'wrongpassword'
        })
      });
      attempts.push(attempt);
    }
    
    const responses = await Promise.all(attempts);
    
    // 前几次应该返回401，后面应该返回429（太多请求）
    const lastResponse = responses[responses.length - 1];
    expect(lastResponse.status).toBe(429);
  });
  
  test('should validate JWT token properly', async () => {
    // 测试无效的JWT
    const invalidTokenResponse = await fetch('/api/v2/users', {
      headers: { 'Authorization': 'Bearer invalid.jwt.token' }
    });
    expect(invalidTokenResponse.status).toBe(401);
    
    // 测试过期的JWT
    const expiredToken = generateExpiredToken();
    const expiredTokenResponse = await fetch('/api/v2/users', {
      headers: { 'Authorization': `Bearer ${expiredToken}` }
    });
    expect(expiredTokenResponse.status).toBe(401);
    
    // 测试篡改的JWT
    const validToken = await getValidToken();
    const tamperedToken = validToken.slice(0, -10) + 'tampered123';
    const tamperedTokenResponse = await fetch('/api/v2/users', {
      headers: { 'Authorization': `Bearer ${tamperedToken}` }
    });
    expect(tamperedTokenResponse.status).toBe(401);
  });
});
```

### 6.2 输入验证测试

**测试用例**: `TC_SEC_002`

```typescript
describe('Input Validation Security', () => {
  test('should prevent SQL injection', async () => {
    const token = await getValidAdminToken();
    
    // 尝试SQL注入攻击
    const maliciousInput = "'; DROP TABLE users; --";
    
    const response = await fetch('/api/v2/users', {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${token}`
      },
      body: JSON.stringify({
        search: maliciousInput
      })
    });
    
    // 应该正常处理，不会执行恶意SQL
    expect(response.status).not.toBe(500);
    
    // 验证数据库表仍然存在
    const usersStillExist = await fetch('/api/v2/users', {
      headers: { 'Authorization': `Bearer ${token}` }
    });
    expect(usersStillExist.status).toBe(200);
  });
  
  test('should sanitize XSS attempts', async () => {
    const token = await getValidAdminToken();
    
    const xssPayload = '<script>alert("XSS")</script>';
    
    const response = await fetch('/api/v2/users', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        name: xssPayload,
        email: 'test@example.com'
      })
    });
    
    if (response.status === 201) {
      const user = await response.json();
      // 恶意脚本应该被转义或移除
      expect(user.name).not.toContain('<script>');
      expect(user.name).not.toContain('alert');
    }
  });
});
```

### 6.3 授权安全测试

**测试用例**: `TC_SEC_003`

```typescript
describe('Authorization Security', () => {
  test('should prevent privilege escalation', async () => {
    const normalUser = await createTestUser({ roles: ['user'] });
    const token = await getAccessToken(normalUser);
    
    // 尝试访问管理员功能
    const adminResponse = await fetch('/api/v2/admin/users', {
      headers: { 'Authorization': `Bearer ${token}` }
    });
    expect(adminResponse.status).toBe(403);
    
    // 尝试修改自己的角色
    const roleChangeResponse = await fetch(`/api/v2/users/${normalUser.id}`, {
      method: 'PATCH',
      headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        roles: ['admin']
      })
    });
    expect(roleChangeResponse.status).toBe(403);
  });
  
  test('should prevent horizontal privilege escalation', async () => {
    const user1 = await createTestUser({ id: 'user1' });
    const user2 = await createTestUser({ id: 'user2' });
    
    const user1Token = await getAccessToken(user1);
    
    // user1尝试访问user2的数据
    const unauthorizedResponse = await fetch(`/api/v2/users/${user2.id}`, {
      headers: { 'Authorization': `Bearer ${user1Token}` }
    });
    expect(unauthorizedResponse.status).toBe(403);
    
    // user1尝试修改user2的数据
    const modifyResponse = await fetch(`/api/v2/users/${user2.id}`, {
      method: 'PATCH',
      headers: {
        'Authorization': `Bearer ${user1Token}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        name: 'Modified by user1'
      })
    });
    expect(modifyResponse.status).toBe(403);
  });
});
```

## 7. 性能测试

### 7.1 负载测试

**测试用例**: `TC_PERF_001`

```javascript
// Artillery.js配置文件
module.exports = {
  config: {
    target: 'http://localhost:3000',
    phases: [
      { duration: 60, arrivalRate: 10 }, // 预热阶段
      { duration: 300, arrivalRate: 50 }, // 正常负载
      { duration: 120, arrivalRate: 100 }, // 高负载
      { duration: 60, arrivalRate: 200 } // 峰值负载
    ],
    processor: './test-processor.js'
  },
  scenarios: [
    {
      name: 'OAuth Authorization Flow',
      weight: 40,
      flow: [
        {
          post: {
            url: '/api/v2/auth/login',
            json: {
              username: '{{ $randomString() }}@example.com',
              password: 'password123'
            },
            capture: {
              json: '$.access_token',
              as: 'accessToken'
            }
          }
        },
        {
          get: {
            url: '/api/v2/oauth/authorize',
            qs: {
              client_id: 'test-client',
              response_type: 'code',
              scope: 'openid profile'
            },
            headers: {
              'Authorization': 'Bearer {{ accessToken }}'
            }
          }
        }
      ]
    },
    {
      name: 'Token Validation',
      weight: 30,
      flow: [
        {
          function: 'generateValidToken'
        },
        {
          post: {
            url: '/api/v2/auth/check',
            json: {
              permission: 'users:read'
            },
            headers: {
              'Authorization': 'Bearer {{ accessToken }}'
            }
          }
        }
      ]
    },
    {
      name: 'API Access',
      weight: 30,
      flow: [
        {
          function: 'generateValidToken'
        },
        {
          get: {
            url: '/api/v2/users',
            headers: {
              'Authorization': 'Bearer {{ accessToken }}'
            }
          }
        }
      ]
    }
  ]
};
```

### 7.2 压力测试

**测试用例**: `TC_PERF_002`

```typescript
describe('Stress Testing', () => {
  test('should handle concurrent token requests', async () => {
    const concurrentRequests = 100;
    const requests = [];
    
    // 创建100个并发的令牌请求
    for (let i = 0; i < concurrentRequests; i++) {
      const request = fetch('/api/v2/oauth/token', {
        method: 'POST',
        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
        body: new URLSearchParams({
          grant_type: 'authorization_code',
          code: `test-code-${i}`,
          client_id: 'test-client',
          client_secret: 'test-secret'
        })
      });
      requests.push(request);
    }
    
    const startTime = Date.now();
    const responses = await Promise.all(requests);
    const endTime = Date.now();
    
    // 验证响应时间
    const totalTime = endTime - startTime;
    const averageTime = totalTime / concurrentRequests;
    expect(averageTime).toBeLessThan(1000); // 平均响应时间小于1秒
    
    // 验证成功率
    const successfulResponses = responses.filter(r => r.status === 200);
    const successRate = successfulResponses.length / responses.length;
    expect(successRate).toBeGreaterThan(0.95); // 成功率大于95%
  });
});
```

### 7.3 内存和资源测试

**测试用例**: `TC_PERF_003`

```typescript
describe('Resource Usage Testing', () => {
  test('should not have memory leaks in token generation', async () => {
    const initialMemory = process.memoryUsage();
    
    // 生成大量令牌
    for (let i = 0; i < 1000; i++) {
      await generateAccessToken({
        user_id: `user-${i}`,
        client_id: 'test-client',
        scope: 'openid profile email'
      });
      
      // 每100次检查一次内存
      if (i % 100 === 0) {
        global.gc && global.gc(); // 强制垃圾回收
        const currentMemory = process.memoryUsage();
        const memoryIncrease = currentMemory.heapUsed - initialMemory.heapUsed;
        
        // 内存增长应该在合理范围内
        expect(memoryIncrease).toBeLessThan(50 * 1024 * 1024); // 小于50MB
      }
    }
  });
});
```

## 8. 兼容性测试

### 8.1 OAuth客户端兼容性测试

**测试用例**: `TC_COMPAT_001`

```typescript
describe('OAuth Client Compatibility', () => {
  test('should work with standard OAuth libraries', async () => {
    // 测试与popular OAuth库的兼容性
    const oauthLibraries = [
      'passport-oauth2',
      'simple-oauth2',
      'oauth2-server'
    ];
    
    for (const library of oauthLibraries) {
      const client = createOAuthClient(library);
      
      // 测试授权码流程
      const authUrl = client.getAuthorizationUrl({
        scope: 'openid profile email',
        state: 'test-state'
      });
      
      expect(authUrl).toContain('/oauth/authorize');
      expect(authUrl).toContain('client_id=');
      expect(authUrl).toContain('response_type=code');
    }
  });
});
```

### 8.2 浏览器兼容性测试

**测试用例**: `TC_COMPAT_002`

```typescript
describe('Browser Compatibility', () => {
  const browsers = ['chrome', 'firefox', 'safari', 'edge'];
  
  browsers.forEach(browser => {
    test(`should work in ${browser}`, async () => {
      const page = await getBrowserPage(browser);
      
      // 测试登录流程
      await page.goto('/login');
      await page.fill('[name="username"]', 'testuser');
      await page.fill('[name="password"]', 'password123');
      await page.click('[type="submit"]');
      
      // 验证登录成功
      await page.waitForURL('/dashboard');
      expect(page.url()).toContain('/dashboard');
      
      // 测试OAuth授权
      await page.goto('/oauth/authorize?client_id=test-client&response_type=code');
      await page.click('[data-testid="authorize-button"]');
      
      // 验证重定向
      await page.waitForURL(/callback/);
      expect(page.url()).toContain('code=');
    });
  });
});
```

## 9. 端到端测试

### 9.1 完整用户流程测试

**测试用例**: `TC_E2E_001`

```typescript
describe('End-to-End User Flows', () => {
  test('complete OAuth flow from user perspective', async () => {
    const page = await browser.newPage();
    
    // 1. 用户访问第三方应用
    await page.goto('https://client-app.example.com');
    await page.click('[data-testid="login-button"]');
    
    // 2. 重定向到认证中心
    await page.waitForURL(/oauth\/authorize/);
    expect(page.url()).toContain('client_id=');
    
    // 3. 用户登录
    await page.fill('[name="username"]', 'testuser@example.com');
    await page.fill('[name="password"]', 'password123');
    await page.click('[type="submit"]');
    
    // 4. 用户授权
    await page.waitForSelector('[data-testid="authorize-button"]');
    await page.click('[data-testid="authorize-button"]');
    
    // 5. 重定向回第三方应用
    await page.waitForURL(/client-app\.example\.com/);
    
    // 6. 验证用户已登录
    const userInfo = await page.textContent('[data-testid="user-name"]');
    expect(userInfo).toContain('testuser');
  });
  
  test('admin user management workflow', async () => {
    const page = await browser.newPage();
    
    // 1. 管理员登录
    await loginAsAdmin(page);
    
    // 2. 导航到用户管理
    await page.click('[data-testid="users-menu"]');
    await page.waitForURL('/users');
    
    // 3. 创建新用户
    await page.click('[data-testid="create-user-button"]');
    await page.fill('[name="username"]', 'newuser');
    await page.fill('[name="email"]', 'newuser@example.com');
    await page.fill('[name="password"]', 'password123');
    await page.selectOption('[name="role"]', 'user');
    await page.click('[type="submit"]');
    
    // 4. 验证用户创建成功
    await page.waitForSelector('[data-testid="success-message"]');
    
    // 5. 搜索新创建的用户
    await page.fill('[data-testid="search-input"]', 'newuser');
    await page.waitForSelector('[data-testid="user-row"]:has-text("newuser")');
    
    // 6. 编辑用户权限
    await page.click('[data-testid="edit-user-button"]');
    await page.check('[data-testid="permission-users-read"]');
    await page.click('[data-testid="save-button"]');
    
    // 7. 验证权限更新
    await page.waitForSelector('[data-testid="success-message"]');
  });
});
```

### 9.2 错误处理流程测试

**测试用例**: `TC_E2E_002`

```typescript
describe('Error Handling Flows', () => {
  test('should handle invalid client gracefully', async () => {
    const page = await browser.newPage();
    
    // 访问带有无效client_id的授权URL
    await page.goto('/oauth/authorize?client_id=invalid-client&response_type=code');
    
    // 应该显示错误页面
    await page.waitForSelector('[data-testid="error-message"]');
    const errorMessage = await page.textContent('[data-testid="error-message"]');
    expect(errorMessage).toContain('Invalid client');
  });
  
  test('should handle network errors during OAuth flow', async () => {
    const page = await browser.newPage();
    
    // 模拟网络错误
    await page.route('/api/v2/oauth/token', route => {
      route.abort('failed');
    });
    
    // 尝试完成OAuth流程
    await completeOAuthFlow(page);
    
    // 应该显示适当的错误消息
    await page.waitForSelector('[data-testid="network-error"]');
    const errorMessage = await page.textContent('[data-testid="network-error"]');
    expect(errorMessage).toContain('Network error');
  });
});
```

## 10. 测试数据管理

### 10.1 测试数据生成

```typescript
// test-data-factory.ts
export class TestDataFactory {
  static createUser(overrides: Partial<User> = {}): User {
    return {
      id: faker.datatype.uuid(),
      username: faker.internet.userName(),
      email: faker.internet.email(),
      password: bcrypt.hashSync('password123', 10),
      name: faker.name.fullName(),
      status: 'active',
      createdAt: new Date(),
      updatedAt: new Date(),
      ...overrides
    };
  }
  
  static createRole(overrides: Partial<Role> = {}): Role {
    return {
      id: faker.datatype.uuid(),
      name: faker.lorem.word(),
      description: faker.lorem.sentence(),
      permissions: [],
      createdAt: new Date(),
      updatedAt: new Date(),
      ...overrides
    };
  }
  
  static createOAuthClient(overrides: Partial<OAuthClient> = {}): OAuthClient {
    return {
      id: faker.datatype.uuid(),
      clientId: faker.random.alphaNumeric(16),
      clientSecret: faker.random.alphaNumeric(32),
      name: faker.company.name(),
      redirectUris: [faker.internet.url()],
      scopes: ['openid', 'profile', 'email'],
      grantTypes: ['authorization_code', 'refresh_token'],
      responseTypes: ['code'],
      tokenEndpointAuthMethod: 'client_secret_basic',
      createdAt: new Date(),
      updatedAt: new Date(),
      ...overrides
    };
  }
}
```

### 10.2 测试数据清理

```typescript
// test-cleanup.ts
export class TestCleanup {
  static async cleanupDatabase() {
    await prisma.token.deleteMany();
    await prisma.authorizationCode.deleteMany();
    await prisma.userRole.deleteMany();
    await prisma.rolePermission.deleteMany();
    await prisma.user.deleteMany();
    await prisma.role.deleteMany();
    await prisma.permission.deleteMany();
    await prisma.oAuthClient.deleteMany();
  }
  
  static async seedTestData() {
    // 创建基础权限
    const permissions = await createBasicPermissions();
    
    // 创建基础角色
    const roles = await createBasicRoles(permissions);
    
    // 创建测试用户
    const users = await createTestUsers(roles);
    
    // 创建测试客户端
    const clients = await createTestClients();
    
    return { permissions, roles, users, clients };
  }
}
```

## 11. 测试报告和监控

### 11.1 测试报告生成

```typescript
// test-reporter.ts
export class TestReporter {
  static generateReport(testResults: TestResult[]) {
    const report = {
      summary: {
        total: testResults.length,
        passed: testResults.filter(r => r.status === 'passed').length,
        failed: testResults.filter(r => r.status === 'failed').length,
        skipped: testResults.filter(r => r.status === 'skipped').length,
        duration: testResults.reduce((sum, r) => sum + r.duration, 0)
      },
      categories: {
        oauth: this.getCategoryResults(testResults, 'oauth'),
        oidc: this.getCategoryResults(testResults, 'oidc'),
        rbac: this.getCategoryResults(testResults, 'rbac'),
        security: this.getCategoryResults(testResults, 'security'),
        performance: this.getCategoryResults(testResults, 'performance')
      },
      coverage: {
        statements: 85.2,
        branches: 78.9,
        functions: 92.1,
        lines: 87.3
      },
      timestamp: new Date().toISOString()
    };
    
    return report;
  }
}
```

### 11.2 持续集成配置

```yaml
# .github/workflows/test.yml
name: Test Suite

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:14
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: test_db
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
      
      redis:
        image: redis:7
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '18'
        cache: 'npm'
    
    - name: Install dependencies
      run: npm ci
    
    - name: Setup test database
      run: |
        npx prisma migrate deploy
        npx prisma db seed
      env:
        DATABASE_URL: postgresql://postgres:postgres@localhost:5432/test_db
    
    - name: Run unit tests
      run: npm run test:unit
    
    - name: Run integration tests
      run: npm run test:integration
      env:
        DATABASE_URL: postgresql://postgres:postgres@localhost:5432/test_db
        REDIS_URL: redis://localhost:6379
    
    - name: Run E2E tests
      run: npm run test:e2e
    
    - name: Run security tests
      run: npm run test:security
    
    - name: Generate test report
      run: npm run test:report
    
    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v3
      with:
        file: ./coverage/lcov.info
```

## 12. 测试维护和优化

### 12.1 测试代码质量

**测试代码规范**:
- 清晰的测试命名
- 适当的测试粒度
- 避免测试间的依赖
- 使用Page Object模式
- 合理的断言

**测试重构策略**:
- 定期审查测试代码
- 消除重复代码
- 提取公共测试工具
- 优化测试性能

### 12.2 测试环境维护

**环境一致性**:
- 使用Docker容器化
- 版本控制测试配置
- 自动化环境部署
- 定期更新依赖

**测试数据管理**:
- 自动化数据准备
- 测试数据版本控制
- 数据隐私保护
- 定期清理测试数据

---

*文档版本：v1.0*  
*最后更新：2024年12月*  
*状态：设计阶段*