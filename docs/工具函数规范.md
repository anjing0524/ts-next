# lib工具函数统一规范

> **文档版本**: v2.0.0  
> **创建日期**: 2024-01-20  
> **最后更新**: 2024-12-19  
> **文档状态**: 正式版  
> **维护团队**: 开发团队

## 文档摘要

本文档定义了`/lib/`目录下工具函数的统一规范，包括代码结构、类型定义、错误处理、文档注释等标准，确保代码的一致性、可维护性和可测试性。项目使用 Jose 库处理 JWT，采用 Jest 作为测试框架。

## 目录

- [1. 总体架构](#1-总体架构)
- [2. 文件组织规范](#2-文件组织规范)
- [3. 代码规范](#3-代码规范)
- [4. 类型定义规范](#4-类型定义规范)
- [5. 错误处理规范](#5-错误处理规范)
- [6. 文档注释规范](#6-文档注释规范)
- [7. 测试规范](#7-测试规范)
- [8. 导出规范](#8-导出规范)

## 1. 总体架构

### 1.1 设计原则

- **单一职责**: 每个工具函数只负责一个特定功能
- **纯函数优先**: 尽量使用纯函数，避免副作用
- **类型安全**: 完整的TypeScript类型定义
- **错误处理**: 统一的错误处理机制
- **可测试性**: 易于单元测试的函数设计
- **向后兼容**: 保持API的稳定性

### 1.2 目录结构

```
lib/
├── index.ts                 # 统一导出入口
├── types/                   # 类型定义
│   ├── index.ts            # 类型统一导出
│   ├── auth.ts             # 认证相关类型
│   ├── oauth2.ts           # OAuth2 类型定义
│   ├── api.ts              # API 响应类型
│   ├── user.ts             # 用户相关类型
│   ├── client.ts           # 客户端类型
│   ├── jose.ts             # Jose JWT 相关类型
│   └── permission.ts       # 权限类型
├── oauth2/                  # OAuth2 相关工具
│   ├── index.ts            # OAuth2 工具导出
│   ├── pkce.ts             # PKCE 实现
│   ├── tokens.ts           # 令牌处理
│   ├── validation.ts       # 参数验证
│   ├── grants.ts           # 授权类型处理
│   ├── scopes.ts           # 作用域管理
│   └── endpoints.ts        # 端点处理
├── auth/                    # 认证工具
│   ├── index.ts            # 认证工具导出
│   ├── password.ts         # 密码处理
│   ├── session.ts          # 会话管理
│   ├── jose-jwt.ts         # Jose JWT 工具
│   ├── middleware.ts       # 认证中间件
│   └── rate-limit.ts       # 速率限制
├── permission/              # 权限相关
│   ├── index.ts            # 权限工具导出
│   ├── rbac.ts             # RBAC 实现
│   ├── scope.ts            # 作用域管理
│   ├── policy.ts           # 权限策略
│   └── checker.ts          # 权限检查器
├── utils/                   # 通用工具
│   ├── index.ts            # 工具函数导出
│   ├── crypto.ts           # 加密工具
│   ├── validation.ts       # 数据验证
│   ├── format.ts           # 格式化工具
│   ├── date.ts             # 日期工具
│   ├── string.ts           # 字符串工具
│   ├── url.ts              # URL 工具
│   └── random.ts           # 随机数生成
├── constants/               # 常量定义
│   ├── index.ts            # 常量统一导出
│   ├── oauth2.ts           # OAuth2 常量
│   ├── errors.ts           # 错误码定义
│   ├── config.ts           # 配置常量
│   ├── endpoints.ts        # 端点常量
│   └── timeouts.ts         # 超时配置
└── database/                # 数据库工具
    ├── index.ts            # 数据库工具导出
    ├── connection.ts       # 连接管理
    ├── migrations.ts       # 迁移工具
    └── queries.ts          # 查询构建器
```

### 文件组织原则

#### 命名规范
- **文件名**: 使用 kebab-case (如: `rate-limit.ts`)
- **目录名**: 使用 kebab-case (如: `oauth2/`)
- **导出文件**: 每个目录必须包含 `index.ts` 作为统一导出入口

#### 模块划分
- **按功能域划分**: 每个目录代表一个功能域
- **单一职责**: 每个文件只负责一个具体功能
- **依赖管理**: 避免循环依赖，明确依赖层次

#### 导出策略
```typescript
// lib/index.ts - 主导出文件
export * from './types';
export * from './oauth2';
export * from './auth';
export * from './permission';
export * from './utils';
export * from './constants';

// 分类导出
export * as OAuth2 from './oauth2';
export * as Auth from './auth';
export * as Permission from './permission';
export * as Utils from './utils';
export * as Constants from './constants';
```

## 2. 文件组织规范

### 2.1 文件命名

- 使用小写字母和连字符: `kebab-case.ts`
- 功能模块文件: `oauth2.ts`, `middleware.ts`
- 类型定义文件: `types.ts`, `interfaces.ts`
- 常量文件: `constants.ts`, `config.ts`
- 测试文件: `*.test.ts`, `*.spec.ts`

### 2.2 文件结构模板

```typescript
/**
 * @fileoverview OAuth2.1 PKCE工具函数
 * @author 开发团队
 * @since 2.0.0
 */

// 1. 导入依赖
import { createHash, randomBytes } from 'crypto';
import { base64url } from 'jose';
import type { PKCEParams, CodeChallenge } from '../types/oauth2';

// 2. 常量定义
const CODE_VERIFIER_LENGTH = 128;
const CODE_CHALLENGE_METHOD = 'S256';

// 3. 类型定义（如果不在types目录）
interface LocalType {
  // ...
}

// 4. 主要功能实现
export class PKCEUtils {
  // 实现代码
}

// 5. 辅助函数
function helperFunction() {
  // 实现代码
}

// 6. 默认导出（如果需要）
export default PKCEUtils;
```

## 3. 代码规范

### 3.1 函数定义规范

#### 纯函数优先
````typescript
/**
 * 生成PKCE code_verifier
 * @param length - 代码验证器长度 (默认128字符)
 * @returns {string} Base64URL编码的随机字符串
 * @throws {ValidationError} 当长度参数无效时
 * @throws {CryptoError} 当随机数生成失败时抛出错误
 * @example
 * ```typescript
 * const verifier = generateCodeVerifier();
 * console.log(verifier); // "dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk"
 * 
 * // 指定长度
 * const shortVerifier = generateCodeVerifier(64);
 * console.log(shortVerifier.length); // 64
 * ```
 * @see {@link https://tools.ietf.org/html/rfc7636#section-4.1 | RFC 7636 Section 4.1}
 */
export function generateCodeVerifier(length: number = 128): string {
  // 验证输入参数
  if (length < 43 || length > 128) {
    throw new ValidationError('Code verifier length must be between 43 and 128');
  }
  
  try {
    const buffer = randomBytes(Math.ceil(length * 3 / 4));
    return buffer
      .toString('base64')
      .replace(/\+/g, '-')
      .replace(/\//g, '_')
      .replace(/=/g, '')
      .substring(0, length);
  } catch (error) {
    throw new CryptoError(`Failed to generate code verifier: ${error.message}`);
  }
}

/**
 * 生成PKCE code_challenge
 * @param codeVerifier - 代码验证器 (43-128字符的随机字符串)
 * @param method - 挑战方法，默认为'S256'
 * @returns {string} Base64URL编码的code_challenge
 * @throws {ValidationError} 当代码验证器格式无效时
 * @throws {CryptoError} 当哈希计算失败时
 * @example
 * ```typescript
 * const verifier = generateCodeVerifier();
 * const challenge = generateCodeChallenge(verifier);
 * console.log(challenge); // 'E9Melhoa2OwvFrEMTJguCHaoeK1t8URWbuGJSstw-cM'
 * ```
 */
export function generateCodeChallenge(
  codeVerifier: string, 
  method: 'S256' | 'plain' = 'S256'
): string {
  // 验证输入参数
  if (!codeVerifier || codeVerifier.length < 43 || codeVerifier.length > 128) {
    throw new ValidationError('Code verifier must be 43-128 characters long');
  }
  
  if (!/^[A-Za-z0-9\-._~]+$/.test(codeVerifier)) {
    throw new ValidationError('Code verifier contains invalid characters');
  }
  
  if (method === 'plain') {
    return codeVerifier;
  }
  
  try {
    const hash = createHash('sha256');
    hash.update(codeVerifier);
    return hash.digest('base64')
      .replace(/\+/g, '-')
      .replace(/\//g, '_')
      .replace(/=/g, '');
  } catch (error) {
    throw new CryptoError('Failed to generate code challenge', error);
  }
}
````

### 3.2 类定义规范

```typescript
/**
 * OAuth2.1 PKCE工具类
 * 提供PKCE相关的代码生成和验证功能
 */
export class PKCEUtils {
  /**
   * 生成code_verifier
   * @static
   * @returns {string} 符合RFC 7636规范的code_verifier
   */
  static generateCodeVerifier(): string {
    // 实现代码
  }

  /**
   * 生成code_challenge
   * @static
   * @param {string} codeVerifier - code_verifier字符串
   * @param {string} method - 挑战方法，默认为'S256'
   * @returns {string} Base64URL编码的code_challenge
   */
  static generateCodeChallenge(codeVerifier: string, method: string = 'S256'): string {
    // 实现代码
  }

  /**
   * 验证code_challenge
   * @static
   * @param {string} codeVerifier - 原始code_verifier
   * @param {string} codeChallenge - 要验证的code_challenge
   * @param {string} method - 挑战方法
   * @returns {boolean} 验证结果
   */
  static verifyCodeChallenge(
    codeVerifier: string,
    codeChallenge: string,
    method: string = 'S256'
  ): boolean {
    // 实现代码
  }
}
```

## 4. 类型定义规范

### 4.1 接口定义

```typescript
// types/oauth.ts

/**
 * PKCE参数接口
 */
export interface PKCEParams {
  /** code_verifier字符串 */
  codeVerifier: string;
  /** code_challenge字符串 */
  codeChallenge: string;
  /** 挑战方法，通常为'S256' */
  codeChallengeMethod: 'S256' | 'plain';
}

/**
 * OAuth2.1授权请求参数
 */
export interface AuthorizationRequest {
  /** 响应类型 */
  responseType: 'code';
  /** 客户端ID */
  clientId: string;
  /** 重定向URI */
  redirectUri: string;
  /** 权限范围 */
  scope?: string;
  /** 状态参数 */
  state?: string;
  /** PKCE code_challenge */
  codeChallenge?: string;
  /** PKCE挑战方法 */
  codeChallengeMethod?: 'S256' | 'plain';
  /** OIDC nonce */
  nonce?: string;
}

/**
 * 令牌响应接口
 */
export interface TokenResponse {
  /** 访问令牌 */
  accessToken: string;
  /** 令牌类型 */
  tokenType: 'Bearer';
  /** 过期时间（秒） */
  expiresIn: number;
  /** 刷新令牌 */
  refreshToken?: string;
  /** ID令牌（OIDC） */
  idToken?: string;
  /** 权限范围 */
  scope?: string;
}
```

### 4.2 枚举定义

```typescript
// types/auth.ts

/**
 * 认证错误类型
 */
export enum AuthErrorType {
  INVALID_CREDENTIALS = 'INVALID_CREDENTIALS',
  ACCOUNT_LOCKED = 'ACCOUNT_LOCKED',
  TOKEN_EXPIRED = 'TOKEN_EXPIRED',
  INSUFFICIENT_PERMISSIONS = 'INSUFFICIENT_PERMISSIONS',
  INVALID_TOKEN = 'INVALID_TOKEN',
}

/**
 * 权限操作类型
 */
export enum PermissionAction {
  READ = 'read',
  WRITE = 'write',
  DELETE = 'delete',
  EXECUTE = 'execute',
}
```

## 5. 错误处理规范

### 5.1 自定义错误类

```typescript
// utils/errors.ts

/**
 * 基础错误类
 */
export abstract class BaseError extends Error {
  abstract readonly code: string;
  abstract readonly statusCode: number;
  
  constructor(
    message: string,
    public readonly cause?: unknown,
    public readonly context?: Record<string, unknown>
  ) {
    super(message);
    this.name = this.constructor.name;
    
    // 保持错误堆栈
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
  }
  
  /**
   * 转换为API响应格式
   */
  toApiResponse(): ApiErrorResponse {
    return {
      error: {
        code: this.code,
        message: this.message,
        context: this.context
      }
    };
  }
}

/**
 * 验证错误
 */
export class ValidationError extends BaseError {
  readonly code = 'VALIDATION_ERROR';
  readonly statusCode = 400;
  
  constructor(
    message: string,
    public readonly field?: string,
    cause?: unknown
  ) {
    super(message, cause, { field });
  }
}

/**
 * 认证错误
 */
export class AuthenticationError extends BaseError {
  readonly code = 'AUTHENTICATION_ERROR';
  readonly statusCode = 401;
  
  constructor(
    message: string,
    public readonly authMethod?: string,
    cause?: unknown
  ) {
    super(message, cause, { authMethod });
  }
}

/**
 * 授权错误
 */
export class AuthorizationError extends BaseError {
  readonly code = 'AUTHORIZATION_ERROR';
  readonly statusCode = 403;
  
  constructor(
    message: string,
    public readonly requiredPermission?: string,
    public readonly userPermissions?: string[],
    cause?: unknown
  ) {
    super(message, cause, { 
      requiredPermission, 
      userPermissions 
    });
  }
}

/**
 * 令牌相关错误
 */
export class TokenError extends BaseError {
  readonly code = 'TOKEN_ERROR';
  readonly statusCode = 401;
}

export class TokenGenerationError extends TokenError {
  readonly code = 'TOKEN_GENERATION_ERROR';
  readonly statusCode = 500;
}

export class TokenValidationError extends TokenError {
  readonly code = 'TOKEN_VALIDATION_ERROR';
}

export class TokenExpiredError extends TokenError {
  readonly code = 'TOKEN_EXPIRED';
}

export class TokenRevocationError extends TokenError {
  readonly code = 'TOKEN_REVOCATION_ERROR';
  readonly statusCode = 500;
}

/**
 * 加密相关错误
 */
export class CryptoError extends BaseError {
  readonly code = 'CRYPTO_ERROR';
  readonly statusCode = 500;
}

/**
 * 配置错误
 */
export class ConfigurationError extends BaseError {
  readonly code = 'CONFIGURATION_ERROR';
  readonly statusCode = 500;
}

/**
 * OAuth2特定错误
 */
export class OAuth2Error extends BaseError {
  readonly statusCode = 400;
  
  constructor(
    public readonly errorCode: OAuth2ErrorCode,
    message: string,
    public readonly errorDescription?: string,
    public readonly errorUri?: string,
    cause?: unknown
  ) {
    super(message, cause, {
      error: errorCode,
      error_description: errorDescription,
      error_uri: errorUri
    });
  }
  
  get code(): string {
    return this.errorCode;
  }
  
  /**
   * 转换为OAuth2标准错误响应
   */
  toOAuth2Response(): OAuth2ErrorResponse {
    return {
      error: this.errorCode,
      error_description: this.errorDescription || this.message,
      error_uri: this.errorUri
    };
  }
}

/**
 * OAuth2错误代码枚举
 */
export enum OAuth2ErrorCode {
  INVALID_REQUEST = 'invalid_request',
  INVALID_CLIENT = 'invalid_client',
  INVALID_GRANT = 'invalid_grant',
  UNAUTHORIZED_CLIENT = 'unauthorized_client',
  UNSUPPORTED_GRANT_TYPE = 'unsupported_grant_type',
  INVALID_SCOPE = 'invalid_scope',
  ACCESS_DENIED = 'access_denied',
  UNSUPPORTED_RESPONSE_TYPE = 'unsupported_response_type',
  SERVER_ERROR = 'server_error',
  TEMPORARILY_UNAVAILABLE = 'temporarily_unavailable'
}
```

### 5.2 错误处理模式

```typescript
// lib/utils/error-handler.ts

/**
 * 统一错误处理函数
 * @param error - 捕获的错误
 * @param context - 错误上下文信息
 * @returns 永不返回，总是抛出处理后的错误
 */
export function handleError(
  error: unknown, 
  context?: Record<string, unknown>
): never {
  // 如果已经是我们的自定义错误，直接重新抛出
  if (error instanceof BaseError) {
    throw error;
  }
  
  // 处理标准Error对象
  if (error instanceof Error) {
    // 根据错误消息判断错误类型
    if (error.message.includes('validation')) {
      throw new ValidationError(error.message, undefined, error);
    }
    
    if (error.message.includes('unauthorized') || error.message.includes('authentication')) {
      throw new AuthenticationError(error.message, undefined, error);
    }
    
    if (error.message.includes('forbidden') || error.message.includes('permission')) {
      throw new AuthorizationError(error.message, undefined, undefined, error);
    }
    
    if (error.message.includes('token')) {
      throw new TokenError(error.message, error);
    }
  }
  
  // 未知错误类型
  console.error('Unexpected error:', error, 'Context:', context);
  throw new class extends BaseError {
    readonly code = 'INTERNAL_ERROR';
    readonly statusCode = 500;
  }(
    'An unexpected error occurred',
    error,
    context
  );
}

/**
 * 异步函数错误包装器
 * @param fn - 要包装的异步函数
 * @param context - 错误上下文
 * @returns 包装后的函数
 */
export function withErrorHandling<T extends (...args: any[]) => Promise<any>>(
  fn: T,
  context?: Record<string, unknown>
): T {
  return (async (...args: Parameters<T>) => {
    try {
      return await fn(...args);
    } catch (error) {
      handleError(error, context);
    }
  }) as T;
}

/**
 * 结果类型，用于函数式错误处理
 */
export type Result<T, E = BaseError> = 
  | { success: true; data: T }
  | { success: false; error: E };

/**
 * 安全执行函数，返回Result类型
 * @param fn - 要执行的函数
 * @returns Result类型的结果
 */
export async function safeExecute<T>(
  fn: () => Promise<T> | T
): Promise<Result<T>> {
  try {
    const data = await fn();
    return { success: true, data };
  } catch (error) {
    if (error instanceof BaseError) {
      return { success: false, error };
    }
    
    return {
      success: false,
      error: new class extends BaseError {
        readonly code = 'EXECUTION_ERROR';
        readonly statusCode = 500;
      }(
        'Execution failed',
        error
      )
    };
  }
}

/**
 * 错误日志记录
 */
export function logError(
  error: BaseError,
  additionalContext?: Record<string, unknown>
): void {
  const logData = {
    timestamp: new Date().toISOString(),
    error: {
      name: error.name,
      code: error.code,
      message: error.message,
      statusCode: error.statusCode,
      context: error.context,
      stack: error.stack
    },
    additionalContext
  };
  
  // 根据错误级别选择日志方法
  if (error.statusCode >= 500) {
    console.error('Server Error:', logData);
  } else if (error.statusCode >= 400) {
    console.warn('Client Error:', logData);
  } else {
    console.info('Error Info:', logData);
  }
}

/**
 * 使用示例
 */
export async function validateToken(token: string): Promise<Result<JWTPayload>> {
  return safeExecute(async () => {
    if (!token) {
      throw new AuthenticationError('Token is required');
    }

    const payload = await verifyJWT(token);
    return payload;
  });
}
```

## 6. 测试要求

### 6.1 单元测试规范

每个工具函数都必须包含完整的单元测试，测试覆盖率要求达到90%以上。

```typescript
// lib/oauth2/__tests__/pkce.test.ts
import { describe, it, expect, vi } from 'vitest';
import { generateCodeVerifier, generateCodeChallenge } from '../pkce';
import { ValidationError, CryptoError } from '../../types/errors';

describe('PKCE Utils', () => {
  describe('generateCodeVerifier', () => {
    it('should generate code verifier with default length', () => {
      const verifier = generateCodeVerifier();
      
      expect(verifier).toBeDefined();
      expect(typeof verifier).toBe('string');
      expect(verifier.length).toBe(128);
      expect(/^[A-Za-z0-9\-._~]+$/.test(verifier)).toBe(true);
    });
    
    it('should generate code verifier with custom length', () => {
      const length = 64;
      const verifier = generateCodeVerifier(length);
      
      expect(verifier.length).toBe(length);
    });
    
    it('should throw ValidationError for invalid length', () => {
      expect(() => generateCodeVerifier(42)).toThrow(ValidationError);
      expect(() => generateCodeVerifier(129)).toThrow(ValidationError);
    });
    
    it('should generate unique verifiers', () => {
      const verifier1 = generateCodeVerifier();
      const verifier2 = generateCodeVerifier();
      
      expect(verifier1).not.toBe(verifier2);
    });
    
    it('should handle crypto errors gracefully', () => {
      // Mock crypto failure
      const originalRandomBytes = vi.fn().mockImplementation(() => {
        throw new Error('Crypto failure');
      });
      
      vi.mock('crypto', () => ({
        randomBytes: originalRandomBytes
      }));
      
      expect(() => generateCodeVerifier()).toThrow(CryptoError);
    });
  });
  
  describe('generateCodeChallenge', () => {
    it('should generate valid code challenge for S256 method', () => {
      const verifier = 'dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk';
      const challenge = generateCodeChallenge(verifier);
      
      expect(challenge).toBeDefined();
      expect(typeof challenge).toBe('string');
      expect(challenge).toBe('E9Melhoa2OwvFrEMTJguCHaoeK1t8URWbuGJSstw-cM');
    });
    
    it('should return verifier for plain method', () => {
      const verifier = 'test-verifier';
      const challenge = generateCodeChallenge(verifier, 'plain');
      
      expect(challenge).toBe(verifier);
    });
    
    it('should validate code verifier format', () => {
      expect(() => generateCodeChallenge('')).toThrow(ValidationError);
      expect(() => generateCodeChallenge('short')).toThrow(ValidationError);
      expect(() => generateCodeChallenge('invalid@chars')).toThrow(ValidationError);
    });
    
    it('should be deterministic for same input', () => {
      const verifier = 'test-verifier-123';
      const challenge1 = generateCodeChallenge(verifier);
      const challenge2 = generateCodeChallenge(verifier);
      
      expect(challenge1).toBe(challenge2);
    });
  });
});
```

### 6.2 集成测试规范

```typescript
// lib/oauth2/__tests__/token-manager.integration.test.ts
import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { TokenManager } from '../token-manager';
import { TokenConfig, TokenPayload } from '../../types';

describe('TokenManager Integration', () => {
  let tokenManager: TokenManager;
  let config: TokenConfig;
  
  beforeEach(() => {
    config = {
      jwtSecret: 'test-secret-key-with-sufficient-length',
      issuer: 'https://test.oauth.com',
      accessTokenTtl: 3600,
      refreshTokenTtl: 86400
    };
    
    tokenManager = new TokenManager(config);
  });
  
  afterEach(() => {
    // 清理资源
  });
  
  describe('Token Lifecycle', () => {
    it('should complete full token lifecycle', async () => {
      const payload: TokenPayload = {
        sub: 'user123',
        client_id: 'client456',
        scope: 'read write'
      };
      
      // 生成访问令牌
      const accessToken = await tokenManager.generateAccessToken(payload);
      expect(accessToken).toBeDefined();
      
      // 验证访问令牌
      const validatedPayload = await tokenManager.validateToken(accessToken);
      expect(validatedPayload.sub).toBe(payload.sub);
      expect(validatedPayload.client_id).toBe(payload.client_id);
      
      // 生成刷新令牌
      const refreshToken = await tokenManager.generateRefreshToken(payload);
      expect(refreshToken).toBeDefined();
      
      // 撤销令牌
      const revoked = await tokenManager.revokeToken(accessToken);
      expect(revoked).toBe(true);
    });
    
    it('should handle token expiration', async () => {
      // 创建短期令牌配置
      const shortConfig = { ...config, accessTokenTtl: 1 };
      const shortTokenManager = new TokenManager(shortConfig);
      
      const payload: TokenPayload = {
        sub: 'user123',
        client_id: 'client456',
        scope: 'read'
      };
      
      const token = await shortTokenManager.generateAccessToken(payload);
      
      // 等待令牌过期
      await new Promise(resolve => setTimeout(resolve, 1100));
      
      // 验证过期令牌应该失败
      await expect(shortTokenManager.validateToken(token))
        .rejects.toThrow('Token has expired');
    });
  });
});
```

### 6.3 性能测试规范

```typescript
// lib/oauth2/__tests__/performance.test.ts
import { describe, it, expect } from 'vitest';
import { generateCodeVerifier, generateCodeChallenge } from '../pkce';
import { TokenManager } from '../token-manager';

describe('Performance Tests', () => {
  it('should generate code verifier efficiently', () => {
    const iterations = 1000;
    const startTime = performance.now();
    
    for (let i = 0; i < iterations; i++) {
      generateCodeVerifier();
    }
    
    const endTime = performance.now();
    const avgTime = (endTime - startTime) / iterations;
    
    // 平均每次生成应该少于1ms
    expect(avgTime).toBeLessThan(1);
  });
  
  it('should handle concurrent token generation', async () => {
    const tokenManager = new TokenManager({
      jwtSecret: 'test-secret-key-with-sufficient-length',
      issuer: 'https://test.oauth.com',
      accessTokenTtl: 3600,
      refreshTokenTtl: 86400
    });
    
    const payload = {
      sub: 'user123',
      client_id: 'client456',
      scope: 'read write'
    };
    
    const concurrentRequests = 100;
    const startTime = performance.now();
    
    const promises = Array.from({ length: concurrentRequests }, () =>
      tokenManager.generateAccessToken(payload)
    );
    
    const tokens = await Promise.all(promises);
    const endTime = performance.now();
    
    expect(tokens).toHaveLength(concurrentRequests);
    expect(tokens.every(token => typeof token === 'string')).toBe(true);
    
    // 并发生成100个令牌应该在合理时间内完成
    expect(endTime - startTime).toBeLessThan(1000);
  });
});
```

### 6.4 测试配置

```typescript
// vitest.config.ts (针对lib目录)
import { defineConfig } from 'vitest/config';
import path from 'path';

export default defineConfig({
  test: {
    globals: true,
    environment: 'node',
    include: ['lib/**/*.{test,spec}.{js,ts}'],
    exclude: ['node_modules', 'dist'],
    coverage: {
      provider: 'v8',
      reporter: ['text', 'json', 'html'],
      include: ['lib/**/*.{js,ts}'],
      exclude: [
        'lib/**/*.{test,spec}.{js,ts}',
        'lib/**/*.d.ts',
        'lib/**/index.ts'
      ],
      thresholds: {
        global: {
          branches: 90,
          functions: 90,
          lines: 90,
          statements: 90
        }
      }
    },
    setupFiles: ['./lib/test-setup.ts']
  },
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './'),
      '@/lib': path.resolve(__dirname, './lib')
    }
  }
});
```

## 7. 文档注释规范

### 7.1 JSDoc标准

所有公开的函数、类、接口都必须包含完整的JSDoc注释：

```typescript
/**
 * 生成OAuth2授权码
 * 
 * 根据OAuth2.1规范生成安全的授权码，用于授权码流程中的临时凭证。
 * 授权码具有短期有效性，通常在10分钟内过期。
 * 
 * @param clientId - OAuth2客户端标识符
 * @param userId - 用户唯一标识符
 * @param scope - 请求的权限范围，多个范围用空格分隔
 * @param redirectUri - 授权完成后的重定向URI
 * @param codeChallenge - PKCE代码挑战（可选，用于公共客户端）
 * @param codeChallengeMethod - PKCE挑战方法，默认为'S256'
 * @returns Promise<string> 生成的授权码字符串
 * 
 * @throws {ValidationError} 当输入参数格式无效时
 * @throws {AuthorizationError} 当客户端无权限请求指定范围时
 * @throws {CryptoError} 当随机数生成失败时
 * 
 * @example
 * ```typescript
 * // 基本用法
 * const authCode = await generateAuthorizationCode(
 *   'client123',
 *   'user456', 
 *   'read write',
 *   'https://app.example.com/callback'
 * );
 * 
 * // 使用PKCE的公共客户端
 * const codeVerifier = generateCodeVerifier();
 * const codeChallenge = generateCodeChallenge(codeVerifier);
 * const authCodeWithPKCE = await generateAuthorizationCode(
 *   'public-client',
 *   'user789',
 *   'read',
 *   'https://mobile.app/callback',
 *   codeChallenge,
 *   'S256'
 * );
 * ```
 * 
 * @see {@link https://tools.ietf.org/html/rfc6749#section-4.1.2 | RFC 6749 Section 4.1.2}
 * @see {@link https://tools.ietf.org/html/rfc7636 | RFC 7636 - PKCE}
 * @since 1.0.0
 * @version 1.2.0
 * @author OAuth Team
 */
export async function generateAuthorizationCode(
  clientId: string,
  userId: string,
  scope: string,
  redirectUri: string,
  codeChallenge?: string,
  codeChallengeMethod: 'S256' | 'plain' = 'S256'
): Promise<string> {
  // 实现逻辑...
}
```

### 7.2 类型注释

```typescript
/**
 * OAuth2客户端配置信息
 * 
 * 定义OAuth2客户端的基本信息和安全配置，用于客户端注册和验证。
 * 
 * @interface OAuthClientConfig
 * @since 1.0.0
 */
export interface OAuthClientConfig {
  /** 
   * 客户端唯一标识符
   * @example 'web-app-client-123'
   */
  clientId: string;
  
  /** 
   * 客户端密钥（仅限机密客户端）
   * @description 用于客户端身份验证，公共客户端应为undefined
   * @example 'super-secret-key-abc123'
   */
  clientSecret?: string;
  
  /** 
   * 客户端类型
   * @description 'confidential'表示能够安全存储凭据的客户端，'public'表示无法安全存储凭据的客户端
   */
  clientType: 'confidential' | 'public';
  
  /** 
   * 客户端显示名称
   * @example 'My Web Application'
   */
  name: string;
  
  /** 
   * 允许的重定向URI列表
   * @description 授权完成后允许重定向的URI列表，必须使用HTTPS（开发环境除外）
   * @example ['https://app.example.com/callback', 'https://app.example.com/auth']
   */
  redirectUris: string[];
  
  /** 
   * 允许的权限范围
   * @description 客户端可以请求的最大权限范围
   * @example ['read', 'write', 'admin']
   */
  allowedScopes: string[];
  
  /** 
   * 访问令牌生存时间（秒）
   * @default 3600
   * @minimum 300
   * @maximum 86400
   */
  accessTokenTtl: number;
  
  /** 
   * 刷新令牌生存时间（秒）
   * @default 2592000
   * @minimum 3600
   * @maximum 31536000
   */
  refreshTokenTtl: number;
  
  /** 
   * 是否强制要求PKCE
   * @description 公共客户端应始终为true，机密客户端可选
   * @default true
   */
  requirePkce: boolean;
  
  /** 
   * 客户端是否激活
   * @description 非激活客户端无法进行授权
   * @default true
   */
  isActive: boolean;
  
  /** 
   * 客户端创建时间
   * @readonly
   */
  readonly createdAt: Date;
  
  /** 
   * 客户端最后更新时间
   * @readonly
   */
  readonly updatedAt: Date;
}
```

### 7.3 枚举注释

```typescript
/**
 * OAuth2授权类型枚举
 * 
 * 定义OAuth2.1规范支持的授权类型，用于不同的授权场景。
 * 
 * @enum {string}
 * @readonly
 * @since 1.0.0
 */
export enum GrantType {
  /** 
   * 授权码流程
   * @description 最安全的授权流程，适用于Web应用和移动应用
   * @see {@link https://tools.ietf.org/html/rfc6749#section-4.1 | RFC 6749 Section 4.1}
   */
  AUTHORIZATION_CODE = 'authorization_code',
  
  /** 
   * 客户端凭据流程
   * @description 用于服务间通信，客户端直接使用自己的凭据获取访问令牌
   * @see {@link https://tools.ietf.org/html/rfc6749#section-4.4 | RFC 6749 Section 4.4}
   */
  CLIENT_CREDENTIALS = 'client_credentials',
  
  /** 
   * 刷新令牌流程
   * @description 使用刷新令牌获取新的访问令牌
   * @see {@link https://tools.ietf.org/html/rfc6749#section-6 | RFC 6749 Section 6}
   */
  REFRESH_TOKEN = 'refresh_token'
}
```

## 7. 测试规范

### 7.1 单元测试结构

```typescript
// __tests__/oauth2/pkce.test.ts

import { describe, test, expect, beforeEach, afterEach } from 'vitest';
import { PKCEUtils } from '../../oauth2/pkce';

describe('PKCEUtils', () => {
  describe('generateCodeVerifier', () => {
    test('应该生成符合长度要求的code_verifier', () => {
      const verifier = PKCEUtils.generateCodeVerifier();

      expect(verifier).toBeDefined();
      expect(verifier.length).toBeGreaterThanOrEqual(43);
      expect(verifier.length).toBeLessThanOrEqual(128);
    });

    test('应该生成URL安全的字符串', () => {
      const verifier = PKCEUtils.generateCodeVerifier();

      expect(verifier).toMatch(/^[A-Za-z0-9\-._~]+$/);
    });

    test('每次生成的verifier应该不同', () => {
      const verifier1 = PKCEUtils.generateCodeVerifier();
      const verifier2 = PKCEUtils.generateCodeVerifier();

      expect(verifier1).not.toBe(verifier2);
    });
  });

  describe('generateCodeChallenge', () => {
    test('应该为相同的verifier生成相同的challenge', () => {
      const verifier = 'test-verifier-123';
      const challenge1 = PKCEUtils.generateCodeChallenge(verifier);
      const challenge2 = PKCEUtils.generateCodeChallenge(verifier);

      expect(challenge1).toBe(challenge2);
    });

    test('应该生成Base64URL编码的字符串', () => {
      const verifier = 'test-verifier-123';
      const challenge = PKCEUtils.generateCodeChallenge(verifier);

      expect(challenge).toMatch(/^[A-Za-z0-9\-_]+$/);
    });
  });

  describe('verifyCodeChallenge', () => {
    test('应该验证正确的verifier和challenge组合', () => {
      const verifier = PKCEUtils.generateCodeVerifier();
      const challenge = PKCEUtils.generateCodeChallenge(verifier);

      const isValid = PKCEUtils.verifyCodeChallenge(verifier, challenge);
      expect(isValid).toBe(true);
    });

    test('应该拒绝错误的verifier和challenge组合', () => {
      const verifier1 = PKCEUtils.generateCodeVerifier();
      const verifier2 = PKCEUtils.generateCodeVerifier();
      const challenge = PKCEUtils.generateCodeChallenge(verifier1);

      const isValid = PKCEUtils.verifyCodeChallenge(verifier2, challenge);
      expect(isValid).toBe(false);
    });
  });
});
```

### 7.2 集成测试示例

```typescript
// __tests__/integration/auth-flow.test.ts

import { describe, test, expect, beforeAll, afterAll } from 'vitest';
import { setupTestDatabase, cleanupTestDatabase } from '../helpers/database';
import { createTestClient, createTestUser } from '../helpers/factories';
import { PKCEUtils } from '../../oauth2/pkce';
import { AuthService } from '../../auth/service';

describe('OAuth2.1 Authorization Flow Integration', () => {
  beforeAll(async () => {
    await setupTestDatabase();
  });

  afterAll(async () => {
    await cleanupTestDatabase();
  });

  test('完整的授权码流程应该成功', async () => {
    // 准备测试数据
    const client = await createTestClient();
    const user = await createTestUser();
    const { codeVerifier, codeChallenge } = PKCEUtils.generatePKCEPair();

    // 1. 授权请求
    const authResult = await AuthService.authorize({
      responseType: 'code',
      clientId: client.clientId,
      redirectUri: client.redirectUris[0],
      scope: 'openid profile',
      codeChallenge,
      codeChallengeMethod: 'S256',
      userId: user.id,
    });

    expect(authResult.success).toBe(true);
    expect(authResult.data.code).toBeDefined();

    // 2. 令牌交换
    const tokenResult = await AuthService.exchangeToken({
      grantType: 'authorization_code',
      code: authResult.data.code,
      redirectUri: client.redirectUris[0],
      clientId: client.clientId,
      codeVerifier,
    });

    expect(tokenResult.success).toBe(true);
    expect(tokenResult.data.accessToken).toBeDefined();
    expect(tokenResult.data.refreshToken).toBeDefined();
  });
});
```

## 8. 导出规范

### 8.1 统一导出文件

```typescript
// lib/index.ts

// OAuth2.1相关导出
export * from './oauth2';
export { PKCEUtils } from './oauth2/pkce';
export { JWTUtils } from './oauth2/jwt';

// 认证相关导出
export * from './auth';
export { authMiddleware } from './auth/middleware';
export { PasswordUtils } from './auth/password';

// 权限相关导出
export * from './permission';
export { PermissionService } from './permission/service';
export { RBACUtils } from './permission/rbac';

// 工具函数导出
export * from './utils';
export { CryptoUtils } from './utils/crypto';
export { ValidationUtils } from './utils/validation';
export { CacheUtils } from './utils/cache';
export { Logger } from './utils/logger';

// 类型定义导出
export * from './types';

// 常量导出
export * from './constants';

// 错误类导出
export * from './utils/errors';
```

### 8.2 模块导出文件

```typescript
// lib/oauth2/index.ts

export { PKCEUtils } from './pkce';
export { JWTUtils } from './jwt';
export { OAuth2Validator } from './validation';

// 重新导出类型
export type { PKCEParams, AuthorizationRequest, TokenResponse } from '../types/oauth';

// 重新导出常量
export { OAUTH2_GRANT_TYPES, OAUTH2_RESPONSE_TYPES, OAUTH2_SCOPES } from '../constants/oauth';
```

### 8.3 使用示例

```typescript
// 在应用代码中使用
import {
  PKCEUtils,
  authMiddleware,
  PermissionService,
  AuthenticationError,
  type AuthorizationRequest,
} from '@/lib';

// 或者按模块导入
import { PKCEUtils } from '@/lib/oauth2';
import { authMiddleware } from '@/lib/auth';
import { PermissionService } from '@/lib/permission';
```

## 9. 版本管理

### 9.1 语义化版本

- **主版本号**: 不兼容的API修改
- **次版本号**: 向后兼容的功能性新增
- **修订号**: 向后兼容的问题修正

### 9.2 变更日志

```markdown
# 变更日志

## [1.1.0] - 2024-01-20

### 新增

- 添加JWT令牌轮换功能
- 支持Redis缓存配置

### 修改

- 优化权限查询性能
- 更新错误消息格式

### 修复

- 修复PKCE验证边界情况
- 解决内存泄漏问题

### 废弃

- `oldFunction()` 将在v2.0.0中移除

## [1.0.0] - 2024-01-15

### 新增

- 初始版本发布
- OAuth2.1核心功能
- RBAC权限系统
```

## 9. 最佳实践

### 9.1 性能优化

```typescript
// lib/utils/performance.ts

/**
 * 性能监控装饰器
 * @param threshold - 性能阈值（毫秒）
 */
export function performanceMonitor(threshold: number = 100) {
  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    const originalMethod = descriptor.value;
    
    descriptor.value = async function (...args: any[]) {
      const startTime = performance.now();
      
      try {
        const result = await originalMethod.apply(this, args);
        const endTime = performance.now();
        const duration = endTime - startTime;
        
        if (duration > threshold) {
          console.warn(`Performance warning: ${propertyKey} took ${duration.toFixed(2)}ms`);
        }
        
        return result;
      } catch (error) {
        const endTime = performance.now();
        const duration = endTime - startTime;
        console.error(`Error in ${propertyKey} after ${duration.toFixed(2)}ms:`, error);
        throw error;
      }
    };
    
    return descriptor;
  };
}

/**
 * 缓存管理器
 */
export class CacheManager {
  private static cache = new Map<string, { value: any; expiry: number }>();
  
  /**
   * 设置缓存
   * @param key - 缓存键
   * @param value - 缓存值
   * @param ttl - 生存时间（毫秒）
   */
  static set(key: string, value: any, ttl: number = 300000): void {
    const expiry = Date.now() + ttl;
    this.cache.set(key, { value, expiry });
  }
  
  /**
   * 获取缓存
   * @param key - 缓存键
   * @returns 缓存值或undefined
   */
  static get<T>(key: string): T | undefined {
    const item = this.cache.get(key);
    
    if (!item) return undefined;
    
    if (Date.now() > item.expiry) {
      this.cache.delete(key);
      return undefined;
    }
    
    return item.value;
  }
  
  /**
   * 清理过期缓存
   */
  static cleanup(): void {
    const now = Date.now();
    for (const [key, item] of this.cache.entries()) {
      if (now > item.expiry) {
        this.cache.delete(key);
      }
    }
  }
}

/**
 * 缓存装饰器
 * @param ttl - 缓存时间（毫秒）
 */
export function cached(ttl: number = 300000) {
  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    const originalMethod = descriptor.value;
    
    descriptor.value = async function (...args: any[]) {
      const cacheKey = `${propertyKey}_${JSON.stringify(args)}`;
      const cached = CacheManager.get(cacheKey);
      
      if (cached !== undefined) {
        return cached;
      }
      
      const result = await originalMethod.apply(this, args);
      CacheManager.set(cacheKey, result, ttl);
      
      return result;
    };
    
    return descriptor;
  };
}
```

### 9.2 安全考虑

```typescript
// lib/utils/security.ts

/**
 * 安全工具函数
 */
export class SecurityUtils {
  /**
   * 安全的字符串比较（防止时序攻击）
   * @param a - 字符串A
   * @param b - 字符串B
   * @returns 是否相等
   */
  static safeStringCompare(a: string, b: string): boolean {
    if (a.length !== b.length) {
      return false;
    }
    
    let result = 0;
    for (let i = 0; i < a.length; i++) {
      result |= a.charCodeAt(i) ^ b.charCodeAt(i);
    }
    
    return result === 0;
  }
  
  /**
   * 输入清理
   * @param input - 输入字符串
   * @returns 清理后的字符串
   */
  static sanitizeInput(input: string): string {
    return input
      .replace(/[<>"'&]/g, (char) => {
        const entities: Record<string, string> = {
          '<': '&lt;',
          '>': '&gt;',
          '"': '&quot;',
          "'": '&#x27;',
          '&': '&amp;'
        };
        return entities[char] || char;
      })
      .trim();
  }
  
  /**
   * 验证URL安全性
   * @param url - 待验证的URL
   * @returns 是否安全
   */
  static isSecureUrl(url: string): boolean {
    try {
      const parsed = new URL(url);
      
      // 只允许HTTPS和HTTP（开发环境）
      if (!['https:', 'http:'].includes(parsed.protocol)) {
        return false;
      }
      
      // 禁止本地文件协议
      if (['file:', 'ftp:', 'data:'].includes(parsed.protocol)) {
        return false;
      }
      
      // 检查主机名
      if (parsed.hostname === 'localhost' && process.env.NODE_ENV === 'production') {
        return false;
      }
      
      return true;
    } catch {
      return false;
    }
  }
  
  /**
   * 生成安全的随机字符串
   * @param length - 字符串长度
   * @returns 随机字符串
   */
  static generateSecureRandom(length: number): string {
    const charset = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~';
    let result = '';
    
    for (let i = 0; i < length; i++) {
      const randomIndex = Math.floor(Math.random() * charset.length);
      result += charset[randomIndex];
    }
    
    return result;
  }
}

/**
 * 速率限制器
 */
export class RateLimiter {
  private static requests = new Map<string, number[]>();
  
  /**
   * 检查是否超过速率限制
   * @param key - 限制键（如IP地址）
   * @param limit - 限制次数
   * @param window - 时间窗口（毫秒）
   * @returns 是否允许请求
   */
  static isAllowed(key: string, limit: number, window: number): boolean {
    const now = Date.now();
    const requests = this.requests.get(key) || [];
    
    // 清理过期请求
    const validRequests = requests.filter(time => now - time < window);
    
    if (validRequests.length >= limit) {
      return false;
    }
    
    validRequests.push(now);
    this.requests.set(key, validRequests);
    
    return true;
  }
  
  /**
   * 清理过期数据
   */
  static cleanup(): void {
    const now = Date.now();
    for (const [key, requests] of this.requests.entries()) {
      const validRequests = requests.filter(time => now - time < 3600000); // 1小时
      if (validRequests.length === 0) {
        this.requests.delete(key);
      } else {
        this.requests.set(key, validRequests);
      }
    }
  }
}
```

### 9.3 可维护性指南

- 保持函数简洁，单一职责
- 使用有意义的变量和函数名
- 添加充分的测试覆盖
- 定期重构和优化代码
- 遵循SOLID原则
- 使用适当的设计模式

## 10. 总结

本规范文档定义了OAuth2.1认证授权中心项目中`/lib/`目录下工具函数的开发标准，包括：

1. **代码结构规范** - 统一的文件组织和命名约定
2. **类型定义规范** - 完整的TypeScript类型系统
3. **错误处理规范** - 统一的错误类型和处理机制
4. **测试要求** - 全面的测试策略和覆盖率要求
5. **文档注释规范** - 详细的JSDoc注释标准
6. **版本管理** - 语义化版本控制和兼容性保证
7. **最佳实践** - 性能优化、安全考虑和可维护性指南

遵循这些规范将确保代码的一致性、可维护性和安全性，为项目的长期发展奠定坚实基础。

---

**注意**: 本规范是活文档，会根据项目发展和最佳实践的演进持续更新。所有开发人员都应遵循此规范，确保代码质量和团队协作效率。
