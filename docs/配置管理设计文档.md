# 配置管理设计文档

**版本**: v1.0.0  
**创建日期**: 2025-06-27  
**最后更新**: 2025-06-27  
**状态**: 正式版  
**维护团队**: 架构组

## 文档摘要

本文档描述了OAuth2.1认证授权中心的统一配置管理方案，涵盖配置中心化、环境变量管理、Token存储安全策略等关键设计决策。通过统一配置管理，消除了硬编码配置，提高了系统的可维护性和安全性。

## 核心设计原则

- ✅ **配置中心化**: 所有配置通过统一的配置类管理
- ✅ **环境变量优先**: 支持通过环境变量覆盖默认配置
- ✅ **类型安全**: 提供完整的TypeScript类型定义
- ✅ **安全存储**: Token采用Cookie + sessionStorage双重安全策略
- ✅ **零硬编码**: 消除所有硬编码的URL、密钥等配置

## 配置架构设计

### 1. 统一配置类设计

#### OAuthConfig类结构

```typescript
/**
 * OAuth2.1认证服务统一配置管理
 * 提供类型安全的配置访问接口，支持环境变量覆盖
 */
export class OAuthConfig {
  // 基础服务配置
  private static readonly DEFAULT_OAUTH_SERVICE_URL = 'http://localhost:3001/datamgr_flow';
  private static readonly DEFAULT_CLIENT_ID = 'auth-center-admin-client';
  private static readonly DEFAULT_CLIENT_SECRET = 'authcenteradminclientsecret';
  private static readonly DEFAULT_REDIRECT_URI = 'http://localhost:3002/auth/callback';

  // 环境变量覆盖支持
  public static getBaseUrl(): string;
  public static getAuthorizeUrl(): string;
  public static getTokenUrl(): string;
  public static getUserInfoUrl(): string;
  public static getClientConfig(): ClientConfig;
}
```

#### 配置接口定义

```typescript
/**
 * OAuth客户端配置接口
 */
export interface ClientConfig {
  clientId: string;
  clientSecret: string;
  redirectUri: string;
}

/**
 * 服务端点配置接口
 */
export interface ServiceEndpoints {
  authorize: string;
  token: string;
  userInfo: string;
  revoke: string;
}
```

### 2. 环境变量配置

#### 支持的环境变量

| 环境变量                        | 默认值                               | 说明             |
| ------------------------------- | ------------------------------------ | ---------------- |
| `NEXT_PUBLIC_OAUTH_SERVICE_URL` | `http://localhost:3001/datamgr_flow` | OAuth服务基础URL |
| `NEXT_PUBLIC_OAUTH_CLIENT_ID`   | `auth-center-admin-client`           | OAuth客户端ID    |
| `OAUTH_CLIENT_SECRET`           | `authcenteradminclientsecret`        | OAuth客户端密钥  |
| `NEXT_PUBLIC_APP_URL`           | `http://localhost:3002`              | 应用基础URL      |

#### 配置文件示例

```bash
# .env.local - 开发环境
NEXT_PUBLIC_OAUTH_SERVICE_URL=http://localhost:3001/datamgr_flow
NEXT_PUBLIC_OAUTH_CLIENT_ID=auth-center-admin-client
OAUTH_CLIENT_SECRET=authcenteradminclientsecret
NEXT_PUBLIC_APP_URL=http://localhost:3002

# .env.production - 生产环境
NEXT_PUBLIC_OAUTH_SERVICE_URL=https://oauth.example.com
NEXT_PUBLIC_OAUTH_CLIENT_ID=prod-admin-client
OAUTH_CLIENT_SECRET=your-production-secret
NEXT_PUBLIC_APP_URL=https://admin.example.com
```

## Token存储安全策略

### 1. 存储策略对比

| 存储方式                    | 安全性 | XSS风险 | CSRF风险 | 使用场景     |
| --------------------------- | ------ | ------- | -------- | ------------ |
| localStorage                | ❌ 低  | ❌ 高   | ✅ 低    | 不推荐       |
| Cookie Only                 | ⚠️ 中  | ✅ 无   | ❌ 高    | 静态网站     |
| **Cookie + sessionStorage** | ✅ 高  | ⚠️ 中   | ✅ 低    | **推荐方案** |

### 2. 安全存储实现

#### TokenStorage类设计

```typescript
/**
 * 安全的Token存储管理类
 * 采用Cookie + sessionStorage双重安全策略
 */
export class TokenStorage {
  private static readonly ACCESS_TOKEN_KEY = 'auth_token';
  private static readonly REFRESH_TOKEN_KEY = 'refresh_token';

  /**
   * 存储访问令牌和刷新令牌
   * - Access Token: 存储在Cookie中，HttpOnly + Secure + SameSite
   * - Refresh Token: 存储在sessionStorage中，自动清理
   */
  public static setTokens(accessToken: string, refreshToken?: string): void {
    // Access Token存储在Cookie中
    document.cookie = `${this.ACCESS_TOKEN_KEY}=${accessToken}; path=/; SameSite=Lax; Secure=${location.protocol === 'https:'}`;

    // Refresh Token存储在sessionStorage中
    if (refreshToken) {
      sessionStorage.setItem(this.REFRESH_TOKEN_KEY, refreshToken);
    }
  }

  /**
   * 清理所有认证信息
   */
  public static clearTokens(): void {
    // 清理Cookie
    document.cookie = `${this.ACCESS_TOKEN_KEY}=; path=/; expires=Thu, 01 Jan 1970 00:00:00 GMT`;

    // 清理sessionStorage
    sessionStorage.removeItem(this.REFRESH_TOKEN_KEY);
  }
}
```

### 3. 安全防护机制

#### XSS防护

- ✅ Access Token存储在Cookie中，减少XSS攻击面
- ✅ 使用CSP (Content Security Policy) 限制脚本执行
- ✅ 输入验证和输出编码

#### CSRF防护

- ✅ 使用SameSite=Lax Cookie属性
- ✅ 实施CSRF Token验证
- ✅ Origin检查

#### 其他安全措施

- ✅ Token过期自动清理
- ✅ 安全的Logout处理
- ✅ 会话超时管理

## 配置使用指南

### 1. 前端组件中使用

```typescript
// useAuth.ts
import { OAuthConfig } from '@repo/lib';

export function useAuth() {
  const initiateLogin = async () => {
    // 使用统一配置获取授权URL
    const authUrl = new URL(OAuthConfig.getAuthorizeUrl());
    const clientConfig = OAuthConfig.getClientConfig();

    // 设置OAuth参数
    authUrl.searchParams.set('client_id', clientConfig.clientId);
    authUrl.searchParams.set('redirect_uri', clientConfig.redirectUri);
    // ... 其他参数设置

    window.location.href = authUrl.toString();
  };
}
```

### 2. API路由中使用

```typescript
// auth/callback/page.tsx
import { OAuthConfig } from '@repo/lib';

async function exchangeCodeForToken(code: string, codeVerifier: string) {
  const clientConfig = OAuthConfig.getClientConfig();

  const response = await fetch(OAuthConfig.getTokenUrl(), {
    method: 'POST',
    headers: {
      'Content-Type': 'application/x-www-form-urlencoded',
      Authorization: `Basic ${btoa(`${clientConfig.clientId}:${clientConfig.clientSecret}`)}`,
    },
    body: new URLSearchParams({
      grant_type: 'authorization_code',
      code,
      redirect_uri: clientConfig.redirectUri,
      client_id: clientConfig.clientId,
      code_verifier: codeVerifier,
    }),
  });
}
```

### 3. 测试环境配置

```typescript
// tests/helpers/global-setup.ts
import { OAuthConfig } from '@repo/lib';

async function checkServices() {
  const oauthServiceUrl = OAuthConfig.getBaseUrl();
  const adminPortalUrl = process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3002';

  const services = [
    { name: 'oauth-service', url: `${oauthServiceUrl}/api/v2/.well-known/openid-configuration` },
    { name: 'admin-portal', url: `${adminPortalUrl}/api/menu` },
  ];

  // 服务健康检查逻辑...
}
```

## 配置迁移指南

### 1. 迁移前状态

- ❌ 硬编码的OAuth服务URL
- ❌ 分散的客户端配置信息
- ❌ 不安全的localStorage Token存储
- ❌ 重复的配置定义

### 2. 迁移后状态

- ✅ 统一的OAuthConfig配置类
- ✅ 环境变量支持的灵活配置
- ✅ 安全的Cookie + sessionStorage存储
- ✅ 类型安全的配置访问

### 3. 迁移步骤

1. **配置类集成**: 在所有需要OAuth配置的文件中导入OAuthConfig
2. **硬编码替换**: 将所有硬编码的URL和配置替换为配置类调用
3. **Token存储升级**: 迁移所有localStorage Token存储为安全存储
4. **环境变量配置**: 在各环境中配置相应的环境变量
5. **测试验证**: 确保所有功能在新配置下正常工作

## 最佳实践

### 1. 配置管理

- ✅ 使用统一的配置类而非分散配置
- ✅ 通过环境变量实现不同环境的配置
- ✅ 提供合理的默认值减少配置复杂度
- ✅ 使用TypeScript类型确保配置正确性

### 2. 安全实践

- ✅ 敏感信息（如客户端密钥）不暴露到前端
- ✅ 使用安全的Token存储策略
- ✅ 实施适当的XSS和CSRF防护
- ✅ 定期轮换密钥和凭据

### 3. 开发体验

- ✅ 提供清晰的配置文档和示例
- ✅ 在开发环境提供友好的错误提示
- ✅ 支持热重载的配置更新
- ✅ 提供配置验证工具

## 总结

通过实施统一配置管理方案，我们实现了：

1. **安全性提升**: 消除了不安全的Token存储，实施了多层安全防护
2. **可维护性提升**: 统一配置管理，消除硬编码，便于维护和更新
3. **灵活性提升**: 支持环境变量配置，适应不同部署环境
4. **开发效率提升**: 类型安全的配置访问，减少配置错误

这个配置管理方案为整个OAuth2.1认证授权中心提供了坚实的配置基础，确保了系统的安全性、可维护性和可扩展性。
