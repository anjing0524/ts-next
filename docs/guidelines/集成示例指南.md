# 集成示例指南

> **文档版本**: v1.0.0  
> **最后更新**: 2025-07-22  
> **维护团队**: 开发团队

## 概述

本文档提供了各种应用场景下集成 OAuth 2.1 认证中心的实际代码示例，帮助开发者快速实现认证功能。

## 准备工作

### 1. 注册 OAuth 客户端

首先需要在管理后台注册你的应用：

```bash
# 登录管理后台
curl -X POST http://localhost:3002/api/v2/auth/login \
  -H "Content-Type: application/json" \
  -d '{
    "username": "admin",
    "password": "SecurePass123!"
  }'
```

### 2. 创建客户端

```bash
# 创建新的 OAuth 客户端
curl -X POST http://localhost:3002/api/v2/clients \
  -H "Authorization: Bearer <your_access_token>" \
  -H "Content-Type: application/json" \
  -d '{
    "clientName": "我的应用",
    "clientType": "CONFIDENTIAL",
    "redirectUris": ["http://localhost:8080/callback"],
    "allowedScopes": ["openid", "profile", "email"],
    "grantTypes": ["authorization_code", "refresh_token"]
  }'
```

### 3. 保存客户端信息

成功注册后，保存返回的 `clientId` 和 `clientSecret`，这些信息将在后续集成中使用。

## Web 应用集成示例

### React 应用

#### 1. 安装依赖

```bash
npm install axios react-router-dom
```

#### 2. 创建认证配置

```typescript
// src/config/auth.ts
export const authConfig = {
  clientId: 'your_client_id',
  clientSecret: 'your_client_secret',
  authority: 'http://localhost:3001',
  redirectUri: 'http://localhost:3000/callback',
  scopes: ['openid', 'profile', 'email']
}

// PKCE 工具函数
export function generateCodeVerifier(): string {
  const array = new Uint8Array(32)
  crypto.getRandomValues(array)
  return Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('')
}

export async function generateCodeChallenge(verifier: string): Promise<string> {
  const encoder = new TextEncoder()
  const data = encoder.encode(verifier)
  const digest = await crypto.subtle.digest('SHA-256', data)
  return btoa(String.fromCharCode(...new Uint8Array(digest)))
    .replace(/\+/g, '-')
    .replace(/\//g, '_')
    .replace(/=/g, '')
}
```

#### 3. 创建认证 Hook

```typescript
// src/hooks/useAuth.ts
import { useState, useEffect } from 'react'
import { authConfig, generateCodeVerifier, generateCodeChallenge } from '../config/auth'

interface User {
  sub: string
  name: string
  email: string
  roles: string[]
  permissions: string[]
}

interface AuthContextType {
  user: User | null
  login: () => void
  logout: () => void
  isAuthenticated: boolean
}

export function useAuth(): AuthContextType {
  const [user, setUser] = useState<User | null>(null)
  
  useEffect(() => {
    // 检查本地存储中的令牌
    const accessToken = localStorage.getItem('access_token')
    if (accessToken) {
      // 解析 JWT 获取用户信息
      const payload = JSON.parse(atob(accessToken.split('.')[1]))
      setUser(payload.user)
    }
  }, [])

  const login = async () => {
    // 生成 PKCE 验证器
    const codeVerifier = generateCodeVerifier()
    const codeChallenge = await generateCodeChallenge(codeVerifier)
    
    // 保存验证器用于后续验证
    sessionStorage.setItem('code_verifier', codeVerifier)
    
    // 构建授权 URL
    const params = new URLSearchParams({
      response_type: 'code',
      client_id: authConfig.clientId,
      redirect_uri: authConfig.redirectUri,
      scope: authConfig.scopes.join(' '),
      state: Math.random().toString(36).substring(7),
      code_challenge: codeChallenge,
      code_challenge_method: 'S256'
    })
    
    // 重定向到授权端点
    window.location.href = `${authConfig.authority}/api/v2/oauth/authorize?${params}`
  }

  const logout = () => {
    localStorage.removeItem('access_token')
    localStorage.removeItem('refresh_token')
    setUser(null)
    window.location.href = '/'
  }

  return {
    user,
    login,
    logout,
    isAuthenticated: !!user
  }
}
```

#### 4. 创建回调页面组件

```typescript
// src/pages/Callback.tsx
import { useEffect, useState } from 'react'
import { useNavigate } from 'react-router-dom'
import { authConfig } from '../config/auth'

export default function Callback() {
  const [error, setError] = useState<string | null>(null)
  const navigate = useNavigate()

  useEffect(() => {
    const handleCallback = async () => {
      // 从 URL 获取授权码
      const urlParams = new URLSearchParams(window.location.search)
      const code = urlParams.get('code')
      const error = urlParams.get('error')
      
      if (error) {
        setError(`授权失败: ${error}`)
        return
      }
      
      if (!code) {
        setError('未收到授权码')
        return
      }
      
      try {
        // 获取保存的 code_verifier
        const codeVerifier = sessionStorage.getItem('code_verifier')
        if (!codeVerifier) {
          throw new Error('找不到 PKCE 验证器')
        }
        
        // 交换访问令牌
        const response = await fetch(`${authConfig.authority}/api/v2/oauth/token`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
          },
          body: new URLSearchParams({
            grant_type: 'authorization_code',
            client_id: authConfig.clientId,
            client_secret: authConfig.clientSecret,
            code: code,
            redirect_uri: authConfig.redirectUri,
            code_verifier: codeVerifier
          })
        })
        
        const tokenResponse = await response.json()
        
        if (!response.ok) {
          throw new Error(tokenResponse.error_description || '令牌交换失败')
        }
        
        // 保存令牌
        localStorage.setItem('access_token', tokenResponse.access_token)
        localStorage.setItem('refresh_token', tokenResponse.refresh_token)
        
        // 清理 sessionStorage
        sessionStorage.removeItem('code_verifier')
        
        // 重定向到首页
        navigate('/')
      } catch (err) {
        setError(err instanceof Error ? err.message : '未知错误')
      }
    }
    
    handleCallback()
  }, [navigate])

  if (error) {
    return (
      <div className="error-container">
        <h2>认证失败</h2>
        <p>{error}</p>
        <button onClick={() => window.location.href = '/'}>
          返回首页
        </button>
      </div>
    )
  }

  return <div>正在处理认证回调...</div>
}
```

#### 5. 创建受保护的路由组件

```typescript
// src/components/ProtectedRoute.tsx
import { useAuth } from '../hooks/useAuth'

interface ProtectedRouteProps {
  children: React.ReactNode
  requiredPermissions?: string[]
}

export function ProtectedRoute({ children, requiredPermissions }: ProtectedRouteProps) {
  const { isAuthenticated, user, login } = useAuth()
  
  useEffect(() => {
    if (!isAuthenticated) {
      login()
    }
  }, [isAuthenticated, login])
  
  if (!isAuthenticated) {
    return <div>正在跳转到登录页...</div>
  }
  
  // 检查权限
  if (requiredPermissions && user) {
    const hasPermission = requiredPermissions.every(permission => 
      user.permissions.includes(permission)
    )
    
    if (!hasPermission) {
      return <div>权限不足</div>
    }
  }
  
  return <>{children}</>
}
```

### Vue 3 应用

#### 1. 安装依赖

```bash
npm install axios vue-router@4 pinia
```

#### 2. 创建认证 Store

```typescript
// src/stores/auth.ts
import { defineStore } from 'pinia'
import { ref } from 'vue'

interface User {
  sub: string
  name: string
  email: string
  roles: string[]
  permissions: string[]
}

export const useAuthStore = defineStore('auth', () => {
  const user = ref<User | null>(null)
  const accessToken = ref<string | null>(null)
  const refreshToken = ref<string | null>(null)
  
  function setTokens(access: string, refresh: string) {
    accessToken.value = access
    refreshToken.value = refresh
    localStorage.setItem('access_token', access)
    localStorage.setItem('refresh_token', refresh)
    
    // 解析用户信息
    const payload = JSON.parse(atob(access.split('.')[1]))
    user.value = payload.user
  }
  
  function clearAuth() {
    user.value = null
    accessToken.value = null
    refreshToken.value = null
    localStorage.removeItem('access_token')
    localStorage.removeItem('refresh_token')
  }
  
  async function refreshAccessToken() {
    if (!refreshToken.value) {
      throw new Error('No refresh token available')
    }
    
    const response = await fetch('http://localhost:3001/api/v2/oauth/token', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
      },
      body: new URLSearchParams({
        grant_type: 'refresh_token',
        client_id: 'your_client_id',
        client_secret: 'your_client_secret',
        refresh_token: refreshToken.value
      })
    })
    
    const data = await response.json()
    
    if (!response.ok) {
      clearAuth()
      throw new Error('Token refresh failed')
    }
    
    setTokens(data.access_token, data.refresh_token)
  }
  
  return {
    user,
    accessToken,
    refreshToken,
    setTokens,
    clearAuth,
    refreshAccessToken
  }
})
```

#### 3. 创建 Axios 拦截器

```typescript
// src/utils/http.ts
import axios from 'axios'
import { useAuthStore } from '../stores/auth'

const http = axios.create({
  baseURL: 'http://localhost:3001/api/v2',
})

// 请求拦截器
http.interceptors.request.use(
  async (config) => {
    const authStore = useAuthStore()
    
    if (authStore.accessToken) {
      config.headers.Authorization = `Bearer ${authStore.accessToken}`
    }
    
    return config
  },
  (error) => {
    return Promise.reject(error)
  }
)

// 响应拦截器
http.interceptors.response.use(
  (response) => response,
  async (error) => {
    const authStore = useAuthStore()
    const originalRequest = error.config
    
    // 如果是 401 错误且未重试过
    if (error.response?.status === 401 && !originalRequest._retry) {
      originalRequest._retry = true
      
      try {
        // 尝试刷新令牌
        await authStore.refreshAccessToken()
        
        // 重试原始请求
        originalRequest.headers.Authorization = `Bearer ${authStore.accessToken}`
        return http(originalRequest)
      } catch (refreshError) {
        // 刷新失败，跳转到登录页
        authStore.clearAuth()
        window.location.href = '/login'
        return Promise.reject(refreshError)
      }
    }
    
    return Promise.reject(error)
  }
)

export default http
```

## 移动应用集成示例

### React Native 应用

#### 1. 安装依赖

```bash
npm install axios react-native-webview @react-native-async-storage/async-storage
```

#### 2. 创建认证服务

```typescript
// src/services/auth.ts
import AsyncStorage from '@react-native-async-storage/async-storage'
import axios from 'axios'

const authConfig = {
  clientId: 'your_mobile_client_id',
  clientSecret: 'your_mobile_client_secret',
  authority: 'http://localhost:3001',
  redirectUri: 'com.yourapp://callback'
}

export class AuthService {
  private static instance: AuthService
  
  private constructor() {}
  
  static getInstance(): AuthService {
    if (!AuthService.instance) {
      AuthService.instance = new AuthService()
    }
    return AuthService.instance
  }
  
  async login(): Promise<void> {
    const codeVerifier = this.generateRandomString(128)
    const codeChallenge = await this.generateCodeChallenge(codeVerifier)
    
    // 保存 code_verifier
    await AsyncStorage.setItem('code_verifier', codeVerifier)
    
    const authUrl = `${authConfig.authority}/api/v2/oauth/authorize?${new URLSearchParams({
      response_type: 'code',
      client_id: authConfig.clientId,
      redirect_uri: authConfig.redirectUri,
      scope: 'openid profile email',
      state: this.generateRandomString(32),
      code_challenge: codeChallenge,
      code_challenge_method: 'S256'
    })}`
    
    // 在移动应用中打开 WebView 或系统浏览器
    // 这里需要根据具体平台实现
    return Promise.resolve()
  }
  
  async handleCallback(url: string): Promise<void> {
    const urlObj = new URL(url)
    const code = urlObj.searchParams.get('code')
    const error = urlObj.searchParams.get('error')
    
    if (error) {
      throw new Error(`Authentication error: ${error}`)
    }
    
    if (!code) {
      throw new Error('No authorization code received')
    }
    
    const codeVerifier = await AsyncStorage.getItem('code_verifier')
    if (!codeVerifier) {
      throw new Error('No code verifier found')
    }
    
    const response = await axios.post(`${authConfig.authority}/api/v2/oauth/token`, {
      grant_type: 'authorization_code',
      client_id: authConfig.clientId,
      client_secret: authConfig.clientSecret,
      code: code,
      redirect_uri: authConfig.redirectUri,
      code_verifier: codeVerifier
    })
    
    const { access_token, refresh_token } = response.data
    
    // 保存令牌
    await AsyncStorage.setItem('access_token', access_token)
    await AsyncStorage.setItem('refresh_token', refresh_token)
    
    // 清理 code_verifier
    await AsyncStorage.removeItem('code_verifier')
  }
  
  async getAccessToken(): Promise<string | null> {
    return AsyncStorage.getItem('access_token')
  }
  
  async logout(): Promise<void> {
    await AsyncStorage.removeItem('access_token')
    await AsyncStorage.removeItem('refresh_token')
  }
  
  private generateRandomString(length: number): string {
    const array = new Uint8Array(length)
    crypto.getRandomValues(array)
    return Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('')
  }
  
  private async generateCodeChallenge(verifier: string): Promise<string> {
    const encoder = new TextEncoder()
    const data = encoder.encode(verifier)
    const digest = await crypto.subtle.digest('SHA-256', data)
    return btoa(String.fromCharCode(...new Uint8Array(digest)))
      .replace(/\+/g, '-')
      .replace(/\//g, '_')
      .replace(/=/g, '')
  }
}
```

## 后端服务集成示例

### Node.js 服务集成

#### 1. 安装依赖

```bash
npm install axios jsonwebtoken jwks-rsa
```

#### 2. 创建认证中间件

```typescript
// src/middleware/auth.ts
import axios from 'axios'
import jwt from 'jsonwebtoken'
import jwksClient from 'jwks-rsa'

const jwksClientInstance = jwksClient({
  jwksUri: 'http://localhost:3001/.well-known/jwks.json'
})

interface JwtPayload {
  sub: string
  aud: string
  exp: number
  iat: number
  permissions: string[]
  user: {
    id: string
    username: string
    roles: string[]
  }
}

export function authenticateToken(req: any, res: any, next: any) {
  const authHeader = req.headers['authorization']
  const token = authHeader && authHeader.split(' ')[1]
  
  if (!token) {
    return res.status(401).json({ error: 'Access token required' })
  }
  
  jwt.verify(token, getKey, (err: any, payload: any) => {
    if (err) {
      return res.status(403).json({ error: 'Invalid token' })
    }
    
    req.user = payload.user
    req.permissions = payload.permissions
    next()
  })
}

function getKey(header: any, callback: any) {
  jwksClientInstance.getSigningKey(header.kid, (err, key) => {
    if (err) {
      return callback(err)
    }
    const signingKey = key?.getPublicKey()
    callback(null, signingKey)
  })
}

export function requirePermissions(requiredPermissions: string[]) {
  return (req: any, res: any, next: any) => {
    const userPermissions = req.permissions || []
    
    const hasAllPermissions = requiredPermissions.every(permission =>
      userPermissions.includes(permission)
    )
    
    if (!hasAllPermissions) {
      return res.status(403).json({ error: 'Insufficient permissions' })
    }
    
    next()
  }
}
```

#### 3. 使用中间件

```typescript
// src/routes/users.ts
import express from 'express'
import { authenticateToken, requirePermissions } from '../middleware/auth'

const router = express.Router()

// 获取用户列表
router.get(
  '/users',
  authenticateToken,
  requirePermissions(['user:list']),
  async (req, res) => {
    try {
      // 调用 OAuth 服务获取用户列表
      const response = await axios.get('http://localhost:3001/api/v2/users', {
        headers: {
          'Authorization': req.headers['authorization']
        }
      })
      
      res.json(response.data)
    } catch (error) {
      res.status(500).json({ error: 'Failed to fetch users' })
    }
  }
)

export default router
```

### Spring Boot 集成

#### 1. 添加依赖

```xml
<!-- pom.xml -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-oauth2-resource-server</artifactId>
</dependency>
<dependency>
    <groupId>com.nimbusds</groupId>
    <artifactId>nimbus-jose-jwt</artifactId>
</dependency>
```

#### 2. 配置 Spring Security

```java
// src/main/java/com/example/config/SecurityConfig.java
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    
    @Value("${oauth.authority:http://localhost:3001}")
    private String authority;
    
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(authz -> authz
                .requestMatchers("/public/**").permitAll()
                .requestMatchers("/api/admin/**").hasAuthority("ROLE_ADMIN")
                .anyRequest().authenticated()
            )
            .oauth2ResourceServer(oauth2 -> oauth2
                .jwt(jwt -> jwt
                    .jwkSetUri(authority + "/.well-known/jwks.json")
                    .jwtDecoderCustomizer(jwtDecoderCustomizer())
                )
            );
        
        return http.build();
    }
    
    private Consumer<JwtDecoderFactory<SecurityContextHolder>> jwtDecoderCustomizer() {
        return factory -> {
            // 自定义 JWT 解析逻辑
            factory.setJwtGrantedAuthoritiesConverter(jwt -> {
                List<GrantedAuthority> authorities = new ArrayList<>();
                
                // 添加角色
                if (jwt.getClaim("user") != null) {
                    Map<String, Object> user = jwt.getClaim("user");
                    List<String> roles = (List<String>) user.get("roles");
                    if (roles != null) {
                        roles.forEach(role -> 
                            authorities.add(new SimpleGrantedAuthority("ROLE_" + role))
                        );
                    }
                }
                
                // 添加权限
                List<String> permissions = jwt.getClaim("permissions");
                if (permissions != null) {
                    permissions.forEach(permission ->
                        authorities.add(new SimpleGrantedAuthority(permission))
                    );
                }
                
                return authorities;
            });
        };
    }
}
```

## 测试工具

### Postman 集成

1. **获取访问令牌**

```http
POST /api/v2/oauth/token
Content-Type: application/x-www-form-urlencoded

grant_type=password&
client_id=your_client_id&
client_secret=your_client_secret&
username=admin&
password=SecurePass123!
```

2. **使用令牌访问 API**

```http
GET /api/v2/users
Authorization: Bearer <your_access_token>
```

### cURL 示例

```bash
# 1. 获取访问令牌
TOKEN_RESPONSE=$(curl -s -X POST http://localhost:3001/api/v2/oauth/token \
  -H "Content-Type: application/x-www-form-urlencoded" \
  -d "grant_type=password&client_id=your_client_id&client_secret=your_client_secret&username=admin&password=SecurePass123!")

# 2. 提取访问令牌
ACCESS_TOKEN=$(echo $TOKEN_RESPONSE | jq -r '.access_token')

# 3. 使用令牌访问 API
curl -X GET http://localhost:3001/api/v2/users \
  -H "Authorization: Bearer $ACCESS_TOKEN"
```

## 最佳实践

1. **安全存储**
   - 客户端密钥必须安全存储，不要暴露在前端代码中
   - 使用 HTTPS 进行所有通信
   - 令牌存储在 HttpOnly cookies 或安全的地方

2. **令牌管理**
   - 实现令牌自动刷新机制
   - 在令牌过期时优雅地处理
   - 提供登出功能清除令牌

3. **错误处理**
   - 处理网络错误和认证失败
   - 提供清晰的用户反馈
   - 实现重试机制

4. **性能优化**
   - 缓存 JWKS 公钥
   - 实现请求节流
   - 使用连接池