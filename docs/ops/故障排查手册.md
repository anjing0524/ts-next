# 故障排查手册

**文档版本**: v1.0  
**创建日期**: 2025-07-22
**最后更新**: 2025-07-22  
**作者**: 运维团队  
**状态**: 初版 - 基础故障排查

## 概述

本手册提供了基于 Turborepo 的 OAuth2.1 认证授权中心和微服务平台的故障排查指南，包括常见问题的诊断步骤和解决方案。

## 故障分类

### 1. 网络和连接问题

#### 1.1 Pingora Proxy 无法访问

**症状**:

- 浏览器显示连接超时
- curl 请求失败
- 502/503 错误

**诊断步骤**:

```bash
# 1. 检查 Pingora Proxy 进程状态
ps aux | grep pingora

# 2. 检查端口监听
lsof -i :8080
netstat -tlnp | grep 8080

# 3. 检查配置文件
cd apps/pingora-proxy
cargo run -- --config config/default.yaml --validate

# 4. 查看日志
tail -f /var/log/pingora-proxy.log
# 或者如果使用 Docker
docker logs pingora-proxy
```

**解决方案**:

```bash
# 重启 Pingora Proxy
cd apps/pingora-proxy
cargo run -- --config config/default.yaml

# 或者 Docker 环境
docker restart pingora-proxy

# 检查防火墙设置
sudo ufw status
sudo ufw allow 8080
```

#### 1.2 上游服务连接失败

**症状**:

- 502 Bad Gateway
- 504 Gateway Timeout
- 健康检查失败

**诊断步骤**:

```bash
# 1. 检查上游服务状态
curl http://localhost:3000/health
curl http://localhost:3001/health

# 2. 检查服务进程
ps aux | grep node
docker ps

# 3. 检查 Pingora 配置
cat apps/pingora-proxy/config/default.yaml

# 4. 测试网络连通性
telnet localhost 3000
telnet localhost 3001
```

**解决方案**:

```bash
# 重启相关服务
pnpm dev  # 开发环境
# 或
docker-compose restart oauth-service admin-portal  # 生产环境

# 更新 Pingora 配置
# 编辑 apps/pingora-proxy/config/default.yaml
# 重新加载配置
kill -HUP $(pgrep pingora)
```

### 2. 认证和授权问题

#### 2.1 OAuth2.1 认证失败

**症状**:

- 登录页面无法访问
- 401 Unauthorized 错误
- JWT 令牌验证失败

**诊断步骤**:

```bash
# 1. 检查 OAuth 服务状态
curl http://localhost:3000/api/health

# 2. 检查数据库连接
pnpm db:studio
# 或直接连接数据库
psql -h localhost -U user -d oauth_db

# 3. 检查环境变量
echo $JWT_SECRET
echo $DATABASE_URL

# 4. 查看应用日志
tail -f apps/oauth-service/logs/app.log
# 或 Docker
docker logs oauth-service
```

**解决方案**:

```bash
# 1. 重置 JWT 密钥
export JWT_SECRET="new-super-secret-jwt-key"

# 2. 重启 OAuth 服务
cd apps/oauth-service
pnpm dev
# 或
docker restart oauth-service

# 3. 清理过期令牌
psql -h localhost -U user -d oauth_db -c "DELETE FROM oauth_tokens WHERE expires_at < NOW();"
```

#### 2.2 权限验证错误

**症状**:

- 403 Forbidden 错误
- 用户角色权限不正确
- API 访问被拒绝

**诊断步骤**:

```sql
-- 检查用户权限
SELECT u.email, r.name as role, p.name as permission
FROM users u
JOIN user_roles ur ON u.id = ur.user_id
JOIN roles r ON ur.role_id = r.id
JOIN role_permissions rp ON r.id = rp.role_id
JOIN permissions p ON rp.permission_id = p.id
WHERE u.email = 'user@example.com';

-- 检查客户端权限
SELECT * FROM oauth_clients WHERE client_id = 'your-client-id';
```

**解决方案**:

```sql
-- 更新用户角色
UPDATE user_roles SET role_id = 1 WHERE user_id = (SELECT id FROM users WHERE email = 'user@example.com');

-- 重新分配权限
INSERT INTO role_permissions (role_id, permission_id) VALUES (1, 2);
```

### 3. 数据库问题

#### 3.1 数据库连接失败

**症状**:

- 应用启动失败
- 数据库连接超时
- "too many connections" 错误

**诊断步骤**:

```bash
# 1. 检查 SQLite 数据库文件
# 确保 'packages/database/prisma/dev.db' 文件存在且有读写权限
ls -l packages/database/prisma/dev.db

# 2. 测试数据库连接
psql -h localhost -U user -d oauth_db

# 3. 检查连接数
psql -h localhost -U user -d oauth_db -c "SELECT count(*) FROM pg_stat_activity;"

# 4. 检查数据库配置
psql -h localhost -U user -d oauth_db -c "SHOW max_connections;"
```

**解决方案**:

```bash
# 1. 重启 PostgreSQL
sudo systemctl restart postgresql
# 或 Docker
docker restart postgres

# 2. 增加最大连接数
sudo -u postgres psql -c "ALTER SYSTEM SET max_connections = 200;"
sudo systemctl restart postgresql

# 3. 清理空闲连接
psql -h localhost -U user -d oauth_db -c "SELECT pg_terminate_backend(pid) FROM pg_stat_activity WHERE state = 'idle' AND state_change < now() - interval '5 minutes';"
```

#### 3.2 数据库性能问题

**症状**:

- 查询响应缓慢
- 高 CPU 使用率
- 锁等待超时

**诊断步骤**:

```sql
-- 查看慢查询
SELECT query, mean_exec_time, calls
FROM pg_stat_statements
ORDER BY mean_exec_time DESC
LIMIT 10;

-- 查看锁等待
SELECT * FROM pg_locks WHERE NOT granted;

-- 查看活跃连接
SELECT pid, usename, application_name, state, query
FROM pg_stat_activity
WHERE state = 'active';
```

**解决方案**:

```sql
-- 创建缺失的索引
CREATE INDEX CONCURRENTLY idx_users_email ON users(email);
CREATE INDEX CONCURRENTLY idx_oauth_tokens_expires_at ON oauth_tokens(expires_at);

-- 更新表统计信息
ANALYZE;

-- 清理过期数据
DELETE FROM oauth_tokens WHERE expires_at < NOW() - INTERVAL '1 day';
DELETE FROM audit_logs WHERE created_at < NOW() - INTERVAL '30 days';
```

### 4. 应用程序问题

#### 4.1 Next.js 应用启动失败

**症状**:

- 应用无法启动
- 编译错误
- 运行时错误

**诊断步骤**:

```bash
# 1. 检查 Node.js 版本
node --version
npm --version
pnpm --version

# 2. 检查依赖安装
pnpm install

# 3. 检查环境变量
cat .env.local

# 4. 查看构建日志
pnpm build
```

**解决方案**:

```bash
# 1. 清理缓存和重新安装
rm -rf node_modules
rm -rf .next
pnpm install

# 2. 更新依赖
pnpm update

# 3. 检查 TypeScript 错误
pnpm type-check

# 4. 重新构建
pnpm build
pnpm start
```

#### 4.2 内存泄漏问题

**症状**:

- 内存使用持续增长
- 应用响应变慢
- OOM (Out of Memory) 错误

**诊断步骤**:

```bash
# 1. 监控内存使用
top -p $(pgrep node)
htop

# 2. 生成堆转储
node --inspect apps/oauth-service/dist/index.js
# 在 Chrome DevTools 中生成 heap snapshot

# 3. 检查进程状态
ps aux | grep node

# 4. 监控 Docker 容器资源
docker stats
```

**解决方案**:

```bash
# 1. 增加 Node.js 内存限制
export NODE_OPTIONS="--max-old-space-size=4096"

# 2. 重启应用
pnpm dev
# 或
docker restart oauth-service admin-portal

# 3. 优化代码（移除内存泄漏）
# 检查未清理的定时器、事件监听器等
```

### 5. 监控和日志问题

#### 5.1 Prometheus 指标缺失

**症状**:

- Grafana 面板显示 "No data"
- Prometheus targets 显示 down
- 指标端点无法访问

**诊断步骤**:

```bash
# 1. 检查 Prometheus 服务
curl http://localhost:9090/targets

# 2. 检查应用指标端点
curl http://localhost:8080/metrics  # Pingora Proxy
curl http://localhost:3000/api/metrics  # OAuth Service

# 3. 检查 Prometheus 配置
cat monitoring/prometheus.yml

# 4. 查看 Prometheus 日志
docker logs prometheus
```

**解决方案**:

```bash
# 1. 重启 Prometheus
docker restart prometheus

# 2. 更新配置并重新加载
# 编辑 monitoring/prometheus.yml
curl -X POST http://localhost:9090/-/reload

# 3. 检查网络连接
docker network ls
docker network inspect oauth-platform_default
```

#### 5.2 日志丢失或格式错误

**症状**:

- 日志文件为空
- 日志格式不正确
- 无法找到错误信息

**诊断步骤**:

```bash
# 1. 检查日志文件权限
ls -la /var/log/oauth-platform/

# 2. 检查日志配置
cat apps/oauth-service/src/utils/logger.ts

# 3. 检查磁盘空间
df -h

# 4. 查看系统日志
journalctl -u oauth-platform
```

**解决方案**:

```bash
# 1. 修复日志文件权限
sudo chown -R app:app /var/log/oauth-platform/
sudo chmod 755 /var/log/oauth-platform/

# 2. 清理旧日志文件
sudo logrotate -f /etc/logrotate.d/oauth-platform

# 3. 重启应用以重新初始化日志
sudo systemctl restart oauth-platform
```

## 性能调优

### 1. Pingora Proxy 优化

```yaml
# config/production.yaml
server:
  worker_threads: 8 # 根据 CPU 核心数调整
  max_connections: 10000
  keepalive_timeout: 60
  tcp_nodelay: true

upstreams:
  - name: 'oauth-service'
    servers:
      - '127.0.0.1:3000'
    health_check:
      interval: 10
      timeout: 5
      retries: 3
    load_balancing:
      algorithm: 'least_connections'
      max_fails: 3
      fail_timeout: 30
    connection_pool:
      max_idle: 100
      idle_timeout: 300
```

### 2. 数据库优化

```sql
-- PostgreSQL 配置优化
ALTER SYSTEM SET shared_buffers = '256MB';
ALTER SYSTEM SET effective_cache_size = '1GB';
ALTER SYSTEM SET work_mem = '4MB';
ALTER SYSTEM SET maintenance_work_mem = '64MB';
ALTER SYSTEM SET checkpoint_completion_target = 0.9;
ALTER SYSTEM SET wal_buffers = '16MB';
ALTER SYSTEM SET default_statistics_target = 100;

-- 重启 PostgreSQL 使配置生效
-- sudo systemctl restart postgresql
```

### 3. Node.js 应用优化

```bash
# 环境变量优化
export NODE_ENV=production
export NODE_OPTIONS="--max-old-space-size=4096 --optimize-for-size"
export UV_THREADPOOL_SIZE=16

# PM2 集群模式
npm install -g pm2
pm2 start ecosystem.config.js
```

## 应急响应流程

### 1. 服务完全不可用

**立即响应** (5分钟内):

1. 确认故障范围
2. 启动应急预案
3. 通知相关人员

**快速恢复** (15分钟内):

1. 切换到备用服务
2. 回滚到上一个稳定版本
3. 临时修复关键问题

**根本解决** (1小时内):

1. 分析根本原因
2. 实施永久修复
3. 验证系统稳定性

### 2. 性能严重下降

**监控检查**:

```bash
# 系统资源监控
top
iostat 1
netstat -i

# 应用性能监控
curl http://localhost:9090/api/v1/query?query=up
curl http://localhost:8080/metrics | grep pingora_request_duration
```

**快速优化**:

```bash
# 增加资源限制
docker update --memory=2g --cpus=2 oauth-service

# 清理缓存
redis-cli FLUSHALL

# 重启负载较高的服务
docker restart oauth-service
```

### 6. OAuth 2.1 特定问题

#### 6.1 PKCE 验证失败

**症状**:

- 授权流程返回 "invalid_code_challenge" 错误
- code_challenge 和 code_verifier 不匹配

**诊断步骤**:

```bash
# 1. 检查授权请求参数
curl "http://localhost:3001/api/v2/oauth/authorize?response_type=code&client_id=test&redirect_uri=http%3A%2F%2Flocalhost%3A8080%2Fcallback&scope=openid&state=abc123&code_challenge=test_challenge&code_challenge_method=S256"

# 2. 验证 PKCE 实现
# 在客户端代码中检查 code_challenge 生成
echo "test_verifier" | openssl dgst -sha256 -binary | openssl base64 -A
# 应该是: test_challenge

# 3. 检查 OAuth 服务日志
docker logs oauth-service | grep PKCE
```

**解决方案**:

```javascript
// 客户端正确实现 PKCE
async function generatePKCE() {
  const verifier = generateRandomString(128);
  const challenge = await base64URL(crypto.subtle.digest('SHA-256', verifier));
  return { verifier, challenge };
}

function base64URL(buffer) {
  return btoa(String.fromCharCode(...new Uint8Array(buffer)))
    .replace(/\+/g, '-')
    .replace(/\//g, '_')
    .replace(/=/g, '');
}
```

#### 6.2 JWT 令牌问题

##### 6.2.1 令牌签名验证失败

**症状**:

- API 返回 401 Unauthorized
- JWT 验证错误 "invalid signature"

**诊断步骤**:

```bash
# 1. 检查 JWKS 端点
curl http://localhost:3001/.well-known/jwks.json

# 2. 验证 JWT 结构
# 获取 token
TOKEN="your.jwt.token"
echo $TOKEN | cut -d '.' -f 1 | base64 -d  # Header
echo $TOKEN | cut -d '.' -f 2 | base64 -d  # Payload

# 3. 使用 jwt.io 在线验证
# 将 token 粘贴到 https://jwt.io
```

**解决方案**:

```bash
# 1. 清理本地缓存的 JWKS
# 客户端重新获取公钥

# 2. 重启 OAuth 服务强制刷新密钥
docker restart oauth-service

# 3. 验证密钥轮换配置
curl http://localhost:3001/.well-known/jwks.json | jq '.keys[0].kid'
```

##### 6.2.2 令牌过期问题

**症状**:

- 频繁要求重新登录
- access_token 很快失效

**诊断步骤**:

```bash
# 1. 检查 token 中的过期时间
echo $TOKEN | cut -d '.' -f 2 | base64 -d | jq '.exp'

# 2. 检查服务器时间
date
# 与 token 中的 exp 时间对比

# 3. 验证 token 生命周期配置
curl http://localhost:3001/api/v2/oauth/token \
  -d "grant_type=client_credentials&client_id=test&client_secret=test" | jq '.expires_in'
```

**解决方案**:

```bash
# 1. 实现自动 token 刷新
# 在客户端代码中

async function refreshToken() {
  const response = await fetch('/api/v2/oauth/token', {
    method: 'POST',
    body: new URLSearchParams({
      grant_type: 'refresh_token',
      client_id: 'your_client_id',
      client_secret: 'your_client_secret',
      refresh_token: getStoredRefreshToken()
    })
  });
  
  const tokens = await response.json();
  storeTokens(tokens.access_token, tokens.refresh_token);
}

# 2. 调整 token 有效期（如果需要）
# 修改 OAuth 服务配置
```

#### 6.3 重定向 URI 问题

**症状**:

- "redirect_uri_mismatch" 错误
- OAuth 流程中断

**诊断步骤**:

```sql
-- 检查注册的 redirect_uri
SELECT client_id, redirect_uris FROM oauth_clients WHERE client_id = 'your_client_id';

-- 检查请求中的 URI
-- 查看浏览器地址栏或网络请求
```

**解决方案**:

```sql
-- 更新客户端的 redirect_uri
UPDATE oauth_clients 
SET redirect_uris = '["http://localhost:3000/callback", "https://yourdomain.com/callback"]'
WHERE client_id = 'your_client_id';
```

### 7. 前端集成问题

#### 7.1 CORS 错误

**症状**:

- 浏览器控制台显示 CORS 错误
- 请求被跨域策略阻止

**诊断步骤**:

```bash
# 1. 检查响应头
curl -I http://localhost:3001/api/v2/oauth/token \
  -H "Origin: http://localhost:3000"

# 2. 检查 OAuth 服务 CORS 配置
# 查看 apps/oauth-service/src/middleware.ts
```

**解决方案**:

```typescript
// 在 Next.js API 路由中添加 CORS
import { NextResponse } from 'next/server';

export function middleware(request) {
  const response = NextResponse.next();
  
  response.headers.set('Access-Control-Allow-Origin', 'http://localhost:3000');
  response.headers.set('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
  response.headers.set('Access-Control-Allow-Headers', 'Content-Type, Authorization');
  
  if (request.method === 'OPTIONS') {
    return new Response(null, { status: 200, headers: response.headers });
  }
  
  return response;
}
```

#### 7.2 路由问题

**症状**:

- OAuth 回调后页面空白
- 路由跳转失败

**诊断步骤**:

```bash
# 1. 检查浏览器网络请求
# 打开开发者工具 > Network 标签

# 2. 检查路由配置
# 查看 apps/admin-portal/src/app 目录结构

# 3. 检查重定向配置
cat apps/admin-portal/src/app/(auth)/callback/page.tsx
```

**解决方案**:

```typescript
// 正确处理 OAuth 回调
export default function CallbackPage() {
  useEffect(() => {
    const urlParams = new URLSearchParams(window.location.search);
    const code = urlParams.get('code');
    const error = urlParams.get('error');
    
    if (error) {
      // 处理错误
      window.location.href = '/auth/error?error=' + error;
      return;
    }
    
    if (code) {
      // 交换 token
      exchangeCodeForToken(code);
    }
  }, []);
  
  return <div>Processing login...</div>;
}
```

## 联系信息

### 紧急联系人

**一级响应** (24/7):

- 运维值班: +86-xxx-xxxx-xxxx
- 邮箱: ops-emergency@company.com

**二级支持** (工作时间):

- 系统架构师: architect@company.com
- 开发负责人: dev-lead@company.com
- 数据库管理员: dba@company.com

### 升级流程

1. **L1 运维团队** - 基础故障排查 (0-30分钟)
2. **L2 开发团队** - 应用层问题 (30分钟-2小时)
3. **L3 架构团队** - 系统架构问题 (2小时+)

### 文档更新

本手册应根据实际故障案例持续更新，每月进行一次全面审查。

**更新流程**:

1. 收集故障案例
2. 分析根本原因
3. 更新排查步骤
4. 验证解决方案
5. 发布更新版本
