# 画布层模型

> 最新更新：2025-08-19

## 概述

K线图渲染系统采用分层画布（Canvas Layer）架构，使用 WebAssembly 与 OffscreenCanvas 进行高性能图形渲染。通过三个独立的画布层实现不同类型内容的分离渲染，提高刷新效率并减少重绘开销。

## 三层架构设计

### Base 层（基础层）
- **用途**：静态或低频更新的背景元素
- **内容**：网格线、固定背景、坐标轴刻度
- **更新频率**：配置变更、布局变更时更新
- **清理策略**：完全清理整个画布区域

### Main 层（主要层）
- **用途**：数据驱动的核心图表内容
- **内容**：K线图、热图、成交量柱状图、价格线
- **更新频率**：数据更新、缩放、滚动时更新
- **清理策略**：完全清理整个画布区域

### Overlay 层（交互层）
- **用途**：用户交互相关的动态元素
- **内容**：十字光标、工具提示、数据缩放导航器
- **更新频率**：鼠标移动、交互状态变化时更新
- **清理策略**：**特殊处理** - 仅清理导航器上方区域，保护导航器内容避免重影

## 渲染器实现规范

### RenderStrategy 接口约定

所有渲染器需实现 `RenderStrategy` trait：

```rust
pub trait RenderStrategy {
    /// 执行渲染
    fn render(&self, ctx: &RenderContext) -> Result<(), RenderError>;
    
    /// 指定所属画布层
    fn get_layer_type(&self) -> CanvasLayerType;
    
    /// 检查是否支持指定渲染模式
    fn supports_mode(&self, mode: RenderMode) -> bool;
}
```

### 清理责任分工

#### ChartRenderer（统一协调器）
- 负责层级清理的统一调度
- 使用 `Root` 面板矩形进行全画布清理
- 对于 Base 和 Main 层执行完全清理
- 对于 Overlay 层委托给专门的 OverlayRenderer

#### OverlayRenderer（交互层专用）
```rust
// 特殊清理逻辑：仅清理导航器上方区域
let root_rect = layout.get_rect(&PaneId::Root);
let nav_rect = layout.get_rect(&PaneId::NavigatorContainer);
overlay_ctx.clear_rect(root_rect.x, root_rect.y, root_rect.width, nav_rect.y);
```

#### 其他渲染器
- BookRenderer、HeatRenderer、VolumeRenderer 等
- 专注于自身内容绘制，不负责清理逻辑
- 清理由 ChartRenderer 统一处理

## 访问者模式与策略工厂

> 本节定义 RenderStrategyFactory 的访问者 API 语义，并给出测试约定（适用于 wasm-bindgen-test 环境）。

### 数据结构与构造
- 工厂内部维护 `HashMap<StrategyType, Vec<RefCell<Box<dyn RenderStrategy>>>>`，支持同类型多实例与内部可变性。
- 构造函数：
  - `new()`：包含系统默认策略，适用于真实渲染流程；
  - `new_empty()`：不包含任何默认策略（测试友好），便于仅验证自定义策略的遍历顺序与过滤逻辑。

### 访问者 API 语义
- `visit_strategies(mode, visitor)`：
  - 先筛选 `supports_mode(mode) == true` 的策略；
  - 再按 `get_priority()` 升序排序（数值越小优先级越高）；
  - 依次回调 `visitor(&dyn RenderStrategy)`；
  - 访问者返回 `ControlFlow::Break(())` 时立即终止遍历，返回 `Break(())`；否则遍历完成返回 `Continue(())`。
- `visit_strategies_by_layer(mode, layer, visitor)`：
  - 先按 `supports_mode(mode)` 过滤，再按 `get_layer_type() == layer` 过滤；
  - 再按 `get_priority()` 升序排序；
  - 依次回调访问者，遵循与上文相同的提前终止语义。
- `visit_strategies_mut(mode, visitor)`：
  - 语义同 `visit_strategies`，但向访问者提供 `&mut dyn RenderStrategy`，用于事件处理等需要可变访问的场景。

### 稳定性与排序
- 目前实现基于 `sort_by_key`，对相同优先级不保证稳定顺序；若需要稳定顺序，应在策略注册阶段控制 `get_priority()` 的唯一性或后续改为稳定排序策略。

### 测试约定（wasm-bindgen-test）
- 所有 wasm 测试使用 `#[wasm_bindgen_test]` 宏，并通过 `wasm_bindgen_test_configure!(run_in_browser);` 在浏览器环境执行。
- 使用 `RenderStrategyFactory::new_empty()` 构造测试工厂，避免默认策略干扰断言。
- 自定义测试策略的 `supports_mode` 应严格匹配传入模式，以验证模式过滤行为；
- 典型用例：
  - 模式过滤仅遍历匹配模式的策略；
  - 图层过滤仅遍历指定 `CanvasLayerType`；
  - 优先级排序按数值升序；
  - 访问者可通过 `Break(())` 提前终止。

> 最近更新：2025-08-19

## 性能优化策略

### 脏标记机制
- 每层独立维护脏标记（dirty flag）
- 只有标记为脏的层才会重新渲染
- 避免不必要的全量重绘

### 清理优化
- **分层清理**：避免清理不需要更新的层
- **区域清理**：Overlay 层仅清理必要区域
- **批量操作**：同一帧内多个渲染操作合并执行

### 内存管理
- 使用 `Rc<RefCell<T>>` 共享状态管理
- 避免不必要的数据克隆
- 及时释放不再使用的资源

## 扩展指南

### 新增渲染器步骤

1. **实现 RenderStrategy trait**
   ```rust
   impl RenderStrategy for YourRenderer {
       fn render(&self, ctx: &RenderContext) -> Result<(), RenderError> {
           // 实现具体渲染逻辑
       }
       
       fn get_layer_type(&self) -> CanvasLayerType {
           // 返回所属层级
       }
   }
   ```

2. **注册到 RenderStrategyFactory**
   ```rust
   // 在 strategy_factory.rs 中添加
   factory.register_renderer(Box::new(YourRenderer::new()));
   ```

3. **遵循清理规范**
   - 不要在渲染器内部执行清理操作
   - 依赖 ChartRenderer 的统一清理机制
   - 特殊需求时与 Overlay 层清理策略保持一致

### 调试建议

- 使用浏览器开发者工具监控 Canvas 性能
- 通过 `console.log` 跟踪层级更新频率
- 检查是否存在不必要的全层重绘
- 验证清理逻辑是否按预期工作

## 最佳实践

1. **职责分离**：不同类型内容严格分层
2. **最小化重绘**：只更新变化的层级
3. **统一清理**：避免渲染器间清理逻辑冲突
4. **性能监控**：定期检查渲染性能指标
5. **错误处理**：妥善处理 Canvas 上下文获取失败等异常情况