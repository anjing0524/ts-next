# OAuth2.1认证授权中心系统监控数据上报设计

> **文档版本**: v2.0.0  
> **创建日期**: 2024-01-20  
> **最后更新**: 2024-01-20  
> **文档状态**: 正式版  
> **维护团队**: 运维团队

## 文档摘要

本文档详细描述了OAuth2.1认证授权中心的系统监控数据上报设计，包括监控指标定义、数据收集策略、上报机制、告警配置等。确保系统运行状态的全面监控和及时响应。

## 目录

- [1. 监控数据上报概述](#1-监控数据上报概述)
  - [1.1 上报目标](#11-上报目标)
  - [1.2 上报架构](#12-上报架构)
- [2. 监控指标体系](#2-监控指标体系)
- [3. 数据收集策略](#3-数据收集策略)
- [4. 上报机制设计](#4-上报机制设计)
- [5. 告警配置](#5-告警配置)
- [6. 可视化展示](#6-可视化展示)
- [7. 性能优化](#7-性能优化)
- [8. 运维管理](#8-运维管理)

## 1. 监控数据上报概述

### 1.1 上报目标

OAuth2.1认证授权中心的监控数据上报系统旨在：

- **实时性能监控**：实时收集和上报系统性能指标
- **业务指标追踪**：监控认证授权相关的业务指标
- **异常告警**：及时发现和上报系统异常
- **合规审计**：为安全审计提供数据支持
- **容量规划**：为系统扩容提供数据依据

### 1.2 上报架构

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   应用层监控     │    │   中间件监控     │    │   基础设施监控   │
│                │    │                │    │                │
│ • API响应时间   │    │ • 数据库性能     │    │ • 服务器资源     │
│ • 业务指标      │    │ • 缓存命中率     │    │ • 网络状态      │
│ • 错误率        │    │ • 消息队列      │    │ • 存储使用      │
└─────────────────┘    └─────────────────┘    └─────────────────┘
         │                       │                       │
         └───────────────────────┼───────────────────────┘
                                │
                    ┌─────────────────┐
                    │   数据收集器     │
                    │                │
                    │ • 指标聚合      │
                    │ • 数据清洗      │
                    │ • 格式转换      │
                    └─────────────────┘
                                │
                    ┌─────────────────┐
                    │   上报引擎      │
                    │                │
                    │ • 批量上报      │
                    │ • 失败重试      │
                    │ • 数据压缩      │
                    └─────────────────┘
                                │
        ┌───────────────────────┼───────────────────────┐
        │                       │                       │
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│ Prometheus  │    │   自定义     │    │   日志系统   │
│   监控      │    │  监控平台    │    │            │
└─────────────┘    └─────────────┘    └─────────────┘
```

## 2. 数据收集机制

### 2.1 应用层数据收集

#### 2.1.1 API性能指标收集

```typescript
// API性能监控中间件
export class ApiMetricsMiddleware {
  constructor(
    private metricsCollector: MetricsCollector,
    private config: MonitoringConfig
  ) {}

  middleware() {
    return (req: Request, res: Response, next: NextFunction) => {
      const startTime = Date.now();
      const originalSend = res.send;

      // 重写response.send方法以捕获响应时间
      res.send = function(data) {
        const responseTime = Date.now() - startTime;
        
        // 收集API指标
        this.metricsCollector.collectApiMetrics({
          endpoint: req.path,
          method: req.method,
          statusCode: res.statusCode,
          responseTime,
          timestamp: new Date(),
          userId: req.user?.id,
          clientId: req.client?.id,
          userAgent: req.get('User-Agent'),
          ip: req.ip
        });

        return originalSend.call(this, data);
      }.bind(this);

      next();
    };
  }
}

// 使用示例
app.use(new ApiMetricsMiddleware(metricsCollector, config).middleware());
```

#### 2.1.2 业务指标收集

```typescript
// 业务事件收集器
export class BusinessMetricsCollector {
  constructor(private metricsCollector: MetricsCollector) {}

  // 登录事件
  recordLoginAttempt(userId: string, success: boolean, reason?: string) {
    this.metricsCollector.collectBusinessEvent('login_attempt', {
      userId,
      success,
      reason,
      timestamp: new Date()
    });
  }

  // OAuth授权事件
  recordOAuthAuthorization(clientId: string, userId: string, scopes: string[]) {
    this.metricsCollector.collectBusinessEvent('oauth_authorization', {
      clientId,
      userId,
      scopes,
      timestamp: new Date()
    });
  }

  // 令牌颁发事件
  recordTokenIssuance(tokenType: string, clientId: string, userId?: string) {
    this.metricsCollector.collectBusinessEvent('token_issuance', {
      tokenType,
      clientId,
      userId,
      timestamp: new Date()
    });
  }

  // 权限检查事件
  recordPermissionCheck(userId: string, permission: string, granted: boolean) {
    this.metricsCollector.collectBusinessEvent('permission_check', {
      userId,
      permission,
      granted,
      timestamp: new Date()
    });
  }
}
```

### 2.2 中间件层数据收集

#### 2.2.1 数据库性能监控

```typescript
// 数据库监控插件
export class DatabaseMetricsPlugin {
  constructor(private metricsCollector: MetricsCollector) {}

  // Prisma中间件
  prismaMiddleware(): Prisma.Middleware {
    return async (params, next) => {
      const startTime = Date.now();
      
      try {
        const result = await next(params);
        const executionTime = Date.now() - startTime;
        
        // 收集数据库指标
        this.metricsCollector.collectDatabaseMetrics({
          model: params.model,
          action: params.action,
          executionTime,
          success: true,
          timestamp: new Date()
        });
        
        return result;
      } catch (error) {
        const executionTime = Date.now() - startTime;
        
        this.metricsCollector.collectDatabaseMetrics({
          model: params.model,
          action: params.action,
          executionTime,
          success: false,
          error: error.message,
          timestamp: new Date()
        });
        
        throw error;
      }
    };
  }
}

// 使用示例
const prisma = new PrismaClient();
prisma.$use(new DatabaseMetricsPlugin(metricsCollector).prismaMiddleware());
```

#### 2.2.2 缓存性能监控

```typescript
// Redis缓存监控
export class CacheMetricsCollector {
  constructor(
    private redis: Redis,
    private metricsCollector: MetricsCollector
  ) {
    this.setupRedisMonitoring();
  }

  private setupRedisMonitoring() {
    // 监控Redis命令
    this.redis.on('connect', () => {
      this.metricsCollector.collectCacheEvent('redis_connect', {
        timestamp: new Date()
      });
    });

    this.redis.on('error', (error) => {
      this.metricsCollector.collectCacheEvent('redis_error', {
        error: error.message,
        timestamp: new Date()
      });
    });
  }

  // 包装Redis操作以收集指标
  async get(key: string): Promise<string | null> {
    const startTime = Date.now();
    
    try {
      const result = await this.redis.get(key);
      const executionTime = Date.now() - startTime;
      
      this.metricsCollector.collectCacheMetrics({
        operation: 'get',
        key,
        hit: result !== null,
        executionTime,
        timestamp: new Date()
      });
      
      return result;
    } catch (error) {
      const executionTime = Date.now() - startTime;
      
      this.metricsCollector.collectCacheMetrics({
        operation: 'get',
        key,
        hit: false,
        executionTime,
        error: error.message,
        timestamp: new Date()
      });
      
      throw error;
    }
  }
}
```

### 2.3 系统资源监控

#### 2.3.1 系统资源收集器

```typescript
// 系统资源监控
export class SystemResourceCollector {
  constructor(
    private metricsCollector: MetricsCollector,
    private interval: number = 30000 // 30秒
  ) {
    this.startCollection();
  }

  private startCollection() {
    setInterval(async () => {
      await this.collectSystemMetrics();
    }, this.interval);
  }

  private async collectSystemMetrics() {
    try {
      const metrics = {
        // CPU使用率
        cpuUsage: await this.getCpuUsage(),
        
        // 内存使用情况
        memoryUsage: process.memoryUsage(),
        
        // 磁盘使用情况
        diskUsage: await this.getDiskUsage(),
        
        // 网络IO
        networkIO: await this.getNetworkIO(),
        
        // 进程信息
        processInfo: {
          pid: process.pid,
          uptime: process.uptime(),
          version: process.version
        },
        
        timestamp: new Date()
      };

      this.metricsCollector.collectSystemMetrics(metrics);
    } catch (error) {
      console.error('Failed to collect system metrics:', error);
    }
  }

  private async getCpuUsage(): Promise<number> {
    return new Promise((resolve) => {
      const startUsage = process.cpuUsage();
      
      setTimeout(() => {
        const endUsage = process.cpuUsage(startUsage);
        const totalUsage = endUsage.user + endUsage.system;
        const percentage = (totalUsage / 1000000) / 1 * 100; // 转换为百分比
        resolve(percentage);
      }, 1000);
    });
  }

  private async getDiskUsage(): Promise<any> {
    // 使用node.js的fs模块获取磁盘使用情况
    const fs = require('fs').promises;
    try {
      const stats = await fs.statfs('.');
      return {
        total: stats.bavail * stats.bsize,
        free: stats.bfree * stats.bsize,
        used: (stats.bavail - stats.bfree) * stats.bsize
      };
    } catch (error) {
      return null;
    }
  }

  private async getNetworkIO(): Promise<any> {
    // 网络IO监控实现
    return {
      bytesReceived: 0,
      bytesSent: 0
    };
  }
}
```

## 3. 数据聚合与处理

### 3.1 指标聚合器

```typescript
// 指标聚合器
export class MetricsAggregator {
  private buffer: Map<string, any[]> = new Map();
  private aggregationInterval: number = 60000; // 1分钟

  constructor(private config: AggregationConfig) {
    this.startAggregation();
  }

  // 添加原始指标数据
  addMetric(type: string, data: any) {
    if (!this.buffer.has(type)) {
      this.buffer.set(type, []);
    }
    this.buffer.get(type)!.push(data);
  }

  private startAggregation() {
    setInterval(() => {
      this.processBuffer();
    }, this.aggregationInterval);
  }

  private processBuffer() {
    for (const [type, data] of this.buffer.entries()) {
      if (data.length === 0) continue;

      const aggregated = this.aggregateData(type, data);
      this.sendAggregatedData(type, aggregated);
      
      // 清空缓冲区
      this.buffer.set(type, []);
    }
  }

  private aggregateData(type: string, data: any[]): any {
    switch (type) {
      case 'api_performance':
        return this.aggregateApiPerformance(data);
      case 'business_events':
        return this.aggregateBusinessEvents(data);
      case 'system_metrics':
        return this.aggregateSystemMetrics(data);
      default:
        return data;
    }
  }

  private aggregateApiPerformance(data: any[]): any {
    const grouped = this.groupBy(data, (item) => `${item.method}:${item.endpoint}`);
    
    return Object.entries(grouped).map(([key, items]) => {
      const responseTimes = items.map(item => item.responseTime);
      const [method, endpoint] = key.split(':');
      
      return {
        method,
        endpoint,
        requestCount: items.length,
        averageResponseTime: this.average(responseTimes),
        minResponseTime: Math.min(...responseTimes),
        maxResponseTime: Math.max(...responseTimes),
        p95ResponseTime: this.percentile(responseTimes, 95),
        p99ResponseTime: this.percentile(responseTimes, 99),
        errorCount: items.filter(item => item.statusCode >= 400).length,
        timestamp: new Date()
      };
    });
  }

  private aggregateBusinessEvents(data: any[]): any {
    const grouped = this.groupBy(data, (item) => item.type);
    
    return Object.entries(grouped).map(([eventType, events]) => ({
      eventType,
      count: events.length,
      details: this.summarizeEvents(eventType, events),
      timestamp: new Date()
    }));
  }

  private aggregateSystemMetrics(data: any[]): any {
    if (data.length === 0) return null;
    
    const latest = data[data.length - 1];
    const cpuUsages = data.map(item => item.cpuUsage).filter(Boolean);
    const memoryUsages = data.map(item => item.memoryUsage.heapUsed).filter(Boolean);
    
    return {
      cpuUsage: {
        current: latest.cpuUsage,
        average: this.average(cpuUsages),
        max: Math.max(...cpuUsages)
      },
      memoryUsage: {
        current: latest.memoryUsage,
        average: this.average(memoryUsages),
        max: Math.max(...memoryUsages)
      },
      processInfo: latest.processInfo,
      timestamp: new Date()
    };
  }

  private groupBy<T>(array: T[], keyFn: (item: T) => string): Record<string, T[]> {
    return array.reduce((groups, item) => {
      const key = keyFn(item);
      if (!groups[key]) groups[key] = [];
      groups[key].push(item);
      return groups;
    }, {} as Record<string, T[]>);
  }

  private average(numbers: number[]): number {
    return numbers.length > 0 ? numbers.reduce((a, b) => a + b, 0) / numbers.length : 0;
  }

  private percentile(numbers: number[], p: number): number {
    const sorted = numbers.sort((a, b) => a - b);
    const index = Math.ceil((p / 100) * sorted.length) - 1;
    return sorted[index] || 0;
  }

  private summarizeEvents(eventType: string, events: any[]): any {
    switch (eventType) {
      case 'login_attempt':
        return {
          total: events.length,
          successful: events.filter(e => e.success).length,
          failed: events.filter(e => !e.success).length
        };
      case 'oauth_authorization':
        return {
          total: events.length,
          uniqueClients: new Set(events.map(e => e.clientId)).size,
          uniqueUsers: new Set(events.map(e => e.userId)).size
        };
      default:
        return { total: events.length };
    }
  }

  private sendAggregatedData(type: string, data: any) {
    // 发送聚合后的数据到上报引擎
    // 这里会调用上报引擎的方法
  }
}
```

## 4. 数据上报引擎

### 4.1 上报引擎核心

```typescript
// 数据上报引擎
export class MetricsReportingEngine {
  private reportQueue: any[] = [];
  private isReporting: boolean = false;
  private adapters: Map<string, MonitoringAdapter> = new Map();

  constructor(private config: ReportingConfig) {
    this.initializeAdapters();
    this.startReporting();
  }

  private initializeAdapters() {
    // 初始化Prometheus适配器
    if (this.config.prometheus?.enabled) {
      this.adapters.set('prometheus', new PrometheusAdapter(this.config.prometheus));
    }

    // 初始化自定义监控适配器
    if (this.config.custom?.enabled) {
      this.adapters.set('custom', new CustomMonitoringAdapter(this.config.custom));
    }

    // 初始化日志适配器
    if (this.config.logging?.enabled) {
      this.adapters.set('logging', new LoggingAdapter(this.config.logging));
    }
  }

  // 添加待上报数据
  addReport(type: string, data: any) {
    this.reportQueue.push({
      type,
      data,
      timestamp: new Date(),
      retryCount: 0
    });
  }

  private startReporting() {
    setInterval(async () => {
      if (!this.isReporting && this.reportQueue.length > 0) {
        await this.processReportQueue();
      }
    }, this.config.reportingInterval || 30000); // 默认30秒
  }

  private async processReportQueue() {
    this.isReporting = true;
    
    try {
      const batch = this.reportQueue.splice(0, this.config.batchSize || 100);
      
      // 并行发送到所有适配器
      const promises = Array.from(this.adapters.entries()).map(([name, adapter]) => 
        this.sendToAdapter(name, adapter, batch)
      );
      
      await Promise.allSettled(promises);
    } catch (error) {
      console.error('Error processing report queue:', error);
    } finally {
      this.isReporting = false;
    }
  }

  private async sendToAdapter(name: string, adapter: MonitoringAdapter, batch: any[]) {
    try {
      await adapter.sendMetrics(batch);
      console.log(`Successfully sent ${batch.length} metrics to ${name}`);
    } catch (error) {
      console.error(`Failed to send metrics to ${name}:`, error);
      
      // 重试逻辑
      const failedItems = batch.filter(item => item.retryCount < this.config.maxRetries);
      failedItems.forEach(item => {
        item.retryCount++;
        this.reportQueue.push(item);
      });
    }
  }
}
```

### 4.2 监控适配器实现

#### 4.2.1 Prometheus适配器

```typescript
// Prometheus适配器
export class PrometheusAdapter implements MonitoringAdapter {
  private gateway: Pushgateway;
  private registry: Registry;

  constructor(private config: PrometheusConfig) {
    this.registry = new Registry();
    this.gateway = new Pushgateway(config.gatewayUrl, [], this.registry);
    this.initializeMetrics();
  }

  private initializeMetrics() {
    // API响应时间直方图
    const apiResponseTime = new Histogram({
      name: 'oauth_api_response_time_seconds',
      help: 'API response time in seconds',
      labelNames: ['method', 'endpoint', 'status_code'],
      buckets: [0.1, 0.5, 1, 2, 5, 10]
    });
    this.registry.registerMetric(apiResponseTime);

    // 业务指标计数器
    const businessEvents = new Counter({
      name: 'oauth_business_events_total',
      help: 'Total number of business events',
      labelNames: ['event_type', 'status']
    });
    this.registry.registerMetric(businessEvents);

    // 系统资源使用率
    const systemResources = new Gauge({
      name: 'oauth_system_resources',
      help: 'System resource usage',
      labelNames: ['resource_type']
    });
    this.registry.registerMetric(systemResources);
  }

  async sendMetrics(batch: any[]): Promise<void> {
    try {
      // 转换数据格式并更新指标
      for (const item of batch) {
        this.updateMetrics(item);
      }

      // 推送到Prometheus Gateway
      await this.gateway.pushAdd({ jobName: 'oauth-auth-center' });
    } catch (error) {
      throw new Error(`Prometheus adapter error: ${error.message}`);
    }
  }

  private updateMetrics(item: any) {
    switch (item.type) {
      case 'api_performance':
        this.updateApiMetrics(item.data);
        break;
      case 'business_events':
        this.updateBusinessMetrics(item.data);
        break;
      case 'system_metrics':
        this.updateSystemMetrics(item.data);
        break;
    }
  }

  private updateApiMetrics(data: any[]) {
    const histogram = this.registry.getSingleMetric('oauth_api_response_time_seconds') as Histogram<string>;
    
    data.forEach(metric => {
      histogram.observe(
        {
          method: metric.method,
          endpoint: metric.endpoint,
          status_code: metric.statusCode?.toString() || 'unknown'
        },
        metric.averageResponseTime / 1000 // 转换为秒
      );
    });
  }

  private updateBusinessMetrics(data: any[]) {
    const counter = this.registry.getSingleMetric('oauth_business_events_total') as Counter<string>;
    
    data.forEach(event => {
      counter.inc({
        event_type: event.eventType,
        status: 'success'
      }, event.count);
    });
  }

  private updateSystemMetrics(data: any) {
    const gauge = this.registry.getSingleMetric('oauth_system_resources') as Gauge<string>;
    
    if (data.cpuUsage) {
      gauge.set({ resource_type: 'cpu' }, data.cpuUsage.current);
    }
    
    if (data.memoryUsage) {
      gauge.set({ resource_type: 'memory' }, data.memoryUsage.current.heapUsed);
    }
  }
}
```

#### 4.2.2 自定义监控适配器

```typescript
// 自定义监控平台适配器
export class CustomMonitoringAdapter implements MonitoringAdapter {
  private httpClient: AxiosInstance;

  constructor(private config: CustomMonitoringConfig) {
    this.httpClient = axios.create({
      baseURL: config.endpoint,
      timeout: config.timeout || 10000,
      headers: {
        'Authorization': `Bearer ${config.apiKey}`,
        'Content-Type': 'application/json'
      }
    });
  }

  async sendMetrics(batch: any[]): Promise<void> {
    try {
      const payload = {
        source: 'oauth-auth-center',
        timestamp: new Date().toISOString(),
        metrics: this.transformMetrics(batch)
      };

      await this.httpClient.post('/metrics', payload);
    } catch (error) {
      throw new Error(`Custom monitoring adapter error: ${error.message}`);
    }
  }

  private transformMetrics(batch: any[]): any[] {
    return batch.map(item => ({
      type: item.type,
      timestamp: item.timestamp,
      data: this.normalizeData(item.data)
    }));
  }

  private normalizeData(data: any): any {
    // 标准化数据格式
    if (Array.isArray(data)) {
      return data.map(item => this.flattenObject(item));
    }
    return this.flattenObject(data);
  }

  private flattenObject(obj: any, prefix: string = ''): any {
    const flattened: any = {};
    
    for (const key in obj) {
      if (obj.hasOwnProperty(key)) {
        const newKey = prefix ? `${prefix}.${key}` : key;
        
        if (typeof obj[key] === 'object' && obj[key] !== null && !Array.isArray(obj[key])) {
          Object.assign(flattened, this.flattenObject(obj[key], newKey));
        } else {
          flattened[newKey] = obj[key];
        }
      }
    }
    
    return flattened;
  }
}
```

#### 4.2.3 日志适配器

```typescript
// 日志适配器
export class LoggingAdapter implements MonitoringAdapter {
  private logger: winston.Logger;

  constructor(private config: LoggingConfig) {
    this.logger = winston.createLogger({
      level: config.level || 'info',
      format: winston.format.combine(
        winston.format.timestamp(),
        winston.format.json()
      ),
      transports: [
        new winston.transports.File({ 
          filename: config.filename || 'metrics.log',
          maxsize: config.maxSize || 10485760, // 10MB
          maxFiles: config.maxFiles || 5
        })
      ]
    });
  }

  async sendMetrics(batch: any[]): Promise<void> {
    try {
      for (const item of batch) {
        this.logger.info('metrics', {
          type: item.type,
          timestamp: item.timestamp,
          data: item.data
        });
      }
    } catch (error) {
      throw new Error(`Logging adapter error: ${error.message}`);
    }
  }
}
```

## 5. 配置管理

### 5.1 监控配置

```typescript
// 监控配置接口
export interface MonitoringConfiguration {
  // 数据收集配置
  collection: {
    enabled: boolean;
    apiMetrics: boolean;
    businessMetrics: boolean;
    systemMetrics: boolean;
    interval: number; // 收集间隔（毫秒）
  };

  // 数据聚合配置
  aggregation: {
    enabled: boolean;
    interval: number; // 聚合间隔（毫秒）
    bufferSize: number; // 缓冲区大小
  };

  // 上报配置
  reporting: {
    enabled: boolean;
    interval: number; // 上报间隔（毫秒）
    batchSize: number; // 批量大小
    maxRetries: number; // 最大重试次数
  };

  // 适配器配置
  adapters: {
    prometheus?: PrometheusConfig;
    custom?: CustomMonitoringConfig;
    logging?: LoggingConfig;
  };

  // 告警配置
  alerting: {
    enabled: boolean;
    thresholds: {
      apiResponseTime: number; // API响应时间阈值（毫秒）
      errorRate: number; // 错误率阈值（百分比）
      cpuUsage: number; // CPU使用率阈值（百分比）
      memoryUsage: number; // 内存使用率阈值（百分比）
    };
  };
}

// 默认配置
export const defaultMonitoringConfig: MonitoringConfiguration = {
  collection: {
    enabled: true,
    apiMetrics: true,
    businessMetrics: true,
    systemMetrics: true,
    interval: 30000 // 30秒
  },
  aggregation: {
    enabled: true,
    interval: 60000, // 1分钟
    bufferSize: 1000
  },
  reporting: {
    enabled: true,
    interval: 30000, // 30秒
    batchSize: 100,
    maxRetries: 3
  },
  adapters: {
    logging: {
      enabled: true,
      level: 'info',
      filename: 'logs/metrics.log',
      maxSize: 10485760, // 10MB
      maxFiles: 5
    }
  },
  alerting: {
    enabled: true,
    thresholds: {
      apiResponseTime: 2000, // 2秒
      errorRate: 5, // 5%
      cpuUsage: 80, // 80%
      memoryUsage: 85 // 85%
    }
  }
};
```

### 5.2 环境配置

```typescript
// 环境特定配置
export class MonitoringConfigManager {
  private config: MonitoringConfiguration;

  constructor() {
    this.config = this.loadConfiguration();
  }

  private loadConfiguration(): MonitoringConfiguration {
    const env = process.env.NODE_ENV || 'development';
    
    switch (env) {
      case 'production':
        return this.getProductionConfig();
      case 'staging':
        return this.getStagingConfig();
      case 'development':
      default:
        return this.getDevelopmentConfig();
    }
  }

  private getProductionConfig(): MonitoringConfiguration {
    return {
      ...defaultMonitoringConfig,
      collection: {
        ...defaultMonitoringConfig.collection,
        interval: 15000 // 更频繁的收集
      },
      reporting: {
        ...defaultMonitoringConfig.reporting,
        interval: 15000 // 更频繁的上报
      },
      adapters: {
        prometheus: {
          enabled: true,
          gatewayUrl: process.env.PROMETHEUS_GATEWAY_URL!,
          timeout: 5000
        },
        custom: {
          enabled: true,
          endpoint: process.env.CUSTOM_MONITORING_ENDPOINT!,
          apiKey: process.env.CUSTOM_MONITORING_API_KEY!,
          timeout: 10000
        },
        logging: {
          enabled: true,
          level: 'warn',
          filename: '/var/log/oauth-metrics.log',
          maxSize: 52428800, // 50MB
          maxFiles: 10
        }
      }
    };
  }

  private getStagingConfig(): MonitoringConfiguration {
    return {
      ...defaultMonitoringConfig,
      adapters: {
        prometheus: {
          enabled: true,
          gatewayUrl: process.env.PROMETHEUS_GATEWAY_URL!,
          timeout: 5000
        },
        logging: {
          enabled: true,
          level: 'info',
          filename: 'logs/staging-metrics.log',
          maxSize: 20971520, // 20MB
          maxFiles: 5
        }
      }
    };
  }

  private getDevelopmentConfig(): MonitoringConfiguration {
    return {
      ...defaultMonitoringConfig,
      collection: {
        ...defaultMonitoringConfig.collection,
        interval: 60000 // 较少的收集频率
      },
      adapters: {
        logging: {
          enabled: true,
          level: 'debug',
          filename: 'logs/dev-metrics.log',
          maxSize: 5242880, // 5MB
          maxFiles: 3
        }
      }
    };
  }

  getConfig(): MonitoringConfiguration {
    return this.config;
  }

  updateConfig(updates: Partial<MonitoringConfiguration>): void {
    this.config = { ...this.config, ...updates };
  }
}
```

## 6. 告警机制

### 6.1 告警规则引擎

```typescript
// 告警规则引擎
export class AlertingEngine {
  private rules: AlertRule[] = [];
  private alertHandlers: AlertHandler[] = [];

  constructor(private config: AlertingConfig) {
    this.initializeRules();
    this.initializeHandlers();
  }

  private initializeRules() {
    // API响应时间告警
    this.rules.push({
      id: 'api-response-time',
      name: 'API响应时间过长',
      condition: (data: any) => {
        return data.type === 'api_performance' && 
               data.data.some((metric: any) => metric.averageResponseTime > this.config.thresholds.apiResponseTime);
      },
      severity: 'warning',
      message: (data: any) => {
        const slowApis = data.data.filter((metric: any) => metric.averageResponseTime > this.config.thresholds.apiResponseTime);
        return `API响应时间过长: ${slowApis.map((api: any) => `${api.method} ${api.endpoint}: ${api.averageResponseTime}ms`).join(', ')}`;
      }
    });

    // 错误率告警
    this.rules.push({
      id: 'api-error-rate',
      name: 'API错误率过高',
      condition: (data: any) => {
        return data.type === 'api_performance' && 
               data.data.some((metric: any) => {
                 const errorRate = (metric.errorCount / metric.requestCount) * 100;
                 return errorRate > this.config.thresholds.errorRate;
               });
      },
      severity: 'critical',
      message: (data: any) => {
        const highErrorApis = data.data.filter((metric: any) => {
          const errorRate = (metric.errorCount / metric.requestCount) * 100;
          return errorRate > this.config.thresholds.errorRate;
        });
        return `API错误率过高: ${highErrorApis.map((api: any) => {
          const errorRate = (api.errorCount / api.requestCount) * 100;
          return `${api.method} ${api.endpoint}: ${errorRate.toFixed(2)}%`;
        }).join(', ')}`;
      }
    });

    // 系统资源告警
    this.rules.push({
      id: 'system-resources',
      name: '系统资源使用率过高',
      condition: (data: any) => {
        return data.type === 'system_metrics' && (
          data.data.cpuUsage?.current > this.config.thresholds.cpuUsage ||
          (data.data.memoryUsage?.current.heapUsed / data.data.memoryUsage?.current.heapTotal * 100) > this.config.thresholds.memoryUsage
        );
      },
      severity: 'warning',
      message: (data: any) => {
        const messages = [];
        if (data.data.cpuUsage?.current > this.config.thresholds.cpuUsage) {
          messages.push(`CPU使用率: ${data.data.cpuUsage.current.toFixed(2)}%`);
        }
        const memoryUsage = (data.data.memoryUsage?.current.heapUsed / data.data.memoryUsage?.current.heapTotal * 100);
        if (memoryUsage > this.config.thresholds.memoryUsage) {
          messages.push(`内存使用率: ${memoryUsage.toFixed(2)}%`);
        }
        return `系统资源使用率过高: ${messages.join(', ')}`;
      }
    });
  }

  private initializeHandlers() {
    // 日志告警处理器
    this.alertHandlers.push(new LogAlertHandler());
    
    // 邮件告警处理器（如果配置了）
    if (this.config.email?.enabled) {
      this.alertHandlers.push(new EmailAlertHandler(this.config.email));
    }
    
    // Webhook告警处理器（如果配置了）
    if (this.config.webhook?.enabled) {
      this.alertHandlers.push(new WebhookAlertHandler(this.config.webhook));
    }
  }

  // 检查数据是否触发告警
  checkAlerts(data: any) {
    for (const rule of this.rules) {
      if (rule.condition(data)) {
        const alert: Alert = {
          id: `${rule.id}-${Date.now()}`,
          ruleId: rule.id,
          ruleName: rule.name,
          severity: rule.severity,
          message: rule.message(data),
          timestamp: new Date(),
          data
        };
        
        this.triggerAlert(alert);
      }
    }
  }

  private async triggerAlert(alert: Alert) {
    console.log(`Alert triggered: ${alert.message}`);
    
    // 发送到所有告警处理器
    const promises = this.alertHandlers.map(handler => 
      handler.handleAlert(alert).catch(error => 
        console.error(`Alert handler error:`, error)
      )
    );
    
    await Promise.allSettled(promises);
  }
}

// 告警处理器接口
export interface AlertHandler {
  handleAlert(alert: Alert): Promise<void>;
}

// 日志告警处理器
export class LogAlertHandler implements AlertHandler {
  private logger = winston.createLogger({
    level: 'warn',
    format: winston.format.combine(
      winston.format.timestamp(),
      winston.format.json()
    ),
    transports: [
      new winston.transports.File({ filename: 'logs/alerts.log' })
    ]
  });

  async handleAlert(alert: Alert): Promise<void> {
    this.logger.warn('Alert triggered', {
      alertId: alert.id,
      ruleId: alert.ruleId,
      severity: alert.severity,
      message: alert.message,
      timestamp: alert.timestamp
    });
  }
}
```

## 7. 部署和运维

### 7.1 Docker配置

```dockerfile
# Dockerfile中的监控配置
FROM node:18-alpine

# 安装监控依赖
RUN apk add --no-cache curl

# 健康检查
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD curl -f http://localhost:3000/api/v2/health || exit 1

# 暴露监控端口
EXPOSE 3000 9090

# 设置监控环境变量
ENV MONITORING_ENABLED=true
ENV PROMETHEUS_ENABLED=true
ENV METRICS_PORT=9090

CMD ["npm", "start"]
```

### 7.2 Kubernetes配置

```yaml
# k8s-monitoring.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: oauth-monitoring-config
data:
  monitoring.json: |
    {
      "collection": {
        "enabled": true,
        "interval": 30000
      },
      "reporting": {
        "enabled": true,
        "interval": 15000
      },
      "adapters": {
        "prometheus": {
          "enabled": true,
          "gatewayUrl": "http://prometheus-pushgateway:9091"
        }
      }
    }

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: oauth-auth-center
spec:
  replicas: 3
  selector:
    matchLabels:
      app: oauth-auth-center
  template:
    metadata:
      labels:
        app: oauth-auth-center
      annotations:
        prometheus.io/scrape: "true"
        prometheus.io/port: "9090"
        prometheus.io/path: "/metrics"
    spec:
      containers:
      - name: oauth-auth-center
        image: oauth-auth-center:latest
        ports:
        - containerPort: 3000
          name: http
        - containerPort: 9090
          name: metrics
        env:
        - name: MONITORING_CONFIG_PATH
          value: "/config/monitoring.json"
        volumeMounts:
        - name: monitoring-config
          mountPath: /config
        livenessProbe:
          httpGet:
            path: /api/v2/health
            port: 3000
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /api/v2/health
            port: 3000
          initialDelaySeconds: 5
          periodSeconds: 5
      volumes:
      - name: monitoring-config
        configMap:
          name: oauth-monitoring-config

---
apiVersion: v1
kind: Service
metadata:
  name: oauth-auth-center-service
  labels:
    app: oauth-auth-center
spec:
  selector:
    app: oauth-auth-center
  ports:
  - name: http
    port: 80
    targetPort: 3000
  - name: metrics
    port: 9090
    targetPort: 9090
```

### 7.3 监控仪表板

```json
{
  "dashboard": {
    "title": "OAuth2.1认证授权中心监控",
    "panels": [
      {
        "title": "API响应时间",
        "type": "graph",
        "targets": [
          {
            "expr": "histogram_quantile(0.95, oauth_api_response_time_seconds_bucket)",
            "legendFormat": "95th percentile"
          },
          {
            "expr": "histogram_quantile(0.50, oauth_api_response_time_seconds_bucket)",
            "legendFormat": "50th percentile"
          }
        ]
      },
      {
        "title": "请求量",
        "type": "graph",
        "targets": [
          {
            "expr": "rate(oauth_api_response_time_seconds_count[5m])",
            "legendFormat": "Requests per second"
          }
        ]
      },
      {
        "title": "错误率",
        "type": "graph",
        "targets": [
          {
            "expr": "rate(oauth_api_response_time_seconds_count{status_code=~\"4..|5..\"}[5m]) / rate(oauth_api_response_time_seconds_count[5m]) * 100",
            "legendFormat": "Error rate %"
          }
        ]
      },
      {
        "title": "系统资源",
        "type": "graph",
        "targets": [
          {
            "expr": "oauth_system_resources{resource_type=\"cpu\"}",
            "legendFormat": "CPU Usage %"
          },
          {
            "expr": "oauth_system_resources{resource_type=\"memory\"}",
            "legendFormat": "Memory Usage"
          }
        ]
      },
      {
        "title": "业务指标",
        "type": "stat",
        "targets": [
          {
            "expr": "increase(oauth_business_events_total{event_type=\"login_attempt\"}[1h])",
            "legendFormat": "登录尝试/小时"
          },
          {
            "expr": "increase(oauth_business_events_total{event_type=\"oauth_authorization\"}[1h])",
            "legendFormat": "OAuth授权/小时"
          }
        ]
      }
    ]
  }
}
```

## 8. 总结

本文档详细描述了OAuth2.1认证授权中心的监控数据上报设计，包括：

1. **多层次数据收集**：从应用层、中间件层到基础设施层的全面监控
2. **智能数据聚合**：实时聚合和处理监控数据，减少存储和传输开销
3. **灵活上报机制**：支持多种监控平台的适配器模式
4. **实时告警系统**：基于规则引擎的智能告警机制
5. **可视化监控**：提供丰富的监控仪表板和图表

该设计确保了系统的可观测性，为运维团队提供了全面的监控能力，有助于及时发现和解决问题，保障系统的稳定运行。

---

**文档版本**: v1.0  
**创建日期**: 2024年12月  
**最后更新**: 2024年12月  
**维护者**: OAuth2.1认证授权中心开发团队