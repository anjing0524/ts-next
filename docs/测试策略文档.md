# Monorepo 微服务平台测试策略文档

**版本**: 4.0
**创建日期**: 2024-12-22
**状态**: 正式版
**维护团队**: 质量保障团队

## 文档摘要

本文档定义了 Monorepo 微服务平台的统一测试策略，旨在确保各微服务（特别是 `oauth-service`）的质量、稳定性和安全性。本文档为开发和测试团队提供了一套标准的测试流程和质量评估标准，并与 `详细设计文档.md` 保持同步。

**核心原则**：
- ✅ **TDD 优先**: 遵循测试驱动开发（TDD）原则，先写测试，再写实现。
- ✅ **真实数据测试**: 测试用例必须使用接近生产环境的真实数据，以确保测试的有效性。
- ✅ **自动化与集成**: 所有测试都应自动化，并集成到 CI/CD 流程中。
- ✅ **安全测试驱动**: 强调安全测试，确保所有安全机制都经过严格验证。

**技术栈确认**:
```json
{
  "测试框架": "Jest + @types/jest",
  "测试环境": "Node.js + Next.js 15",
  "数据库": "真实Prisma数据库 (无mock)",
  "JWT库": "jose@6.0.11 (ESM配置修复)",
  "覆盖率工具": "Jest内置覆盖率",
  "TDD工具": "Jest + describe/it + beforeEach"
}
```

## 目录

1. [TDD测试策略](#1-tdd测试策略)
2. [Jest配置与Jose库兼容](#2-jest配置与jose库兼容)
3. [真实测试数据管理](#3-真实测试数据管理)
4. [OAuth2.1流程TDD测试](#4-oauth21流程tdd测试)
5. [RBAC权限TDD测试](#5-rbac权限tdd测试)
6. [API端点单元测试](#6-api端点单元测试)
7. [集成测试策略](#7-集成测试策略)
8. [测试环境配置](#8-测试环境配置)
9. [测试报告与监控](#9-测试报告与监控)

## 1. TDD测试策略

### 1.1 TDD核心原则

遵循Kent Beck的TDD原则，专注于"编写干净可用的代码"：

- **Red阶段**: 编写一个失败的测试，明确需求
- **Green阶段**: 编写最小代码使测试通过
- **Refactor阶段**: 重构代码提高质量，保持测试通过
- **小步前进**: 每次迭代只关注一个小功能
- **测试先行**: 测试定义了代码应该做什么

### 1.2 测试层级策略

```
OAuth2.1 + RBAC测试金字塔
         /\
        /集成\     (30%) - OAuth2.1流程集成测试
       /______\
      /        \
     /  单元测试  \  (70%) - API端点和RBAC单元测试
    /__________\
```

**注意**: 删除了性能测试和E2E测试，专注于核心业务逻辑验证。

### 1.3 测试覆盖率目标

| 测试类型 | 覆盖率目标 | 关键指标 |
|---------|-----------|----------|
| 单元测试 | ≥ 85% | OAuth2.1端点覆盖率、RBAC逻辑覆盖率 |
| 集成测试 | ≥ 90% | 完整授权码流程覆盖率 |

### 1.4 测试驱动原则

**避免的反模式**:
- ❌ 过度使用mock/stub
- ❌ 测试实现细节而非行为
- ❌ 一个测试验证多个行为
- ❌ 测试之间相互依赖
- ❌ 复杂的测试逻辑

**推荐的实践**:
- ✅ 使用真实数据库和测试用户
- ✅ 测试API行为和权限验证
- ✅ 每个测试只验证一个行为
- ✅ 描述性的测试名称
- ✅ 快速的测试执行

## 2. Jest配置与Jose库兼容

### 2.1 Jest配置修复

解决Jose库ESM导入问题：

```typescript
// jest.config.ts
import type { Config } from '@jest/types';

const config: Config.InitialOptions = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  roots: ['<rootDir>'],
  testMatch: ['**/__tests__/**/*.(ts|js)', '**/*.(test|spec).(ts|js)'],
  transform: {
    '^.+\\.(ts|tsx)$': 'ts-jest',
  },
  // 关键: 修复Jose库ESM导入问题
  transformIgnorePatterns: [
    'node_modules/(?!(jose)/)'
  ],
  moduleNameMapping: {
    '^jose$': '<rootDir>/node_modules/jose/dist/node/esm/index.js'
  },
  extensionsToTreatAsEsm: ['.ts'],
  globals: {
    'ts-jest': {
      useESM: true
    }
  },
  setupFilesAfterEnv: ['<rootDir>/jest.setup.ts'],
  collectCoverageFrom: [
    'app/api/**/*.{ts,js}',
    'lib/**/*.{ts,js}',
    '!**/*.d.ts',
    '!**/node_modules/**',
  ],
  coverageDirectory: 'coverage',
  coverageReporters: ['text', 'lcov', 'html'],
  testTimeout: 10000,
};

export default config;
```

### 2.2 Jest Setup配置

```typescript
// jest.setup.ts
import { PrismaClient } from '@prisma/client';
import { beforeAll, afterAll, beforeEach } from '@jest/globals';

declare global {
  var prisma: PrismaClient;
}

beforeAll(async () => {
  global.prisma = new PrismaClient({
    datasources: {
      db: {
        url: process.env.TEST_DATABASE_URL || 'file:./test.db'
      }
    }
  });
  
  // 连接数据库
  await global.prisma.$connect();
});

afterAll(async () => {
  // 清理并断开连接
  await global.prisma.$disconnect();
});

beforeEach(async () => {
  // 每个测试前清理数据
  await cleanupTestData();
});

async function cleanupTestData() {
  await global.prisma.token.deleteMany();
  await global.prisma.authorizationCode.deleteMany();
  await global.prisma.userRole.deleteMany();
  await global.prisma.rolePermission.deleteMany();
  // 保留测试用户和客户端数据
}
```

## 3. 真实测试数据管理

### 3.1 测试用户数据

建立不同权限级别的测试用户：

```typescript
// __tests__/setup/test-data.ts
export interface TestUser {
  id: string;
  username: string;
  email: string;
  password: string;
  roles: string[];
  permissions: string[];
}

export const testUsers: Record<string, TestUser> = {
  systemAdmin: {
    id: 'test-system-admin-001',
    username: 'system.admin',
    email: 'system.admin@test.com',
    password: 'Test123!@#',
    roles: ['SYSTEM_ADMIN'],
    permissions: [
      'menu:*:*',
      'api:*:*',
      'system:admin:full'
    ]
  },
  
  userAdmin: {
    id: 'test-user-admin-001',
    username: 'user.admin',
    email: 'user.admin@test.com',
    password: 'Test123!@#',
    roles: ['USER_ADMIN'],
    permissions: [
      'menu:users:*',
      'api:users:*',
      'menu:dashboard:view'
    ]
  },
  
  permissionAdmin: {
    id: 'test-permission-admin-001',
    username: 'permission.admin',
    email: 'permission.admin@test.com',
    password: 'Test123!@#',
    roles: ['PERMISSION_ADMIN'],
    permissions: [
      'menu:roles:*',
      'menu:permissions:*',
      'api:roles:*',
      'api:permissions:*'
    ]
  },
  
  regularUser: {
    id: 'test-regular-user-001',
    username: 'regular.user',
    email: 'regular.user@test.com',
    password: 'Test123!@#',
    roles: ['USER'],
    permissions: [
      'menu:dashboard:view'
    ]
  },
  
  noPermissionUser: {
    id: 'test-no-permission-001',
    username: 'no.permission',
    email: 'no.permission@test.com',
    password: 'Test123!@#',
    roles: [],
    permissions: []
  }
};
```

### 3.2 测试客户端数据

```typescript
export interface TestClient {
  id: string;
  clientId: string;
  clientSecret?: string;
  name: string;
  redirectUris: string[];
  scopes: string[];
  grantTypes: string[];
}

export const testClients: Record<string, TestClient> = {
  webApp: {
    id: 'test-client-web-001',
    clientId: 'test-web-client',
    clientSecret: 'test-web-secret-123',
    name: '测试Web应用',
    redirectUris: [
      'http://localhost:3000/callback',
      'http://localhost:3001/auth/callback'
    ],
    scopes: ['openid', 'profile', 'email'],
    grantTypes: ['authorization_code', 'refresh_token']
  }
};
```

### 3.3 PKCE测试工具

```typescript
// __tests__/setup/pkce-utils.ts
import * as crypto from 'crypto';

export interface PKCEPair {
  codeVerifier: string;
  codeChallenge: string;
  codeChallengeMethod: 'S256';
}

export function generatePKCE(): PKCEPair {
  const codeVerifier = crypto.randomBytes(32).toString('base64url');
  const codeChallenge = crypto
    .createHash('sha256')
    .update(codeVerifier)
    .digest('base64url');
    
  return {
    codeVerifier,
    codeChallenge,
    codeChallengeMethod: 'S256'
  };
}
```

## 2. 测试策略

### 2.1 OAuth2.1 & OIDC 流程测试

- **授权码 + PKCE 流程**: 编写端到端测试，覆盖从 `/api/v2/oauth/authorize` 请求到 `/api/v2/oauth/token` 交换的完整流程，重点验证 PKCE (S256) 逻辑。
- **OIDC**: 验证 `/api/v2/oauth/userinfo` 端点返回的用户信息是否准确，并测试 `/.well-known/openid-configuration` 和 `/.well-known/jwks.json` 的可访问性和内容正确性。
- **令牌管理**: 测试 `/api/v2/oauth/revoke` 端点的令牌撤销功能，以及访问令牌和刷新令牌的过期逻辑。

### 2.2 管理端 API 测试

- **CRUD 操作**: 为 `/api/v2/users`, `/api/v2/roles`, `/api/v2/permissions`, `/api/v2/clients` 等所有管理端点编写单元和集成测试，验证其增删改查功能。
- **输入验证**: 使用 `Zod`  schema 对所有 API 的输入进行边界测试和无效数据测试。

### 2.3 RBAC 权限测试

- **角色分配**: 验证用户分配角色后，其 JWT `payload` 中的 `permissions` 声明是否正确。
- **API 访问控制**: 编写矩阵测试，覆盖不同角色对所有受保护 API 的访问权限，确保返回正确的 HTTP 状态码（200, 403, 401）。

### 2.4 安全机制测试

- **JWT 验证**: 测试 JWT 签名（RS256）、过期 (`exp`)、签发者 (`iss`) 和受众 (`aud`) 的验证逻辑。
- **密码哈希**: 验证 `bcrypt` 哈希和比对的正确性。
- **SQL 注入**: 确保所有使用 Prisma 的数据库查询都是参数化的，防止 SQL 注入。

## 3. 测试覆盖率

- **目标**: 核心业务逻辑（如 `oauth-service`）的测试覆盖率必须达到 **95%** 以上。
- **监控**: CI/CD 流水线将自动计算并报告测试覆盖率，低于阈值将导致构建失败。


**测试重点**:
- 参数验证（client_id, redirect_uri, response_type, scope等）
- PKCE强制执行
- 客户端验证
- 重定向URI验证
- 状态参数处理
- 错误重定向机制

**测试用例**:
```typescript
describe('/api/v2/oauth/authorize', () => {
  describe('参数验证', () => {
    it('应该验证必需的参数', async () => {
      const request = new NextRequest('http://localhost:3000/api/v2/oauth/authorize');
      const response = await GET(request);
      
      expect(response.status).toBe(400);
      const errorData = await response.json();
      expect(errorData.error.code).toBe('invalid_request');
    });
    
    it('应该验证response_type为code', async () => {
      const url = new URL('http://localhost:3000/api/v2/oauth/authorize');
      url.searchParams.set('response_type', 'token');
      url.searchParams.set('client_id', 'test_client');
      url.searchParams.set('redirect_uri', 'http://localhost:3000/callback');
      
      const request = new NextRequest(url);
      const response = await GET(request);
      
      expect(response.status).toBe(302);
      const location = response.headers.get('location');
      expect(location).toContain('error=unsupported_response_type');
    });
    
    it('应该验证redirect_uri匹配', async () => {
      const url = new URL('http://localhost:3000/api/v2/oauth/authorize');
      url.searchParams.set('response_type', 'code');
      url.searchParams.set('client_id', testClient.clientId);
      url.searchParams.set('redirect_uri', 'http://evil.com/callback');
      
      const request = new NextRequest(url);
      const response = await GET(request);
      
      expect(response.status).toBe(400);
      const errorData = await response.json();
      expect(errorData.error.code).toBe('invalid_request');
    });
  });
  
  describe('PKCE验证', () => {
    it('应该强制要求PKCE参数', async () => {
      const url = new URL('http://localhost:3000/api/v2/oauth/authorize');
      url.searchParams.set('response_type', 'code');
      url.searchParams.set('client_id', testClient.clientId);
      url.searchParams.set('redirect_uri', testClient.redirectUris[0]);
      url.searchParams.set('scope', 'openid');
      
      const request = new NextRequest(url);
      const response = await GET(request);
      
      expect(response.status).toBe(302);
      const location = response.headers.get('location');
      expect(location).toContain('error=invalid_request');
      expect(location).toContain('PKCE');
    });
    
    it('应该验证code_challenge_method为S256', async () => {
      const url = new URL('http://localhost:3000/api/v2/oauth/authorize');
      url.searchParams.set('response_type', 'code');
      url.searchParams.set('client_id', testClient.clientId);
      url.searchParams.set('redirect_uri', testClient.redirectUris[0]);
      url.searchParams.set('scope', 'openid');
      url.searchParams.set('code_challenge', 'test_challenge');
      url.searchParams.set('code_challenge_method', 'plain');
      
      const request = new NextRequest(url);
      const response = await GET(request);
      
      expect(response.status).toBe(302);
      const location = response.headers.get('location');
      expect(location).toContain('error=invalid_request');
    });
  });
  
  describe('用户认证', () => {
    it('应该重定向未认证用户到登录页面', async () => {
      const url = new URL('http://localhost:3000/api/v2/oauth/authorize');
      url.searchParams.set('response_type', 'code');
      url.searchParams.set('client_id', testClient.clientId);
      url.searchParams.set('redirect_uri', testClient.redirectUris[0]);
      url.searchParams.set('scope', 'openid');
      url.searchParams.set('code_challenge', validCodeChallenge);
      url.searchParams.set('code_challenge_method', 'S256');
      
      const request = new NextRequest(url);
      const response = await GET(request);
      
      expect(response.status).toBe(302);
      const location = response.headers.get('location');
      expect(location).toContain('/login');
    });
    
    it('应该为已认证用户继续授权流程', async () => {
      const url = new URL('http://localhost:3000/api/v2/oauth/authorize');
      url.searchParams.set('response_type', 'code');
      url.searchParams.set('client_id', testClient.clientId);
      url.searchParams.set('redirect_uri', testClient.redirectUris[0]);
      url.searchParams.set('scope', 'openid');
      url.searchParams.set('code_challenge', validCodeChallenge);
      url.searchParams.set('code_challenge_method', 'S256');
      
      const request = new NextRequest(url);
      request.cookies.set('auth_center_session_token', validSessionToken);
      
      const response = await GET(request);
      
      // 应该重定向到同意页面或直接返回授权码
      expect(response.status).toBe(302);
      const location = response.headers.get('location');
      expect(location).toMatch(/\/consent|\/callback.*code=/);
    });
  });
});
```

#### 2.1.2 令牌端点测试 (`/api/v2/oauth/token`)

**测试重点**:
- 授权码验证
- PKCE验证
- 客户端认证
- JWT令牌生成（使用Jose库）
- 刷新令牌处理

**测试用例**:
```typescript
import * as jose from 'jose';

describe('/api/v2/oauth/token', () => {
  describe('授权码模式', () => {
    it('应该验证授权码有效性', async () => {
      const formData = new FormData();
      formData.append('grant_type', 'authorization_code');
      formData.append('code', validAuthCode);
      formData.append('redirect_uri', testClient.redirectUris[0]);
      formData.append('client_id', testClient.clientId);
      formData.append('code_verifier', validCodeVerifier);
      
      const request = new NextRequest('http://localhost:3000/api/v2/oauth/token', {
        method: 'POST',
        body: formData,
      });
      
      const response = await POST(request);
      
      expect(response.status).toBe(200);
      const tokenData = await response.json();
      expect(tokenData.success).toBe(true);
      expect(tokenData.data.access_token).toBeDefined();
      expect(tokenData.data.token_type).toBe('Bearer');
    });
    
    it('应该验证PKCE', async () => {
      const formData = new FormData();
      formData.append('grant_type', 'authorization_code');
      formData.append('code', validAuthCode);
      formData.append('redirect_uri', testClient.redirectUris[0]);
      formData.append('client_id', testClient.clientId);
      formData.append('code_verifier', 'invalid_verifier');
      
      const request = new NextRequest('http://localhost:3000/api/v2/oauth/token', {
        method: 'POST',
        body: formData,
      });
      
      const response = await POST(request);
      
      expect(response.status).toBe(400);
      const errorData = await response.json();
      expect(errorData.error.code).toBe('invalid_grant');
    });
    
    it('应该生成有效的JWT令牌', async () => {
      const formData = new FormData();
      formData.append('grant_type', 'authorization_code');
      formData.append('code', validAuthCode);
      formData.append('redirect_uri', testClient.redirectUris[0]);
      formData.append('client_id', testClient.clientId);
      formData.append('code_verifier', validCodeVerifier);
      
      const request = new NextRequest('http://localhost:3000/api/v2/oauth/token', {
        method: 'POST',
        body: formData,
      });
      
      const response = await POST(request);
      const tokenData = await response.json();
      const accessToken = tokenData.data.access_token;
      
      // 使用Jose验证JWT结构
      const protectedHeader = jose.decodeProtectedHeader(accessToken);
      expect(protectedHeader.alg).toBe('RS256');
      expect(protectedHeader.kid).toBeDefined();
      
      const payload = jose.decodeJwt(accessToken);
      expect(payload.iss).toBeDefined();
      expect(payload.aud).toBeDefined();
      expect(payload.sub).toBeDefined();
      expect(payload.client_id).toBe(testClient.clientId);
      expect(payload.jti).toBeDefined();
    });
  });
  
  describe('客户端凭证模式', () => {
    it('应该验证客户端凭证', async () => {
      const formData = new FormData();
      formData.append('grant_type', 'client_credentials');
      formData.append('scope', 'api:read');
      
      const request = new NextRequest('http://localhost:3000/api/v2/oauth/token', {
        method: 'POST',
        headers: {
          'Authorization': `Basic ${btoa(`${testClient.clientId}:${testClient.clientSecret}`)}`,
        },
        body: formData,
      });
      
      const response = await POST(request);
      
      expect(response.status).toBe(200);
      const tokenData = await response.json();
      expect(tokenData.data.access_token).toBeDefined();
      expect(tokenData.data.refresh_token).toBeUndefined(); // 客户端凭证模式不返回refresh token
    });
  });
  
  describe('刷新令牌模式', () => {
    it('应该验证刷新令牌', async () => {
      const formData = new FormData();
      formData.append('grant_type', 'refresh_token');
      formData.append('refresh_token', validRefreshToken);
      formData.append('client_id', testClient.clientId);
      
      const request = new NextRequest('http://localhost:3000/api/v2/oauth/token', {
        method: 'POST',
        body: formData,
      });
      
      const response = await POST(request);
      
      expect(response.status).toBe(200);
      const tokenData = await response.json();
      expect(tokenData.data.access_token).toBeDefined();
      expect(tokenData.data.refresh_token).toBeDefined(); // 新的refresh token
    });
  });
});
```

### 2.2 OIDC流程测试

#### 2.2.1 用户信息端点测试 (`/api/v2/oauth/userinfo`)

**测试用例**:
```typescript
describe('/api/v2/oauth/userinfo', () => {
  it('应该返回用户基本信息', async () => {
    // 测试openid scope的用户信息
  });
  
  it('应该根据scope返回相应信息', async () => {
    // 测试profile scope
    // 测试email scope
  });
  
  it('应该验证访问令牌', async () => {
    // 测试有效令牌
    // 测试无效令牌
    // 测试过期令牌
  });
});
```

#### 2.2.2 JWKS端点测试 (`/.well-known/jwks.json`)

**测试用例**:
```typescript
describe('/.well-known/jwks.json', () => {
  it('应该返回有效的JWKS', async () => {
    // 验证JWKS格式
    // 验证公钥信息
  });
  
  it('应该支持密钥轮换', async () => {
    // 测试多个密钥的处理
  });
});
```

## 3. Jest与Next.js 15集成

### 3.1 Jest配置优化

本项目使用Jest作为唯一测试框架，配置如下：

```javascript
// jest.config.js
/** @type {import('jest').Config} */
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  
  // 测试文件匹配
  testMatch: [
    '**/__tests__/**/*.test.ts',
    '**/__tests__/**/*.test.js'
  ],
  
  // 模块路径映射 - 正确配置
  moduleNameMapper: {
    '^@/(.*)$': '<rootDir>/$1',
    '^@/lib/(.*)$': '<rootDir>/lib/$1',
    '^@/app/(.*)$': '<rootDir>/app/$1'
  },
  
  // 覆盖率配置
  collectCoverageFrom: [
    'app/api/**/*.ts',
    'lib/**/*.ts',
    '!**/*.d.ts',
    '!**/node_modules/**'
  ],
  
  // 设置文件
  setupFilesAfterEnv: ['<rootDir>/jest.setup.js'],
  
  // 转换配置
  transform: {
    '^.+\\.(ts|tsx)$': 'ts-jest'
  },
  
  // 测试超时
  testTimeout: 10000,
  
  verbose: true
};
```

### 3.2 真实数据库测试策略

**重要**: 本项目连接真实Prisma数据库进行测试，不使用mock：

```typescript
// __tests__/setup/test-helpers.ts
import { PrismaClient } from '@prisma/client';

// 全局数据库实例
let prisma: PrismaClient;

export async function setupTestDatabase() {
  prisma = new PrismaClient({
    datasources: {
      db: {
        url: process.env.DATABASE_URL || 'file:./test.db'
      }
    }
  });
  
  // 连接数据库
  await prisma.$connect();
  
  return prisma;
}

export async function cleanupTestDatabase() {
  if (prisma) {
    // 清理测试数据
    await prisma.accessToken.deleteMany();
    await prisma.authorizationCode.deleteMany();
    await prisma.oAuthClient.deleteMany();
    await prisma.user.deleteMany();
    
    await prisma.$disconnect();
  }
}

export function getPrismaClient() {
  return prisma;
}
```

### 3.3 Jest测试命令

```json
{
  "scripts": {
    "test": "jest",
    "test:watch": "jest --watch", 
    "test:coverage": "jest --coverage",
    "test:ci": "jest --ci --coverage --watchAll=false"
  }
}
```

## 4. 单元测试策略

### 4.1 JWTUtils类测试

```typescript
import { JWTUtils } from '@/lib/auth/oauth2';
import * as jose from 'jose';

describe('JWTUtils', () => {
  describe('createAccessToken', () => {
    it('应该创建有效的访问令牌', async () => {
      const payload = {
        client_id: 'test_client',
        user_id: 'test_user',
        scope: 'openid profile',
        permissions: ['user:read'],
      };
      
      const token = await JWTUtils.createAccessToken(payload);
      
      expect(token).toBeDefined();
      expect(typeof token).toBe('string');
      
      // 验证JWT结构
      const decodedHeader = jose.decodeProtectedHeader(token);
      expect(decodedHeader.alg).toBe('RS256');
      
      const decodedPayload = jose.decodeJwt(token);
      expect(decodedPayload.client_id).toBe('test_client');
      expect(decodedPayload.sub).toBe('test_user');
      expect(decodedPayload.scope).toBe('openid profile');
      expect(decodedPayload.permissions).toEqual(['user:read']);
    });
    
    it('应该设置正确的过期时间', async () => {
      const payload = {
        client_id: 'test_client',
        exp: '2h',
      };
      
      const token = await JWTUtils.createAccessToken(payload);
      const decodedPayload = jose.decodeJwt(token);
      
      const expectedExp = Math.floor(Date.now() / 1000) + (2 * 60 * 60);
      expect(decodedPayload.exp).toBeCloseTo(expectedExp, -2);
    });
  });
  
  describe('verifyAccessToken', () => {
    it('应该验证有效的访问令牌', async () => {
      const payload = {
        client_id: 'test_client',
        user_id: 'test_user',
      };
      
      const token = await JWTUtils.createAccessToken(payload);
      const result = await JWTUtils.verifyAccessToken(token);
      
      expect(result.valid).toBe(true);
      expect(result.payload).toBeDefined();
      expect(result.error).toBeUndefined();
    });
    
    it('应该拒绝过期的令牌', async () => {
      const payload = {
        client_id: 'test_client',
        exp: '-1h', // 过期时间设为1小时前
      };
      
      const token = await JWTUtils.createAccessToken(payload);
      const result = await JWTUtils.verifyAccessToken(token);
      
      expect(result.valid).toBe(false);
      expect(result.error).toContain('expired');
    });
    
    it('应该检查令牌黑名单', async () => {
      const mockPrisma = jest.mocked(prisma);
      mockPrisma.tokenBlacklist.findUnique.mockResolvedValue({
        id: '1',
        jti: 'test-jti',
        createdAt: new Date(),
      });
      
      const payload = {
        client_id: 'test_client',
      };
      
      const token = await JWTUtils.createAccessToken(payload);
      const result = await JWTUtils.verifyAccessToken(token);
      
      expect(result.valid).toBe(false);
      expect(result.error).toContain('revoked');
    });
  });
});
```

### 4.2 PKCE工具类测试

```typescript
import { PKCEUtils } from '@/lib/auth/oauth2';

describe('PKCEUtils', () => {
  describe('generateCodeVerifier', () => {
    it('应该生成符合规范的code verifier', () => {
      const verifier = PKCEUtils.generateCodeVerifier();
      
      expect(verifier).toBeDefined();
      expect(typeof verifier).toBe('string');
      expect(verifier.length).toBeGreaterThanOrEqual(43);
      expect(verifier.length).toBeLessThanOrEqual(128);
      expect(verifier).toMatch(/^[A-Za-z0-9\-_~]+$/);
    });
    
    it('应该生成唯一的verifier', () => {
      const verifier1 = PKCEUtils.generateCodeVerifier();
      const verifier2 = PKCEUtils.generateCodeVerifier();
      
      expect(verifier1).not.toBe(verifier2);
    });
  });
  
  describe('generateCodeChallenge', () => {
    it('应该生成正确的code challenge', () => {
      const verifier = 'dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk';
      const challenge = PKCEUtils.generateCodeChallenge(verifier);
      
      expect(challenge).toBe('E9Melhoa2OwvFrEMTJguCHaoeK1t8URWbuGJSstw-cM');
    });
  });
  
  describe('verifyCodeChallenge', () => {
    it('应该验证正确的PKCE对', () => {
      const verifier = 'dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk';
      const challenge = 'E9Melhoa2OwvFrEMTJguCHaoeK1t8URWbuGJSstw-cM';
      
      const isValid = PKCEUtils.verifyCodeChallenge(verifier, challenge, 'S256');
      
      expect(isValid).toBe(true);
    });
    
    it('应该拒绝错误的PKCE对', () => {
      const verifier = 'wrong_verifier';
      const challenge = 'E9Melhoa2OwvFrEMTJguCHaoeK1t8URWbuGJSstw-cM';
      
      const isValid = PKCEUtils.verifyCodeChallenge(verifier, challenge, 'S256');
      
      expect(isValid).toBe(false);
    });
  });
});
```

## 5. 集成测试策略

### 5.1 API端点集成测试

#### 5.1.1 OAuth流程集成测试

**测试文件**: `__tests__/integration/oauth-flow.test.ts`

```typescript
describe('OAuth2.1完整流程集成测试', () => {
  let testClient: any;
  let testUser: any;
  
  beforeEach(async () => {
    // 创建测试客户端和用户
    testClient = await global.testUtils.createTestClient();
    testUser = await global.testUtils.createTestUser();
  });
  
  it('应该完成完整的授权码流程', async () => {
    // 1. 生成PKCE参数
    const codeVerifier = PKCEUtils.generateCodeVerifier();
    const codeChallenge = PKCEUtils.generateCodeChallenge(codeVerifier);
    
    // 2. 构建授权URL
    const authorizeUrl = new URL('/api/v2/oauth/authorize', 'http://localhost:3000');
    authorizeUrl.searchParams.set('client_id', testClient.clientId);
    authorizeUrl.searchParams.set('redirect_uri', 'http://localhost:3000/callback');
    authorizeUrl.searchParams.set('response_type', 'code');
    authorizeUrl.searchParams.set('scope', 'openid profile');
    authorizeUrl.searchParams.set('state', 'test_state');
    authorizeUrl.searchParams.set('code_challenge', codeChallenge);
    authorizeUrl.searchParams.set('code_challenge_method', 'S256');
    
    // 3. 模拟用户登录和授权
    const authorizeRequest = new NextRequest(authorizeUrl.toString());
    // 添加用户会话token
    authorizeRequest.headers.set('Authorization', `Bearer ${userSessionToken}`);
    
    const authorizeResponse = await GET(authorizeRequest);
    
    // 4. 提取授权码
    expect(authorizeResponse.status).toBe(302);
    const location = authorizeResponse.headers.get('Location');
    const callbackUrl = new URL(location!);
    const code = callbackUrl.searchParams.get('code');
    
    expect(code).toBeDefined();
    
    // 5. 交换访问令牌
    const tokenRequest = new NextRequest('/api/v2/oauth/token', {
      method: 'POST',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      body: new URLSearchParams({
        grant_type: 'authorization_code',
        code: code!,
        redirect_uri: 'http://localhost:3000/callback',
        client_id: testClient.clientId,
        code_verifier: codeVerifier
      })
    });
    
    const tokenResponse = await POST(tokenRequest);
    expect(tokenResponse.status).toBe(200);
    
    const tokens = await tokenResponse.json();
    expect(tokens.access_token).toBeDefined();
    expect(tokens.refresh_token).toBeDefined();
    expect(tokens.token_type).toBe('Bearer');
    
    // 6. 使用访问令牌调用API
    const userInfoRequest = new NextRequest('/api/v2/oauth/userinfo', {
      headers: { Authorization: `Bearer ${tokens.access_token}` }
    });
    
    const userInfoResponse = await GET(userInfoRequest);
    expect(userInfoResponse.status).toBe(200);
    
    const userInfo = await userInfoResponse.json();
    expect(userInfo.sub).toBe(testUser.id);
  });
});
```

## 6. 端到端测试策略

### 6.1 浏览器自动化测试

使用Playwright进行端到端测试：

**测试文件**: `e2e/oauth-flow.spec.ts`

```typescript
import { test, expect } from '@playwright/test';

test.describe('OAuth2.1授权流程', () => {
  test('用户应该能够完成完整的授权流程', async ({ page }) => {
    // 1. 访问客户端应用
    await page.goto('/demo-client');
    
    // 2. 点击登录按钮
    await page.click('button[data-testid="login-button"]');
    
    // 3. 应该重定向到授权服务器
    await expect(page).toHaveURL(/\/api\/v2\/oauth\/authorize/);
    
    // 4. 应该重定向到登录页面
    await expect(page).toHaveURL(/\/login/);
    
    // 5. 填写登录表单
    await page.fill('input[name="username"]', 'testuser');
    await page.fill('input[name="password"]', 'password');
    await page.click('button[type="submit"]');
    
    // 6. 应该显示授权同意页面
    await expect(page).toHaveURL(/\/consent/);
    await expect(page.locator('h1')).toContainText('授权确认');
    
    // 7. 确认授权
    await page.click('button[data-testid="approve-button"]');
    
    // 8. 应该重定向回客户端应用
    await expect(page).toHaveURL(/\/demo-client/);
    
    // 9. 验证用户已登录
    await expect(page.locator('[data-testid="user-info"]')).toBeVisible();
  });
  
  test('用户应该能够拒绝授权', async ({ page }) => {
    // 类似流程，但点击拒绝按钮
    // 验证错误处理
  });
});
```

## 7. 安全测试策略

### 7.1 PKCE安全测试

```typescript
describe('PKCE安全测试', () => {
  it('应该防止授权码拦截攻击', async () => {
    // 测试没有正确code_verifier的情况
  });
  
  it('应该强制使用S256方法', async () => {
    // 测试plain方法被拒绝
  });
});
```

### 7.2 JWT安全测试

```typescript
describe('JWT安全测试', () => {
  it('应该验证JWT签名', async () => {
    // 测试篡改的JWT被拒绝
  });
  
  it('应该检查令牌过期', async () => {
    // 测试过期令牌被拒绝
  });
  
  it('应该支持令牌撤销', async () => {
    // 测试撤销的令牌被拒绝
  });
});
```

## 8. 性能测试策略

### 8.1 负载测试

使用k6进行负载测试：

```javascript
// performance/oauth-load.js
import http from 'k6/http';
import { check } from 'k6';

export let options = {
  stages: [
    { duration: '2m', target: 100 },
    { duration: '5m', target: 100 },
    { duration: '2m', target: 200 },
    { duration: '5m', target: 200 },
    { duration: '2m', target: 0 },
  ],
};

export default function () {
  // 测试令牌端点性能
  let response = http.post('http://localhost:3000/api/v2/oauth/token', {
    grant_type: 'client_credentials',
    client_id: 'test_client',
    client_secret: 'test_secret',
    scope: 'api:read'
  });
  
  check(response, {
    'status is 200': (r) => r.status === 200,
    'response time < 500ms': (r) => r.timings.duration < 500,
  });
}
```

## 9. 测试环境配置

### 9.1 Jest配置

**文件**: `jest.config.ts`

```typescript
export default {
  preset: 'ts-jest',
  testEnvironment: 'node',
  setupFilesAfterEnv: ['<rootDir>/jest.setup.ts'],
  testMatch: [
    '**/__tests__/**/*.test.ts',
    '**/__tests__/**/*.test.js'
  ],
  collectCoverageFrom: [
    'app/api/**/*.ts',
    'lib/**/*.ts',
    '!**/*.d.ts',
    '!**/node_modules/**'
  ],
  coverageThreshold: {
    global: {
      branches: 80,
      functions: 80,
      lines: 80,
      statements: 80
    }
  }
};
```

### 9.2 测试数据库配置

```typescript
// jest.setup.ts
import { prisma } from '@/lib/prisma';

beforeEach(async () => {
  // 清理测试数据
  await global.testUtils.cleanupTestData();
});

afterAll(async () => {
  await prisma.$disconnect();
});
```

## 10. 测试数据管理

### 10.1 测试工具函数

```typescript
// jest.setup.ts
global.testUtils = {
  // 创建测试用户
  createTestUser: async (overrides = {}) => {
    const bcrypt = require('bcrypt');
    const { prisma } = require('@/lib/prisma');

    const defaultUser = {
      username: `testuser_${Date.now()}`,
      passwordHash: await bcrypt.hash('testpassword123', 10),
      displayName: 'Test User',
      isActive: true,
      ...overrides,
    };

    return await prisma.user.create({ data: defaultUser });
  },

  // 创建测试OAuth客户端
  createTestClient: async (overrides = {}) => {
    const { prisma } = require('@/lib/prisma');
    const bcrypt = require('bcrypt');

    const defaultClient = {
      clientId: `test_client_${Date.now()}`,
      clientSecret: await bcrypt.hash('test_secret', 10),
      name: 'Test Client',
      clientType: 'CONFIDENTIAL',
      redirectUris: JSON.stringify(['http://localhost:3000/callback']),
      grantTypes: JSON.stringify(['authorization_code', 'client_credentials']),
      responseTypes: JSON.stringify(['code']),
      allowedScopes: JSON.stringify(['openid', 'profile', 'api:read']),
      isActive: true,
      requirePkce: true,
      ...overrides,
    };

    return await prisma.oAuthClient.create({ data: defaultClient });
  },

  // 创建测试JWT令牌
  createTestJWT: async (payload = {}) => {
    const { JWTUtils } = require('@/lib/auth/oauth2');
    const defaultPayload = {
      client_id: 'test_client',
      user_id: 'test_user',
        scope: 'openid profile',
      ...payload,
    };

    return await JWTUtils.createAccessToken(defaultPayload);
  },

  // 清理测试数据
  cleanupTestData: async () => {
    const { prisma } = require('@/lib/prisma');

    // 按依赖关系顺序清理
    await prisma.auditLog.deleteMany({});
    await prisma.accessToken.deleteMany({});
    await prisma.refreshToken.deleteMany({});
    await prisma.authorizationCode.deleteMany({});
    await prisma.consentGrant.deleteMany({});
    await prisma.userRole.deleteMany({});
    await prisma.rolePermission.deleteMany({});
    await prisma.oAuthClient.deleteMany({});
    await prisma.user.deleteMany({});
    await prisma.role.deleteMany({});
    await prisma.permission.deleteMany({});
    await prisma.scope.deleteMany({});
    await prisma.tokenBlacklist.deleteMany({});
  },
};
```

## 11. 测试报告与监控

### 11.1 测试报告

使用Jest生成详细的测试报告：

```json
{
  "scripts": {
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage",
    "test:ci": "jest --ci --coverage --watchAll=false"
  }
}
```

### 11.2 持续集成

GitHub Actions配置：

```yaml
# .github/workflows/test.yml
name: Test

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '18'
        cache: 'pnpm'
    
    - name: Install dependencies
      run: pnpm install
    
    - name: Run tests
      run: pnpm test:ci
    
    - name: Upload coverage
      uses: codecov/codecov-action@v3
```

这个更新后的测试策略文档专注于OAuth2.1标准流程的正确测试，移除了不符合标准的login端点测试，确保测试覆盖了所有关键的认证授权场景。