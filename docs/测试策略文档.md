# OAuth2.1认证授权中心测试策略文档

**版本**: v2.0  
**创建日期**: 2024-12-19  
**最后更新**: 2024-12-21  
**文档状态**: 正式版  
**维护团队**: 测试团队

## 文档摘要

本文档定义了OAuth2.1认证授权中心的全面测试策略，包括单元测试、集成测试、端到端测试和性能测试。重点关注OAuth2.1标准流程的正确实现和安全性验证。

**重要更新**: 
- ✅ 统一使用Jest作为测试框架
- ✅ 移除了关于独立login端点的测试策略
- ✅ 专注于标准OAuth2.1授权码流程的测试覆盖
- ✅ 更新了Jest与Next.js 15的集成配置
- ✅ 连接真实Prisma数据库进行测试（无mock）

**技术栈确认**:
```json
{
  "测试框架": "Jest + @types/jest",
  "测试环境": "Node.js + Next.js 15",
  "数据库": "真实Prisma数据库 (无mock)",
  "JWT库": "jose@6.0.11 (测试中使用)",
  "覆盖率工具": "Jest内置覆盖率",
  "Vitest": "已完全移除"
}
```

## 目录

1. [测试总体策略](#1-测试总体策略)
2. [OAuth2.1核心流程测试](#2-oauth21核心流程测试)
3. [Jest与Next.js 15集成](#3-jest与nextjs-15集成)
4. [单元测试策略](#4-单元测试策略)
5. [集成测试策略](#5-集成测试策略)
6. [端到端测试策略](#6-端到端测试策略)
7. [安全测试策略](#7-安全测试策略)
8. [性能测试策略](#8-性能测试策略)
9. [测试环境配置](#9-测试环境配置)
10. [测试数据管理](#10-测试数据管理)
11. [测试报告与监控](#11-测试报告与监控)

## 1. 测试总体策略

### 1.1 测试原则

- **标准合规性**: 确保完全符合OAuth2.1和OIDC标准
- **安全优先**: 重点测试安全机制和漏洞防护
- **自动化优先**: 最大化测试自动化覆盖率
- **持续集成**: 与CI/CD流程深度集成
- **真实场景**: 模拟真实的使用场景和边界条件
- **Jose库优先**: 所有JWT测试使用Jose库而非jsonwebtoken

### 1.2 测试金字塔

```
         /\
        /E2E\     (10%) - 端到端测试
       /______\
      /        \
     /Integration\ (20%) - 集成测试
    /__________\
   /            \
  /  Unit Tests  \  (70%) - 单元测试
 /________________\
```

### 1.3 测试覆盖率目标

| 测试类型 | 覆盖率目标 | 关键指标 |
|---------|-----------|----------|
| 单元测试 | ≥ 90% | 代码行覆盖率、分支覆盖率 |
| 集成测试 | ≥ 80% | API端点覆盖率、业务流程覆盖率 |
| 端到端测试 | ≥ 70% | 用户场景覆盖率、关键路径覆盖率 |

## 2. OAuth2.1核心流程测试

### 2.1 授权码流程测试

#### 2.1.1 授权端点测试 (`/api/v2/oauth/authorize`)

**测试重点**:
- 参数验证（client_id, redirect_uri, response_type, scope等）
- PKCE强制执行
- 客户端验证
- 重定向URI验证
- 状态参数处理
- 错误重定向机制

**测试用例**:
```typescript
describe('/api/v2/oauth/authorize', () => {
  describe('参数验证', () => {
    it('应该验证必需的参数', async () => {
      const request = new NextRequest('http://localhost:3000/api/v2/oauth/authorize');
      const response = await GET(request);
      
      expect(response.status).toBe(400);
      const errorData = await response.json();
      expect(errorData.error.code).toBe('invalid_request');
    });
    
    it('应该验证response_type为code', async () => {
      const url = new URL('http://localhost:3000/api/v2/oauth/authorize');
      url.searchParams.set('response_type', 'token');
      url.searchParams.set('client_id', 'test_client');
      url.searchParams.set('redirect_uri', 'http://localhost:3000/callback');
      
      const request = new NextRequest(url);
      const response = await GET(request);
      
      expect(response.status).toBe(302);
      const location = response.headers.get('location');
      expect(location).toContain('error=unsupported_response_type');
    });
    
    it('应该验证redirect_uri匹配', async () => {
      const url = new URL('http://localhost:3000/api/v2/oauth/authorize');
      url.searchParams.set('response_type', 'code');
      url.searchParams.set('client_id', testClient.clientId);
      url.searchParams.set('redirect_uri', 'http://evil.com/callback');
      
      const request = new NextRequest(url);
      const response = await GET(request);
      
      expect(response.status).toBe(400);
      const errorData = await response.json();
      expect(errorData.error.code).toBe('invalid_request');
    });
  });
  
  describe('PKCE验证', () => {
    it('应该强制要求PKCE参数', async () => {
      const url = new URL('http://localhost:3000/api/v2/oauth/authorize');
      url.searchParams.set('response_type', 'code');
      url.searchParams.set('client_id', testClient.clientId);
      url.searchParams.set('redirect_uri', testClient.redirectUris[0]);
      url.searchParams.set('scope', 'openid');
      
      const request = new NextRequest(url);
      const response = await GET(request);
      
      expect(response.status).toBe(302);
      const location = response.headers.get('location');
      expect(location).toContain('error=invalid_request');
      expect(location).toContain('PKCE');
    });
    
    it('应该验证code_challenge_method为S256', async () => {
      const url = new URL('http://localhost:3000/api/v2/oauth/authorize');
      url.searchParams.set('response_type', 'code');
      url.searchParams.set('client_id', testClient.clientId);
      url.searchParams.set('redirect_uri', testClient.redirectUris[0]);
      url.searchParams.set('scope', 'openid');
      url.searchParams.set('code_challenge', 'test_challenge');
      url.searchParams.set('code_challenge_method', 'plain');
      
      const request = new NextRequest(url);
      const response = await GET(request);
      
      expect(response.status).toBe(302);
      const location = response.headers.get('location');
      expect(location).toContain('error=invalid_request');
    });
  });
  
  describe('用户认证', () => {
    it('应该重定向未认证用户到登录页面', async () => {
      const url = new URL('http://localhost:3000/api/v2/oauth/authorize');
      url.searchParams.set('response_type', 'code');
      url.searchParams.set('client_id', testClient.clientId);
      url.searchParams.set('redirect_uri', testClient.redirectUris[0]);
      url.searchParams.set('scope', 'openid');
      url.searchParams.set('code_challenge', validCodeChallenge);
      url.searchParams.set('code_challenge_method', 'S256');
      
      const request = new NextRequest(url);
      const response = await GET(request);
      
      expect(response.status).toBe(302);
      const location = response.headers.get('location');
      expect(location).toContain('/login');
    });
    
    it('应该为已认证用户继续授权流程', async () => {
      const url = new URL('http://localhost:3000/api/v2/oauth/authorize');
      url.searchParams.set('response_type', 'code');
      url.searchParams.set('client_id', testClient.clientId);
      url.searchParams.set('redirect_uri', testClient.redirectUris[0]);
      url.searchParams.set('scope', 'openid');
      url.searchParams.set('code_challenge', validCodeChallenge);
      url.searchParams.set('code_challenge_method', 'S256');
      
      const request = new NextRequest(url);
      request.cookies.set('auth_center_session_token', validSessionToken);
      
      const response = await GET(request);
      
      // 应该重定向到同意页面或直接返回授权码
      expect(response.status).toBe(302);
      const location = response.headers.get('location');
      expect(location).toMatch(/\/consent|\/callback.*code=/);
    });
  });
});
```

#### 2.1.2 令牌端点测试 (`/api/v2/oauth/token`)

**测试重点**:
- 授权码验证
- PKCE验证
- 客户端认证
- JWT令牌生成（使用Jose库）
- 刷新令牌处理

**测试用例**:
```typescript
import * as jose from 'jose';

describe('/api/v2/oauth/token', () => {
  describe('授权码模式', () => {
    it('应该验证授权码有效性', async () => {
      const formData = new FormData();
      formData.append('grant_type', 'authorization_code');
      formData.append('code', validAuthCode);
      formData.append('redirect_uri', testClient.redirectUris[0]);
      formData.append('client_id', testClient.clientId);
      formData.append('code_verifier', validCodeVerifier);
      
      const request = new NextRequest('http://localhost:3000/api/v2/oauth/token', {
        method: 'POST',
        body: formData,
      });
      
      const response = await POST(request);
      
      expect(response.status).toBe(200);
      const tokenData = await response.json();
      expect(tokenData.success).toBe(true);
      expect(tokenData.data.access_token).toBeDefined();
      expect(tokenData.data.token_type).toBe('Bearer');
    });
    
    it('应该验证PKCE', async () => {
      const formData = new FormData();
      formData.append('grant_type', 'authorization_code');
      formData.append('code', validAuthCode);
      formData.append('redirect_uri', testClient.redirectUris[0]);
      formData.append('client_id', testClient.clientId);
      formData.append('code_verifier', 'invalid_verifier');
      
      const request = new NextRequest('http://localhost:3000/api/v2/oauth/token', {
        method: 'POST',
        body: formData,
      });
      
      const response = await POST(request);
      
      expect(response.status).toBe(400);
      const errorData = await response.json();
      expect(errorData.error.code).toBe('invalid_grant');
    });
    
    it('应该生成有效的JWT令牌', async () => {
      const formData = new FormData();
      formData.append('grant_type', 'authorization_code');
      formData.append('code', validAuthCode);
      formData.append('redirect_uri', testClient.redirectUris[0]);
      formData.append('client_id', testClient.clientId);
      formData.append('code_verifier', validCodeVerifier);
      
      const request = new NextRequest('http://localhost:3000/api/v2/oauth/token', {
        method: 'POST',
        body: formData,
      });
      
      const response = await POST(request);
      const tokenData = await response.json();
      const accessToken = tokenData.data.access_token;
      
      // 使用Jose验证JWT结构
      const protectedHeader = jose.decodeProtectedHeader(accessToken);
      expect(protectedHeader.alg).toBe('RS256');
      expect(protectedHeader.kid).toBeDefined();
      
      const payload = jose.decodeJwt(accessToken);
      expect(payload.iss).toBeDefined();
      expect(payload.aud).toBeDefined();
      expect(payload.sub).toBeDefined();
      expect(payload.client_id).toBe(testClient.clientId);
      expect(payload.jti).toBeDefined();
    });
  });
  
  describe('客户端凭证模式', () => {
    it('应该验证客户端凭证', async () => {
      const formData = new FormData();
      formData.append('grant_type', 'client_credentials');
      formData.append('scope', 'api:read');
      
      const request = new NextRequest('http://localhost:3000/api/v2/oauth/token', {
        method: 'POST',
        headers: {
          'Authorization': `Basic ${btoa(`${testClient.clientId}:${testClient.clientSecret}`)}`,
        },
        body: formData,
      });
      
      const response = await POST(request);
      
      expect(response.status).toBe(200);
      const tokenData = await response.json();
      expect(tokenData.data.access_token).toBeDefined();
      expect(tokenData.data.refresh_token).toBeUndefined(); // 客户端凭证模式不返回refresh token
    });
  });
  
  describe('刷新令牌模式', () => {
    it('应该验证刷新令牌', async () => {
      const formData = new FormData();
      formData.append('grant_type', 'refresh_token');
      formData.append('refresh_token', validRefreshToken);
      formData.append('client_id', testClient.clientId);
      
      const request = new NextRequest('http://localhost:3000/api/v2/oauth/token', {
        method: 'POST',
        body: formData,
      });
      
      const response = await POST(request);
      
      expect(response.status).toBe(200);
      const tokenData = await response.json();
      expect(tokenData.data.access_token).toBeDefined();
      expect(tokenData.data.refresh_token).toBeDefined(); // 新的refresh token
    });
  });
});
```

### 2.2 OIDC流程测试

#### 2.2.1 用户信息端点测试 (`/api/v2/oauth/userinfo`)

**测试用例**:
```typescript
describe('/api/v2/oauth/userinfo', () => {
  it('应该返回用户基本信息', async () => {
    // 测试openid scope的用户信息
  });
  
  it('应该根据scope返回相应信息', async () => {
    // 测试profile scope
    // 测试email scope
  });
  
  it('应该验证访问令牌', async () => {
    // 测试有效令牌
    // 测试无效令牌
    // 测试过期令牌
  });
});
```

#### 2.2.2 JWKS端点测试 (`/.well-known/jwks.json`)

**测试用例**:
```typescript
describe('/.well-known/jwks.json', () => {
  it('应该返回有效的JWKS', async () => {
    // 验证JWKS格式
    // 验证公钥信息
  });
  
  it('应该支持密钥轮换', async () => {
    // 测试多个密钥的处理
  });
});
```

## 3. Jest与Next.js 15集成

### 3.1 Jest配置优化

本项目使用Jest作为唯一测试框架，配置如下：

```javascript
// jest.config.js
/** @type {import('jest').Config} */
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  
  // 测试文件匹配
  testMatch: [
    '**/__tests__/**/*.test.ts',
    '**/__tests__/**/*.test.js'
  ],
  
  // 模块路径映射 - 正确配置
  moduleNameMapper: {
    '^@/(.*)$': '<rootDir>/$1',
    '^@/lib/(.*)$': '<rootDir>/lib/$1',
    '^@/app/(.*)$': '<rootDir>/app/$1'
  },
  
  // 覆盖率配置
  collectCoverageFrom: [
    'app/api/**/*.ts',
    'lib/**/*.ts',
    '!**/*.d.ts',
    '!**/node_modules/**'
  ],
  
  // 设置文件
  setupFilesAfterEnv: ['<rootDir>/jest.setup.js'],
  
  // 转换配置
  transform: {
    '^.+\\.(ts|tsx)$': 'ts-jest'
  },
  
  // 测试超时
  testTimeout: 10000,
  
  verbose: true
};
```

### 3.2 真实数据库测试策略

**重要**: 本项目连接真实Prisma数据库进行测试，不使用mock：

```typescript
// __tests__/setup/test-helpers.ts
import { PrismaClient } from '@prisma/client';

// 全局数据库实例
let prisma: PrismaClient;

export async function setupTestDatabase() {
  prisma = new PrismaClient({
    datasources: {
      db: {
        url: process.env.DATABASE_URL || 'file:./test.db'
      }
    }
  });
  
  // 连接数据库
  await prisma.$connect();
  
  return prisma;
}

export async function cleanupTestDatabase() {
  if (prisma) {
    // 清理测试数据
    await prisma.accessToken.deleteMany();
    await prisma.authorizationCode.deleteMany();
    await prisma.oAuthClient.deleteMany();
    await prisma.user.deleteMany();
    
    await prisma.$disconnect();
  }
}

export function getPrismaClient() {
  return prisma;
}
```

### 3.3 Jest测试命令

```json
{
  "scripts": {
    "test": "jest",
    "test:watch": "jest --watch", 
    "test:coverage": "jest --coverage",
    "test:ci": "jest --ci --coverage --watchAll=false"
  }
}
```

## 4. 单元测试策略

### 4.1 JWTUtils类测试

```typescript
import { JWTUtils } from '@/lib/auth/oauth2';
import * as jose from 'jose';

describe('JWTUtils', () => {
  describe('createAccessToken', () => {
    it('应该创建有效的访问令牌', async () => {
      const payload = {
        client_id: 'test_client',
        user_id: 'test_user',
        scope: 'openid profile',
        permissions: ['user:read'],
      };
      
      const token = await JWTUtils.createAccessToken(payload);
      
      expect(token).toBeDefined();
      expect(typeof token).toBe('string');
      
      // 验证JWT结构
      const decodedHeader = jose.decodeProtectedHeader(token);
      expect(decodedHeader.alg).toBe('RS256');
      
      const decodedPayload = jose.decodeJwt(token);
      expect(decodedPayload.client_id).toBe('test_client');
      expect(decodedPayload.sub).toBe('test_user');
      expect(decodedPayload.scope).toBe('openid profile');
      expect(decodedPayload.permissions).toEqual(['user:read']);
    });
    
    it('应该设置正确的过期时间', async () => {
      const payload = {
        client_id: 'test_client',
        exp: '2h',
      };
      
      const token = await JWTUtils.createAccessToken(payload);
      const decodedPayload = jose.decodeJwt(token);
      
      const expectedExp = Math.floor(Date.now() / 1000) + (2 * 60 * 60);
      expect(decodedPayload.exp).toBeCloseTo(expectedExp, -2);
    });
  });
  
  describe('verifyAccessToken', () => {
    it('应该验证有效的访问令牌', async () => {
      const payload = {
        client_id: 'test_client',
        user_id: 'test_user',
      };
      
      const token = await JWTUtils.createAccessToken(payload);
      const result = await JWTUtils.verifyAccessToken(token);
      
      expect(result.valid).toBe(true);
      expect(result.payload).toBeDefined();
      expect(result.error).toBeUndefined();
    });
    
    it('应该拒绝过期的令牌', async () => {
      const payload = {
        client_id: 'test_client',
        exp: '-1h', // 过期时间设为1小时前
      };
      
      const token = await JWTUtils.createAccessToken(payload);
      const result = await JWTUtils.verifyAccessToken(token);
      
      expect(result.valid).toBe(false);
      expect(result.error).toContain('expired');
    });
    
    it('应该检查令牌黑名单', async () => {
      const mockPrisma = jest.mocked(prisma);
      mockPrisma.tokenBlacklist.findUnique.mockResolvedValue({
        id: '1',
        jti: 'test-jti',
        createdAt: new Date(),
      });
      
      const payload = {
        client_id: 'test_client',
      };
      
      const token = await JWTUtils.createAccessToken(payload);
      const result = await JWTUtils.verifyAccessToken(token);
      
      expect(result.valid).toBe(false);
      expect(result.error).toContain('revoked');
    });
  });
});
```

### 4.2 PKCE工具类测试

```typescript
import { PKCEUtils } from '@/lib/auth/oauth2';

describe('PKCEUtils', () => {
  describe('generateCodeVerifier', () => {
    it('应该生成符合规范的code verifier', () => {
      const verifier = PKCEUtils.generateCodeVerifier();
      
      expect(verifier).toBeDefined();
      expect(typeof verifier).toBe('string');
      expect(verifier.length).toBeGreaterThanOrEqual(43);
      expect(verifier.length).toBeLessThanOrEqual(128);
      expect(verifier).toMatch(/^[A-Za-z0-9\-_~]+$/);
    });
    
    it('应该生成唯一的verifier', () => {
      const verifier1 = PKCEUtils.generateCodeVerifier();
      const verifier2 = PKCEUtils.generateCodeVerifier();
      
      expect(verifier1).not.toBe(verifier2);
    });
  });
  
  describe('generateCodeChallenge', () => {
    it('应该生成正确的code challenge', () => {
      const verifier = 'dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk';
      const challenge = PKCEUtils.generateCodeChallenge(verifier);
      
      expect(challenge).toBe('E9Melhoa2OwvFrEMTJguCHaoeK1t8URWbuGJSstw-cM');
    });
  });
  
  describe('verifyCodeChallenge', () => {
    it('应该验证正确的PKCE对', () => {
      const verifier = 'dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk';
      const challenge = 'E9Melhoa2OwvFrEMTJguCHaoeK1t8URWbuGJSstw-cM';
      
      const isValid = PKCEUtils.verifyCodeChallenge(verifier, challenge, 'S256');
      
      expect(isValid).toBe(true);
    });
    
    it('应该拒绝错误的PKCE对', () => {
      const verifier = 'wrong_verifier';
      const challenge = 'E9Melhoa2OwvFrEMTJguCHaoeK1t8URWbuGJSstw-cM';
      
      const isValid = PKCEUtils.verifyCodeChallenge(verifier, challenge, 'S256');
      
      expect(isValid).toBe(false);
    });
  });
});
```

## 5. 集成测试策略

### 5.1 API端点集成测试

#### 5.1.1 OAuth流程集成测试

**测试文件**: `__tests__/integration/oauth-flow.test.ts`

```typescript
describe('OAuth2.1完整流程集成测试', () => {
  let testClient: any;
  let testUser: any;
  
  beforeEach(async () => {
    // 创建测试客户端和用户
    testClient = await global.testUtils.createTestClient();
    testUser = await global.testUtils.createTestUser();
  });
  
  it('应该完成完整的授权码流程', async () => {
    // 1. 生成PKCE参数
    const codeVerifier = PKCEUtils.generateCodeVerifier();
    const codeChallenge = PKCEUtils.generateCodeChallenge(codeVerifier);
    
    // 2. 构建授权URL
    const authorizeUrl = new URL('/api/v2/oauth/authorize', 'http://localhost:3000');
    authorizeUrl.searchParams.set('client_id', testClient.clientId);
    authorizeUrl.searchParams.set('redirect_uri', 'http://localhost:3000/callback');
    authorizeUrl.searchParams.set('response_type', 'code');
    authorizeUrl.searchParams.set('scope', 'openid profile');
    authorizeUrl.searchParams.set('state', 'test_state');
    authorizeUrl.searchParams.set('code_challenge', codeChallenge);
    authorizeUrl.searchParams.set('code_challenge_method', 'S256');
    
    // 3. 模拟用户登录和授权
    const authorizeRequest = new NextRequest(authorizeUrl.toString());
    // 添加用户会话token
    authorizeRequest.headers.set('Authorization', `Bearer ${userSessionToken}`);
    
    const authorizeResponse = await GET(authorizeRequest);
    
    // 4. 提取授权码
    expect(authorizeResponse.status).toBe(302);
    const location = authorizeResponse.headers.get('Location');
    const callbackUrl = new URL(location!);
    const code = callbackUrl.searchParams.get('code');
    
    expect(code).toBeDefined();
    
    // 5. 交换访问令牌
    const tokenRequest = new NextRequest('/api/v2/oauth/token', {
      method: 'POST',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      body: new URLSearchParams({
        grant_type: 'authorization_code',
        code: code!,
        redirect_uri: 'http://localhost:3000/callback',
        client_id: testClient.clientId,
        code_verifier: codeVerifier
      })
    });
    
    const tokenResponse = await POST(tokenRequest);
    expect(tokenResponse.status).toBe(200);
    
    const tokens = await tokenResponse.json();
    expect(tokens.access_token).toBeDefined();
    expect(tokens.refresh_token).toBeDefined();
    expect(tokens.token_type).toBe('Bearer');
    
    // 6. 使用访问令牌调用API
    const userInfoRequest = new NextRequest('/api/v2/oauth/userinfo', {
      headers: { Authorization: `Bearer ${tokens.access_token}` }
    });
    
    const userInfoResponse = await GET(userInfoRequest);
    expect(userInfoResponse.status).toBe(200);
    
    const userInfo = await userInfoResponse.json();
    expect(userInfo.sub).toBe(testUser.id);
  });
});
```

## 6. 端到端测试策略

### 6.1 浏览器自动化测试

使用Playwright进行端到端测试：

**测试文件**: `e2e/oauth-flow.spec.ts`

```typescript
import { test, expect } from '@playwright/test';

test.describe('OAuth2.1授权流程', () => {
  test('用户应该能够完成完整的授权流程', async ({ page }) => {
    // 1. 访问客户端应用
    await page.goto('/demo-client');
    
    // 2. 点击登录按钮
    await page.click('button[data-testid="login-button"]');
    
    // 3. 应该重定向到授权服务器
    await expect(page).toHaveURL(/\/api\/v2\/oauth\/authorize/);
    
    // 4. 应该重定向到登录页面
    await expect(page).toHaveURL(/\/login/);
    
    // 5. 填写登录表单
    await page.fill('input[name="username"]', 'testuser');
    await page.fill('input[name="password"]', 'password');
    await page.click('button[type="submit"]');
    
    // 6. 应该显示授权同意页面
    await expect(page).toHaveURL(/\/consent/);
    await expect(page.locator('h1')).toContainText('授权确认');
    
    // 7. 确认授权
    await page.click('button[data-testid="approve-button"]');
    
    // 8. 应该重定向回客户端应用
    await expect(page).toHaveURL(/\/demo-client/);
    
    // 9. 验证用户已登录
    await expect(page.locator('[data-testid="user-info"]')).toBeVisible();
  });
  
  test('用户应该能够拒绝授权', async ({ page }) => {
    // 类似流程，但点击拒绝按钮
    // 验证错误处理
  });
});
```

## 7. 安全测试策略

### 7.1 PKCE安全测试

```typescript
describe('PKCE安全测试', () => {
  it('应该防止授权码拦截攻击', async () => {
    // 测试没有正确code_verifier的情况
  });
  
  it('应该强制使用S256方法', async () => {
    // 测试plain方法被拒绝
  });
});
```

### 7.2 JWT安全测试

```typescript
describe('JWT安全测试', () => {
  it('应该验证JWT签名', async () => {
    // 测试篡改的JWT被拒绝
  });
  
  it('应该检查令牌过期', async () => {
    // 测试过期令牌被拒绝
  });
  
  it('应该支持令牌撤销', async () => {
    // 测试撤销的令牌被拒绝
  });
});
```

## 8. 性能测试策略

### 8.1 负载测试

使用k6进行负载测试：

```javascript
// performance/oauth-load.js
import http from 'k6/http';
import { check } from 'k6';

export let options = {
  stages: [
    { duration: '2m', target: 100 },
    { duration: '5m', target: 100 },
    { duration: '2m', target: 200 },
    { duration: '5m', target: 200 },
    { duration: '2m', target: 0 },
  ],
};

export default function () {
  // 测试令牌端点性能
  let response = http.post('http://localhost:3000/api/v2/oauth/token', {
    grant_type: 'client_credentials',
    client_id: 'test_client',
    client_secret: 'test_secret',
    scope: 'api:read'
  });
  
  check(response, {
    'status is 200': (r) => r.status === 200,
    'response time < 500ms': (r) => r.timings.duration < 500,
  });
}
```

## 9. 测试环境配置

### 9.1 Jest配置

**文件**: `jest.config.ts`

```typescript
export default {
  preset: 'ts-jest',
  testEnvironment: 'node',
  setupFilesAfterEnv: ['<rootDir>/jest.setup.ts'],
  testMatch: [
    '**/__tests__/**/*.test.ts',
    '**/__tests__/**/*.test.js'
  ],
  collectCoverageFrom: [
    'app/api/**/*.ts',
    'lib/**/*.ts',
    '!**/*.d.ts',
    '!**/node_modules/**'
  ],
  coverageThreshold: {
    global: {
      branches: 80,
      functions: 80,
      lines: 80,
      statements: 80
    }
  }
};
```

### 9.2 测试数据库配置

```typescript
// jest.setup.ts
import { prisma } from '@/lib/prisma';

beforeEach(async () => {
  // 清理测试数据
  await global.testUtils.cleanupTestData();
});

afterAll(async () => {
  await prisma.$disconnect();
});
```

## 10. 测试数据管理

### 10.1 测试工具函数

```typescript
// jest.setup.ts
global.testUtils = {
  // 创建测试用户
  createTestUser: async (overrides = {}) => {
    const bcrypt = require('bcrypt');
    const { prisma } = require('@/lib/prisma');

    const defaultUser = {
      username: `testuser_${Date.now()}`,
      passwordHash: await bcrypt.hash('testpassword123', 10),
      displayName: 'Test User',
      isActive: true,
      ...overrides,
    };

    return await prisma.user.create({ data: defaultUser });
  },

  // 创建测试OAuth客户端
  createTestClient: async (overrides = {}) => {
    const { prisma } = require('@/lib/prisma');
    const bcrypt = require('bcrypt');

    const defaultClient = {
      clientId: `test_client_${Date.now()}`,
      clientSecret: await bcrypt.hash('test_secret', 10),
      name: 'Test Client',
      clientType: 'CONFIDENTIAL',
      redirectUris: JSON.stringify(['http://localhost:3000/callback']),
      grantTypes: JSON.stringify(['authorization_code', 'client_credentials']),
      responseTypes: JSON.stringify(['code']),
      allowedScopes: JSON.stringify(['openid', 'profile', 'api:read']),
      isActive: true,
      requirePkce: true,
      ...overrides,
    };

    return await prisma.oAuthClient.create({ data: defaultClient });
  },

  // 创建测试JWT令牌
  createTestJWT: async (payload = {}) => {
    const { JWTUtils } = require('@/lib/auth/oauth2');
    const defaultPayload = {
      client_id: 'test_client',
      user_id: 'test_user',
        scope: 'openid profile',
      ...payload,
    };

    return await JWTUtils.createAccessToken(defaultPayload);
  },

  // 清理测试数据
  cleanupTestData: async () => {
    const { prisma } = require('@/lib/prisma');

    // 按依赖关系顺序清理
    await prisma.auditLog.deleteMany({});
    await prisma.accessToken.deleteMany({});
    await prisma.refreshToken.deleteMany({});
    await prisma.authorizationCode.deleteMany({});
    await prisma.consentGrant.deleteMany({});
    await prisma.userRole.deleteMany({});
    await prisma.rolePermission.deleteMany({});
    await prisma.oAuthClient.deleteMany({});
    await prisma.user.deleteMany({});
    await prisma.role.deleteMany({});
    await prisma.permission.deleteMany({});
    await prisma.scope.deleteMany({});
    await prisma.tokenBlacklist.deleteMany({});
  },
};
```

## 11. 测试报告与监控

### 11.1 测试报告

使用Jest生成详细的测试报告：

```json
{
  "scripts": {
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage",
    "test:ci": "jest --ci --coverage --watchAll=false"
  }
}
```

### 11.2 持续集成

GitHub Actions配置：

```yaml
# .github/workflows/test.yml
name: Test

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '18'
        cache: 'pnpm'
    
    - name: Install dependencies
      run: pnpm install
    
    - name: Run tests
      run: pnpm test:ci
    
    - name: Upload coverage
      uses: codecov/codecov-action@v3
```

这个更新后的测试策略文档专注于OAuth2.1标准流程的正确测试，移除了不符合标准的login端点测试，确保测试覆盖了所有关键的认证授权场景。