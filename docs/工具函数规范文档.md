# 工具函数规范文档

## 1. 概述

本文档定义了项目中工具函数的设计规范、组织结构和使用指南，旨在提高代码的可复用性、可维护性和一致性。

### 1.1 设计原则

- **单一职责**: 每个工具函数只负责一个特定的功能
- **纯函数优先**: 尽量使用纯函数，避免副作用
- **类型安全**: 完善的 TypeScript 类型定义
- **可测试性**: 易于编写单元测试
- **性能优化**: 考虑函数的性能影响
- **错误处理**: 统一的错误处理机制
- **文档完善**: 每个函数都有详细的 JSDoc 注释

### 1.2 命名规范

- 使用动词开头的驼峰命名法
- 函数名应清晰表达其功能
- 避免使用缩写，除非是广泛认知的缩写
- 布尔返回值的函数使用 `is`、`has`、`can` 等前缀
- 异步函数名称应体现其异步特性

### 1.3 当前问题分析

基于对现有代码的分析，发现以下问题：

1. **工具函数分散**: 相关功能分布在不同文件中
2. **缺乏统一导出**: 没有统一的入口点
3. **类型定义不完善**: 部分函数缺少类型定义
4. **错误处理不一致**: 不同函数的错误处理方式不统一
5. **文档不完整**: 缺少详细的使用说明和示例

## 2. 目录结构

### 2.1 推荐结构

```
lib/
├── utils/
│   ├── index.ts          # 统一导出
│   ├── crypto.ts         # 加密解密工具
│   ├── validation.ts     # 数据验证工具
│   ├── logger.ts         # 日志工具
│   ├── errors.ts         # 错误处理工具
│   ├── cache.ts          # 缓存工具
│   ├── helpers.ts        # 通用辅助函数
│   ├── string.ts         # 字符串处理工具
│   ├── date.ts           # 日期时间工具
│   ├── format.ts         # 格式化工具
│   ├── array.ts          # 数组处理工具
│   ├── object.ts         # 对象处理工具
│   ├── url.ts            # URL 处理工具
│   └── file.ts           # 文件处理工具
└── types/
    └── utils.ts          # 工具函数类型定义
```

### 2.2 现有结构分析

当前 `lib` 目录结构：
```
lib/
├── auth/
│   ├── oauth2.ts          # 包含加密工具函数
│   └── middleware.ts      # 包含验证工具函数
├── services/
│   └── permission.ts      # 包含权限检查工具
├── utils/
│   └── logger.ts          # 日志工具
└── prisma.ts              # 数据库客户端
```

**需要重构的原因**：
- 加密工具函数散布在 `auth/oauth2.ts` 中
- 验证工具函数混合在业务逻辑中
- 缺乏统一的工具函数组织方式
- 没有完整的类型定义体系

## 3. 核心工具函数规范

### 3.1 加密工具 (crypto.ts)

```typescript
/**
 * 加密解密工具函数
 * 
 * @description 提供安全的加密、解密、哈希和随机数生成功能
 */

import { createHash, randomBytes, createCipheriv, createDecipheriv } from 'crypto';
import { encode as base64URLEncode, decode as base64URLDecode } from 'base64url';

/**
 * 生成指定长度的随机字符串
 * 
 * @param length 字符串长度
 * @param charset 字符集 (默认: URL 安全字符)
 * @returns 随机字符串
 * 
 * @example
 * ```typescript
 * const randomStr = generateRandomString(32);
 * console.log(randomStr); // "abc123def456..."
 * ```
 */
export function generateRandomString(
  length: number,
  charset: string = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~'
): string {
  if (length <= 0) {
    throw new Error('Length must be greater than 0');
  }
  
  const bytes = randomBytes(length);
  let result = '';
  
  for (let i = 0; i < length; i++) {
    result += charset[bytes[i] % charset.length];
  }
  
  return result;
}

/**
 * 计算 SHA256 哈希值
 * 
 * @param data 要哈希的数据
 * @returns 哈希值 (Buffer)
 * 
 * @example
 * ```typescript
 * const hash = sha256('hello world');
 * console.log(hash.toString('hex'));
 * ```
 */
export function sha256(data: string | Buffer): Buffer {
  return createHash('sha256').update(data).digest();
}

/**
 * Base64URL 编码
 * 
 * @param data 要编码的数据
 * @returns Base64URL 编码字符串
 * 
 * @example
 * ```typescript
 * const encoded = base64URLEncode(Buffer.from('hello'));
 * console.log(encoded); // "aGVsbG8"
 * ```
 */
export function base64URLEncode(data: Buffer | string): string {
  const buffer = typeof data === 'string' ? Buffer.from(data) : data;
  return buffer.toString('base64url');
}

/**
 * Base64URL 解码
 * 
 * @param data Base64URL 编码字符串
 * @returns 解码后的 Buffer
 * 
 * @example
 * ```typescript
 * const decoded = base64URLDecode('aGVsbG8');
 * console.log(decoded.toString()); // "hello"
 * ```
 */
export function base64URLDecode(data: string): Buffer {
  return Buffer.from(data, 'base64url');
}

/**
 * AES-256-GCM 加密
 * 
 * @param plaintext 明文
 * @param key 加密密钥 (32 字节)
 * @returns 加密结果 (包含 IV 和认证标签)
 * 
 * @example
 * ```typescript
 * const key = randomBytes(32);
 * const encrypted = encryptAES256GCM('secret data', key);
 * ```
 */
export function encryptAES256GCM(plaintext: string, key: Buffer): {
  encrypted: Buffer;
  iv: Buffer;
  tag: Buffer;
} {
  if (key.length !== 32) {
    throw new Error('Key must be 32 bytes for AES-256');
  }
  
  const iv = randomBytes(12); // 96-bit IV for GCM
  const cipher = createCipheriv('aes-256-gcm', key, iv);
  
  let encrypted = cipher.update(plaintext, 'utf8');
  encrypted = Buffer.concat([encrypted, cipher.final()]);
  
  const tag = cipher.getAuthTag();
  
  return { encrypted, iv, tag };
}

/**
 * AES-256-GCM 解密
 * 
 * @param encrypted 加密数据
 * @param key 解密密钥
 * @param iv 初始化向量
 * @param tag 认证标签
 * @returns 解密后的明文
 * 
 * @example
 * ```typescript
 * const decrypted = decryptAES256GCM(encrypted, key, iv, tag);
 * console.log(decrypted); // "secret data"
 * ```
 */
export function decryptAES256GCM(
  encrypted: Buffer,
  key: Buffer,
  iv: Buffer,
  tag: Buffer
): string {
  if (key.length !== 32) {
    throw new Error('Key must be 32 bytes for AES-256');
  }
  
  const decipher = createDecipheriv('aes-256-gcm', key, iv);
  decipher.setAuthTag(tag);
  
  let decrypted = decipher.update(encrypted);
  decrypted = Buffer.concat([decrypted, decipher.final()]);
  
  return decrypted.toString('utf8');
}

/**
 * 生成密码哈希 (使用 bcrypt 风格)
 * 
 * @param password 原始密码
 * @param saltRounds 盐轮数 (默认: 12)
 * @returns 密码哈希
 * 
 * @example
 * ```typescript
 * const hash = await hashPassword('mypassword');
 * ```
 */
export async function hashPassword(password: string, saltRounds: number = 12): Promise<string> {
  const bcrypt = await import('bcrypt');
  return bcrypt.hash(password, saltRounds);
}

/**
 * 验证密码
 * 
 * @param password 原始密码
 * @param hash 密码哈希
 * @returns 验证结果
 * 
 * @example
 * ```typescript
 * const isValid = await verifyPassword('mypassword', hash);
 * ```
 */
export async function verifyPassword(password: string, hash: string): Promise<boolean> {
  const bcrypt = await import('bcrypt');
  return bcrypt.compare(password, hash);
}
```

### 3.2 验证工具 (validation.ts)

```typescript
/**
 * 数据验证工具函数
 * 
 * @description 提供常用的数据验证功能
 */

import { z } from 'zod';

/**
 * 验证邮箱格式
 * 
 * @param email 邮箱地址
 * @returns 是否为有效邮箱
 * 
 * @example
 * ```typescript
 * const isValid = isValidEmail('user@example.com');
 * console.log(isValid); // true
 * ```
 */
export function isValidEmail(email: string): boolean {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(email);
}

/**
 * 验证 URL 格式
 * 
 * @param url URL 字符串
 * @returns 是否为有效 URL
 * 
 * @example
 * ```typescript
 * const isValid = isValidUrl('https://example.com');
 * console.log(isValid); // true
 * ```
 */
export function isValidUrl(url: string): boolean {
  try {
    new URL(url);
    return true;
  } catch {
    return false;
  }
}

/**
 * 验证 UUID 格式
 * 
 * @param uuid UUID 字符串
 * @returns 是否为有效 UUID
 * 
 * @example
 * ```typescript
 * const isValid = isValidUUID('123e4567-e89b-12d3-a456-426614174000');
 * console.log(isValid); // true
 * ```
 */
export function isValidUUID(uuid: string): boolean {
  const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
  return uuidRegex.test(uuid);
}

/**
 * 验证手机号格式 (中国大陆)
 * 
 * @param phone 手机号
 * @returns 是否为有效手机号
 * 
 * @example
 * ```typescript
 * const isValid = isValidPhone('13800138000');
 * console.log(isValid); // true
 * ```
 */
export function isValidPhone(phone: string): boolean {
  const phoneRegex = /^1[3-9]\d{9}$/;
  return phoneRegex.test(phone);
}

/**
 * 验证密码强度
 * 
 * @param password 密码
 * @param options 验证选项
 * @returns 验证结果
 * 
 * @example
 * ```typescript
 * const result = validatePasswordStrength('MyPassword123!');
 * console.log(result.isValid); // true
 * console.log(result.score); // 4
 * ```
 */
export function validatePasswordStrength(
  password: string,
  options: {
    minLength?: number;
    requireUppercase?: boolean;
    requireLowercase?: boolean;
    requireNumbers?: boolean;
    requireSpecialChars?: boolean;
  } = {}
): {
  isValid: boolean;
  score: number;
  feedback: string[];
} {
  const {
    minLength = 8,
    requireUppercase = true,
    requireLowercase = true,
    requireNumbers = true,
    requireSpecialChars = true
  } = options;
  
  const feedback: string[] = [];
  let score = 0;
  
  // 长度检查
  if (password.length < minLength) {
    feedback.push(`密码长度至少需要 ${minLength} 个字符`);
  } else {
    score += 1;
  }
  
  // 大写字母检查
  if (requireUppercase && !/[A-Z]/.test(password)) {
    feedback.push('密码需要包含大写字母');
  } else if (/[A-Z]/.test(password)) {
    score += 1;
  }
  
  // 小写字母检查
  if (requireLowercase && !/[a-z]/.test(password)) {
    feedback.push('密码需要包含小写字母');
  } else if (/[a-z]/.test(password)) {
    score += 1;
  }
  
  // 数字检查
  if (requireNumbers && !/\d/.test(password)) {
    feedback.push('密码需要包含数字');
  } else if (/\d/.test(password)) {
    score += 1;
  }
  
  // 特殊字符检查
  if (requireSpecialChars && !/[!@#$%^&*(),.?":{}|<>]/.test(password)) {
    feedback.push('密码需要包含特殊字符');
  } else if (/[!@#$%^&*(),.?":{}|<>]/.test(password)) {
    score += 1;
  }
  
  return {
    isValid: feedback.length === 0,
    score,
    feedback
  };
}

/**
 * 使用 Zod 进行数据验证
 * 
 * @param schema Zod 验证模式
 * @param data 要验证的数据
 * @returns 验证结果
 * 
 * @example
 * ```typescript
 * const userSchema = z.object({
 *   name: z.string().min(1),
 *   email: z.string().email(),
 *   age: z.number().min(0)
 * });
 * 
 * const result = validateWithZod(userSchema, {
 *   name: 'John',
 *   email: 'john@example.com',
 *   age: 25
 * });
 * ```
 */
export function validateWithZod<T>(
  schema: z.ZodSchema<T>,
  data: unknown
): {
  success: boolean;
  data?: T;
  errors?: string[];
} {
  try {
    const validatedData = schema.parse(data);
    return {
      success: true,
      data: validatedData
    };
  } catch (error) {
    if (error instanceof z.ZodError) {
      return {
        success: false,
        errors: error.errors.map(err => `${err.path.join('.')}: ${err.message}`)
      };
    }
    return {
      success: false,
      errors: ['验证失败']
    };
  }
}

/**
 * 清理和验证输入字符串
 * 
 * @param input 输入字符串
 * @param options 清理选项
 * @returns 清理后的字符串
 * 
 * @example
 * ```typescript
 * const cleaned = sanitizeInput('  Hello World!  ', {
 *   trim: true,
 *   removeHtml: true
 * });
 * console.log(cleaned); // "Hello World!"
 * ```
 */
export function sanitizeInput(
  input: string,
  options: {
    trim?: boolean;
    removeHtml?: boolean;
    maxLength?: number;
    allowedChars?: RegExp;
  } = {}
): string {
  let result = input;
  
  // 去除首尾空格
  if (options.trim !== false) {
    result = result.trim();
  }
  
  // 移除 HTML 标签
  if (options.removeHtml) {
    result = result.replace(/<[^>]*>/g, '');
  }
  
  // 限制长度
  if (options.maxLength && result.length > options.maxLength) {
    result = result.substring(0, options.maxLength);
  }
  
  // 过滤字符
  if (options.allowedChars) {
    result = result.replace(new RegExp(`[^${options.allowedChars.source}]`, 'g'), '');
  }
  
  return result;
}
```

### 3.3 错误处理工具 (errors.ts)

```typescript
/**
 * 错误处理工具
 * 
 * @description 提供统一的错误处理机制
 */

/**
 * 应用程序错误基类
 */
export abstract class AppError extends Error {
  abstract readonly statusCode: number;
  abstract readonly isOperational: boolean;
  
  constructor(message: string, public readonly context?: Record<string, any>) {
    super(message);
    this.name = this.constructor.name;
    
    // 确保堆栈跟踪正确
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
  }
}

/**
 * 验证错误
 */
export class ValidationError extends AppError {
  readonly statusCode = 400;
  readonly isOperational = true;
  
  constructor(message: string, public readonly field?: string, context?: Record<string, any>) {
    super(message, context);
  }
}

/**
 * 认证错误
 */
export class AuthenticationError extends AppError {
  readonly statusCode = 401;
  readonly isOperational = true;
  
  constructor(message: string = '认证失败', context?: Record<string, any>) {
    super(message, context);
  }
}

/**
 * 授权错误
 */
export class AuthorizationError extends AppError {
  readonly statusCode = 403;
  readonly isOperational = true;
  
  constructor(message: string = '权限不足', context?: Record<string, any>) {
    super(message, context);
  }
}

/**
 * 资源未找到错误
 */
export class NotFoundError extends AppError {
  readonly statusCode = 404;
  readonly isOperational = true;
  
  constructor(message: string = '资源未找到', context?: Record<string, any>) {
    super(message, context);
  }
}

/**
 * 业务逻辑错误
 */
export class BusinessError extends AppError {
  readonly statusCode = 422;
  readonly isOperational = true;
  
  constructor(message: string, context?: Record<string, any>) {
    super(message, context);
  }
}

/**
 * 系统错误
 */
export class SystemError extends AppError {
  readonly statusCode = 500;
  readonly isOperational = false;
  
  constructor(message: string = '系统内部错误', context?: Record<string, any>) {
    super(message, context);
  }
}

/**
 * 错误响应格式
 */
export interface ErrorResponse {
  /** 错误码 */
  code: string;
  /** 错误消息 */
  message: string;
  /** 详细信息 */
  details?: any;
  /** 请求 ID */
  requestId?: string;
  /** 时间戳 */
  timestamp: string;
}

/**
 * 格式化错误响应
 * 
 * @param error 错误对象
 * @param requestId 请求 ID
 * @returns 格式化的错误响应
 * 
 * @example
 * ```typescript
 * const error = new ValidationError('邮箱格式无效', 'email');
 * const response = formatErrorResponse(error, 'req-123');
 * ```
 */
export function formatErrorResponse(
  error: Error,
  requestId?: string
): ErrorResponse {
  const timestamp = new Date().toISOString();
  
  if (error instanceof AppError) {
    return {
      code: error.constructor.name,
      message: error.message,
      details: error.context,
      requestId,
      timestamp
    };
  }
  
  // 未知错误，不暴露详细信息
  return {
    code: 'SystemError',
    message: '系统内部错误',
    requestId,
    timestamp
  };
}

/**
 * 安全地执行异步函数
 * 
 * @param fn 异步函数
 * @returns 执行结果或错误
 * 
 * @example
 * ```typescript
 * const [error, result] = await safeAsync(() => fetchUserData(id));
 * if (error) {
 *   console.error('获取用户数据失败:', error);
 *   return;
 * }
 * console.log('用户数据:', result);
 * ```
 */
export async function safeAsync<T>(
  fn: () => Promise<T>
): Promise<[Error | null, T | null]> {
  try {
    const result = await fn();
    return [null, result];
  } catch (error) {
    return [error instanceof Error ? error : new Error(String(error)), null];
  }
}

/**
 * 重试机制
 * 
 * @param fn 要重试的函数
 * @param options 重试选项
 * @returns 执行结果
 * 
 * @example
 * ```typescript
 * const result = await retry(
 *   () => fetchDataFromAPI(),
 *   { maxAttempts: 3, delay: 1000 }
 * );
 * ```
 */
export async function retry<T>(
  fn: () => Promise<T>,
  options: {
    maxAttempts?: number;
    delay?: number;
    backoff?: 'linear' | 'exponential';
    shouldRetry?: (error: Error) => boolean;
  } = {}
): Promise<T> {
  const {
    maxAttempts = 3,
    delay = 1000,
    backoff = 'linear',
    shouldRetry = () => true
  } = options;
  
  let lastError: Error;
  
  for (let attempt = 1; attempt <= maxAttempts; attempt++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error instanceof Error ? error : new Error(String(error));
      
      if (attempt === maxAttempts || !shouldRetry(lastError)) {
        throw lastError;
      }
      
      // 计算延迟时间
      const currentDelay = backoff === 'exponential' 
        ? delay * Math.pow(2, attempt - 1)
        : delay * attempt;
      
      await new Promise(resolve => setTimeout(resolve, currentDelay));
    }
  }
  
  throw lastError!;
}
```

### 3.4 缓存工具 (cache.ts)

```typescript
/**
 * 缓存工具
 * 
 * @description 提供内存缓存和 Redis 缓存功能
 */

/**
 * 内存缓存项
 */
interface CacheItem<T> {
  value: T;
  expiry: number;
}

/**
 * 简单内存缓存
 */
export class MemoryCache<T = any> {
  private cache = new Map<string, CacheItem<T>>();
  private timers = new Map<string, NodeJS.Timeout>();
  
  /**
   * 设置缓存项
   * 
   * @param key 缓存键
   * @param value 缓存值
   * @param ttl 生存时间（毫秒）
   * 
   * @example
   * ```typescript
   * const cache = new MemoryCache<string>();
   * cache.set('user:123', 'John Doe', 60000); // 缓存 1 分钟
   * ```
   */
  set(key: string, value: T, ttl: number = 300000): void {
    const expiry = Date.now() + ttl;
    
    // 清除现有定时器
    const existingTimer = this.timers.get(key);
    if (existingTimer) {
      clearTimeout(existingTimer);
    }
    
    // 设置缓存项
    this.cache.set(key, { value, expiry });
    
    // 设置过期定时器
    const timer = setTimeout(() => {
      this.delete(key);
    }, ttl);
    
    this.timers.set(key, timer);
  }
  
  /**
   * 获取缓存项
   * 
   * @param key 缓存键
   * @returns 缓存值或 undefined
   * 
   * @example
   * ```typescript
   * const user = cache.get('user:123');
   * if (user) {
   *   console.log('缓存命中:', user);
   * }
   * ```
   */
  get(key: string): T | undefined {
    const item = this.cache.get(key);
    
    if (!item) {
      return undefined;
    }
    
    // 检查是否过期
    if (Date.now() > item.expiry) {
      this.delete(key);
      return undefined;
    }
    
    return item.value;
  }
  
  /**
   * 删除缓存项
   * 
   * @param key 缓存键
   * @returns 是否删除成功
   */
  delete(key: string): boolean {
    const timer = this.timers.get(key);
    if (timer) {
      clearTimeout(timer);
      this.timers.delete(key);
    }
    
    return this.cache.delete(key);
  }
  
  /**
   * 清空所有缓存
   */
  clear(): void {
    // 清除所有定时器
    for (const timer of this.timers.values()) {
      clearTimeout(timer);
    }
    
    this.cache.clear();
    this.timers.clear();
  }
  
  /**
   * 获取缓存大小
   * 
   * @returns 缓存项数量
   */
  size(): number {
    return this.cache.size;
  }
  
  /**
   * 检查缓存项是否存在
   * 
   * @param key 缓存键
   * @returns 是否存在
   */
  has(key: string): boolean {
    const item = this.cache.get(key);
    
    if (!item) {
      return false;
    }
    
    // 检查是否过期
    if (Date.now() > item.expiry) {
      this.delete(key);
      return false;
    }
    
    return true;
  }
}

/**
 * 缓存装饰器
 * 
 * @param ttl 生存时间（毫秒）
 * @param keyGenerator 键生成函数
 * @returns 装饰器函数
 * 
 * @example
 * ```typescript
 * class UserService {
 *   @cached(60000, (id: string) => `user:${id}`)
 *   async getUser(id: string) {
 *     return await fetchUserFromDB(id);
 *   }
 * }
 * ```
 */
export function cached<T extends (...args: any[]) => Promise<any>>(
  ttl: number = 300000,
  keyGenerator?: (...args: Parameters<T>) => string
) {
  const cache = new MemoryCache<Awaited<ReturnType<T>>>();
  
  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    const originalMethod = descriptor.value;
    
    descriptor.value = async function (...args: Parameters<T>) {
      // 生成缓存键
      const key = keyGenerator 
        ? keyGenerator(...args)
        : `${target.constructor.name}:${propertyKey}:${JSON.stringify(args)}`;
      
      // 尝试从缓存获取
      const cachedResult = cache.get(key);
      if (cachedResult !== undefined) {
        return cachedResult;
      }
      
      // 执行原方法
      const result = await originalMethod.apply(this, args);
      
      // 缓存结果
      cache.set(key, result, ttl);
      
      return result;
    };
    
    return descriptor;
  };
}

/**
 * 获取或设置缓存
 * 
 * @param cache 缓存实例
 * @param key 缓存键
 * @param factory 值工厂函数
 * @param ttl 生存时间
 * @returns 缓存值
 * 
 * @example
 * ```typescript
 * const cache = new MemoryCache<User>();
 * const user = await getOrSet(
 *   cache,
 *   'user:123',
 *   () => fetchUserFromDB('123'),
 *   60000
 * );
 * ```
 */
export async function getOrSet<T>(
  cache: MemoryCache<T>,
  key: string,
  factory: () => Promise<T> | T,
  ttl: number = 300000
): Promise<T> {
  // 尝试从缓存获取
  const cached = cache.get(key);
  if (cached !== undefined) {
    return cached;
  }
  
  // 生成新值
  const value = await factory();
  
  // 缓存新值
  cache.set(key, value, ttl);
  
  return value;
}

// 导出全局缓存实例
export const globalCache = new MemoryCache();
```

## 4. 类型定义规范

### 4.1 工具函数类型 (types/utils.ts)

```typescript
/**
 * 工具函数相关类型定义
 */

/**
 * 分页参数
 */
export interface PaginationParams {
  /** 页码 (从 1 开始) */
  page?: number;
  /** 每页大小 */
  pageSize?: number;
  /** 排序字段 */
  sortBy?: string;
  /** 排序方向 */
  sortOrder?: 'asc' | 'desc';
}

/**
 * 分页结果
 */
export interface PaginatedResult<T> {
  /** 数据列表 */
  data: T[];
  /** 分页元信息 */
  meta: {
    /** 当前页码 */
    page: number;
    /** 每页大小 */
    pageSize: number;
    /** 总记录数 */
    total: number;
    /** 总页数 */
    totalPages: number;
    /** 是否有下一页 */
    hasNext: boolean;
    /** 是否有上一页 */
    hasPrev: boolean;
  };
}

/**
 * API 响应格式
 */
export interface ApiResponse<T = any> {
  /** 是否成功 */
  success: boolean;
  /** 响应数据 */
  data?: T;
  /** 错误信息 */
  error?: {
    code: string;
    message: string;
    details?: any;
  };
  /** 请求 ID */
  requestId?: string;
  /** 时间戳 */
  timestamp: string;
}

/**
 * 日志级别
 */
export type LogLevel = 'debug' | 'info' | 'warn' | 'error';

/**
 * 日志条目
 */
export interface LogEntry {
  /** 日志级别 */
  level: LogLevel;
  /** 日志消息 */
  message: string;
  /** 时间戳 */
  timestamp: string;
  /** 上下文数据 */
  context?: Record<string, any>;
  /** 错误堆栈 */
  stack?: string;
}

/**
 * 缓存配置
 */
export interface CacheConfig {
  /** 默认 TTL (毫秒) */
  defaultTTL?: number;
  /** 最大缓存项数 */
  maxItems?: number;
  /** 是否启用 */
  enabled?: boolean;
}

/**
 * 重试配置
 */
export interface RetryConfig {
  /** 最大重试次数 */
  maxAttempts?: number;
  /** 延迟时间 (毫秒) */
  delay?: number;
  /** 退避策略 */
  backoff?: 'linear' | 'exponential';
  /** 是否应该重试的判断函数 */
  shouldRetry?: (error: Error) => boolean;
}

/**
 * 工具函数选项
 */
export interface UtilOptions {
  /** 缓存配置 */
  cache?: CacheConfig;
  /** 重试配置 */
  retry?: RetryConfig;
  /** 日志配置 */
  logging?: {
    level?: LogLevel;
    enabled?: boolean;
  };
}
```

## 5. 统一导出规范

### 5.1 utils/index.ts

```typescript
/**
 * 工具函数统一导出
 * 
 * @description 提供所有工具函数的统一入口
 */

// 加密工具
export {
  generateRandomString,
  sha256,
  base64URLEncode,
  base64URLDecode,
  encryptAES256GCM,
  decryptAES256GCM,
  hashPassword,
  verifyPassword
} from './crypto';

// 验证工具
export {
  isValidEmail,
  isValidUrl,
  isValidUUID,
  isValidPhone,
  validatePasswordStrength,
  validateWithZod,
  sanitizeInput
} from './validation';

// 错误处理
export {
  AppError,
  ValidationError,
  AuthenticationError,
  AuthorizationError,
  NotFoundError,
  BusinessError,
  SystemError,
  formatErrorResponse,
  safeAsync,
  retry
} from './errors';

// 缓存工具
export {
  MemoryCache,
  cached,
  getOrSet,
  globalCache
} from './cache';

// 日志工具
export {
  logger,
  createLogger,
  LogLevel
} from './logger';

// 类型定义
export type {
  PaginationParams,
  PaginatedResult,
  ApiResponse,
  LogLevel,
  LogEntry,
  CacheConfig,
  RetryConfig,
  UtilOptions
} from '../types/utils';
```

## 6. 使用示例

### 6.1 在 API 路由中使用

```typescript
// app/api/v2/users/route.ts
import { 
  validateWithZod, 
  formatErrorResponse, 
  ValidationError,
  logger,
  globalCache
} from '@/lib/utils';
import { z } from 'zod';

// 用户创建验证模式
const createUserSchema = z.object({
  name: z.string().min(1, '姓名不能为空'),
  email: z.string().email('邮箱格式无效'),
  password: z.string().min(8, '密码至少 8 位')
});

export async function POST(request: Request) {
  try {
    const body = await request.json();
    
    // 验证请求数据
    const validation = validateWithZod(createUserSchema, body);
    if (!validation.success) {
      throw new ValidationError('请求数据无效', undefined, {
        errors: validation.errors
      });
    }
    
    const userData = validation.data;
    
    // 检查缓存
    const cacheKey = `user:email:${userData.email}`;
    const existingUser = globalCache.get(cacheKey);
    if (existingUser) {
      throw new ValidationError('邮箱已存在');
    }
    
    // 创建用户逻辑...
    const user = await createUser(userData);
    
    // 缓存用户信息
    globalCache.set(cacheKey, user, 300000); // 5 分钟
    
    logger.info('用户创建成功', { userId: user.id, email: user.email });
    
    return Response.json({
      success: true,
      data: user,
      timestamp: new Date().toISOString()
    });
    
  } catch (error) {
    logger.error('创建用户失败', { error });
    
    const errorResponse = formatErrorResponse(
      error instanceof Error ? error : new Error('未知错误'),
      request.headers.get('x-request-id') || undefined
    );
    
    return Response.json(errorResponse, {
      status: error instanceof ValidationError ? 400 : 500
    });
  }
}
```

### 6.2 在服务类中使用

```typescript
// lib/services/user.ts
import { 
  hashPassword, 
  cached, 
  retry, 
  logger,
  BusinessError 
} from '@/lib/utils';
import { prisma } from '@/lib/database';

export class UserService {
  /**
   * 创建用户
   */
  async createUser(userData: {
    name: string;
    email: string;
    password: string;
  }) {
    // 检查邮箱是否已存在
    const existingUser = await this.getUserByEmail(userData.email);
    if (existingUser) {
      throw new BusinessError('邮箱已被使用');
    }
    
    // 哈希密码
    const hashedPassword = await hashPassword(userData.password);
    
    // 创建用户（带重试机制）
    const user = await retry(
      () => prisma.user.create({
        data: {
          ...userData,
          password: hashedPassword
        }
      }),
      { maxAttempts: 3, delay: 1000 }
    );
    
    logger.info('用户创建成功', { userId: user.id });
    
    return user;
  }
  
  /**
   * 根据邮箱获取用户（带缓存）
   */
  @cached(300000, (email: string) => `user:email:${email}`)
  async getUserByEmail(email: string) {
    return prisma.user.findUnique({
      where: { email }
    });
  }
}
```

## 7. 测试规范

### 7.1 单元测试示例

```typescript
// __tests__/lib/utils/validation.test.ts
import {
  isValidEmail,
  isValidUrl,
  validatePasswordStrength,
  sanitizeInput
} from '@/lib/utils/validation';

describe('验证工具函数', () => {
  describe('isValidEmail', () => {
    it('应该验证有效邮箱', () => {
      expect(isValidEmail('user@example.com')).toBe(true);
      expect(isValidEmail('test.email+tag@domain.co.uk')).toBe(true);
    });
    
    it('应该拒绝无效邮箱', () => {
      expect(isValidEmail('invalid-email')).toBe(false);
      expect(isValidEmail('@domain.com')).toBe(false);
      expect(isValidEmail('user@')).toBe(false);
    });
  });
  
  describe('validatePasswordStrength', () => {
    it('应该验证强密码', () => {
      const result = validatePasswordStrength('MyPassword123!');
      expect(result.isValid).toBe(true);
      expect(result.score).toBe(5);
      expect(result.feedback).toHaveLength(0);
    });
    
    it('应该识别弱密码', () => {
      const result = validatePasswordStrength('123');
      expect(result.isValid).toBe(false);
      expect(result.score).toBeLessThan(5);
      expect(result.feedback.length).toBeGreaterThan(0);
    });
  });
});
```

## 8. 性能优化建议

### 8.1 函数优化

1. **避免重复计算**: 使用缓存机制
2. **懒加载**: 按需导入大型依赖
3. **内存管理**: 及时清理缓存和定时器
4. **异步优化**: 使用 Promise.all 并行处理

### 8.2 缓存策略

1. **合理设置 TTL**: 根据数据更新频率设置
2. **缓存键设计**: 使用有意义的键名
3. **缓存大小控制**: 避免内存泄漏
4. **缓存失效策略**: 及时清理过期数据

## 9. 迁移计划

### 9.1 第一阶段：基础重构

1. 创建新的 utils 目录结构
2. 迁移现有工具函数
3. 添加类型定义
4. 创建统一导出

### 9.2 第二阶段：功能完善

1. 添加缺失的工具函数
2. 完善错误处理机制
3. 添加缓存功能
4. 优化性能

### 9.3 第三阶段：测试和文档

1. 编写完整的单元测试
2. 添加集成测试
3. 完善文档和示例
4. 性能测试和优化

## 10. 总结

通过本规范的实施，我们将建立一个：

- **统一的工具函数体系**
- **完善的类型安全保障**
- **高效的缓存机制**
- **健壮的错误处理**
- **清晰的代码组织结构**

这将显著提升代码质量、开发效率和系统稳定性。