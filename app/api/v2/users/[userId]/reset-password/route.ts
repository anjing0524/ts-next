// 文件路径: app/api/v2/users/[userId]/reset-password/route.ts
// 描述: 管理员为用户重置密码 (Admin resets a user's password)

import { NextRequest, NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { User, PasswordHistory, Prisma } from '@prisma/client';
import bcrypt from 'bcrypt';
import crypto from 'crypto'; // For generating random password
import { JWTUtils } from '@/lib/auth/oauth2';

const MIN_PASSWORD_LENGTH = 8;
const AUTOGENERATED_PASSWORD_LENGTH = 12; // 自动生成密码的长度 (Length of auto-generated password)

// --- 辅助函数 (Copied/adapted) ---
function errorResponse(message: string, status: number, errorCode?: string) {
  return NextResponse.json({ error: errorCode || 'request_failed', message }, { status });
}

async function isUserAdmin(userId: string): Promise<boolean> {
  // TODO: Implement real RBAC check.
  const userWithRoles = await prisma.user.findUnique({
    where: { id: userId },
    include: { userRoles: { include: { role: true } } }
  });
  return userWithRoles?.userRoles.some(ur => ur.role.name === 'admin') || false;
}

// 简单密码生成器 (Simple password generator)
function generateRandomPassword(length: number): string {
  // 包含大小写字母、数字。可以根据需要添加特殊字符。
  // (Includes uppercase, lowercase letters, and numbers. Special characters can be added if needed.)
  const charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
  let password = "";
  for (let i = 0, n = charset.length; i < length; ++i) {
    password += charset.charAt(Math.floor(crypto.randomBytes(1)[0] / 256 * n));
  }
  // 确保至少包含一个数字和一个大写字母 (Ensure at least one number and one uppercase letter for minimal complexity)
  if (!/\d/.test(password)) password += crypto.randomInt(0,9);
  if (!/[A-Z]/.test(password)) password += charset.charAt(crypto.randomInt(26,51));
  if (!/[a-z]/.test(password)) password += charset.charAt(crypto.randomInt(0,25));
  // Trim to desired length if additions made it longer
  return password.slice(0, length);
}


interface RouteContext {
  params: {
    userId: string; // 目标用户的ID (ID of the target user)
  };
}

// --- POST /api/v2/users/{userId}/reset-password (管理员重置用户密码) ---
export async function POST(req: NextRequest, context: RouteContext) {
  const { params } = context;
  const targetUserId = params.userId;

  // 1. 管理员认证 (Admin Authentication)
  const authHeader = req.headers.get('Authorization');
  if (!authHeader || !authHeader.toLowerCase().startsWith('bearer ')) return errorResponse('Unauthorized: Missing Authorization header.', 401, 'unauthorized');
  const token = authHeader.substring(7);
  if (!token) return errorResponse('Unauthorized: Missing token.', 401, 'unauthorized');

  const { valid, payload, error: tokenError } = await JWTUtils.verifyV2AuthAccessToken(token);
  if (!valid || !payload) return errorResponse(`Unauthorized: Invalid token. ${tokenError || ''}`.trim(), 401, 'invalid_token');
  const adminUserId = payload.userId as string | undefined;
  if (!adminUserId) return errorResponse('Unauthorized: Invalid token payload (Admin ID missing).', 401, 'invalid_token_payload');
  if (!(await isUserAdmin(adminUserId))) return errorResponse('Forbidden: Not an admin.', 403, 'forbidden');

  // 防止管理员通过此特定端点重置自己的密码 (Prevent admin from resetting their own password via this specific endpoint)
  if (targetUserId === adminUserId) {
    return errorResponse('Administrators should use the standard password change flow for their own account.', 400, 'self_reset_not_allowed');
  }

  // 2. 解析请求体 (Parse request body)
  let requestBody = {}; // 默认为空对象，以便处理没有请求体的情况 (Default to empty object to handle no-body case)
  const contentType = req.headers.get('content-type');
  if (contentType && contentType.includes('application/json')) {
    try {
      requestBody = await req.json();
    } catch (e) {
      return errorResponse('Invalid JSON request body.', 400, 'invalid_request');
    }
  }

  const { newPassword: providedPassword } = requestBody as { newPassword?: string };
  let finalNewPassword = providedPassword;
  let passwordWasAutogenerated = false;

  // 3. 确定新密码 (Determine new password)
  if (!finalNewPassword) {
    finalNewPassword = generateRandomPassword(AUTOGENERATED_PASSWORD_LENGTH);
    passwordWasAutogenerated = true;
    console.log(`Admin ${adminUserId} is auto-generating password for user ${targetUserId}.`);
  }

  // 4. 验证新密码 (Validate new password - if provided by admin)
  if (!passwordWasAutogenerated && finalNewPassword) { // 只有当密码由管理员提供时才验证 (Only validate if password was provided by admin)
    if (finalNewPassword.length < MIN_PASSWORD_LENGTH) {
      return errorResponse(`New password must be at least ${MIN_PASSWORD_LENGTH} characters long.`, 400, 'password_policy_violation');
    }
    // 可在此处添加其他密码复杂度检查 (Other password complexity checks can be added here)
  }

  try {
    // 5. 检查目标用户是否存在 (Check if target user exists)
    const userToUpdate = await prisma.user.findUnique({ where: { id: targetUserId } });
    if (!userToUpdate) return errorResponse('User not found to reset password.', 404, 'user_not_found');

    // (可选) 密码历史检查 - 对于管理员重置，可能不那么严格，但仍是好习惯
    // (Optional) Password history check - might be less strict for admin resets, but still good practice
    // 此处我们跳过历史检查，因为管理员操作具有更高权限，且通常用于恢复访问
    // (Here we skip history check as admin action has higher privilege and is often for recovery)

    // 6. 哈希新密码并更新用户 (Hash new password and update user)
    const newPasswordHash = await bcrypt.hash(finalNewPassword!, 10); // finalNewPassword is guaranteed to be a string here

    await prisma.$transaction(async (tx) => {
      // a. 更新用户密码和状态 (Update user's password and status)
      await tx.user.update({
        where: { id: targetUserId },
        data: {
          passwordHash: newPasswordHash,
          mustChangePassword: true, // 强制用户在下次登录时修改密码 (Force user to change password on next login)
          failedLoginAttempts: 0,   // 重置登录尝试 (Reset login attempts)
          lockedUntil: null,        // 解锁账户 (Unlock account)
          updatedAt: new Date(),
        },
      });

      // b. 将新密码哈希添加到历史记录 (Add new password hash to history)
      await tx.passwordHistory.create({
        data: {
          userId: targetUserId,
          passwordHash: newPasswordHash,
        },
      });
    });

    // 7. 构建并返回响应 (Construct and return response)
    const responsePayload: { message: string; newPassword?: string } = {
      message: 'Password reset successfully. User will be required to change it on next login.',
    };
    if (passwordWasAutogenerated) {
      responsePayload.newPassword = finalNewPassword; // 包含自动生成的密码 (Include auto-generated password)
    }

    return NextResponse.json(responsePayload, { status: 200 });

  } catch (error: any) {
    console.error(`Error resetting password for user ${targetUserId} by admin ${adminUserId}:`, error);
    return errorResponse('An unexpected error occurred while resetting the password.', 500, 'server_error');
  }
}
